<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html>

<!--
	Copyright (c) 1999-2008 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.bind - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="./style.css">
<link rel="icon" type="image/gif" href="./holy.gif" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="./dmlogo.gif" width="270" height="53" border="0" alt="www.digitalmars.com" align="left"></a>
	<p align="right">D Programming Language 1.0</p>


	<div id="headingNav">
	<ul>
	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Phobos/StdBind" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="http://www.digitalmars.com/d/1.0/index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Wed Oct  1 23:47:51 2008</div>
</div>

<!-- -->

<div id="navigation">
    <div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d/1.0/phobos">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>
	<li><a href="http://www.digitalmars.com/d/1.0/index.html" title="D Programming Language">D ...</a></li>
	<li><a href="http://www.digitalmars.com/d/1.0/lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="http://www.digitalmars.com/d/1.0/comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>
    <div class="navblock">
<ul>
<li><a href="index.html" title="Index of all HTML files">Index</a></li>
</ul>
    <ul>
	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="phobos.html#std" title="D standard modules">std</a></h2>
    <ul>
	<li><a href="std.base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std.bind.html" title="Function argument binding">std.bind</a></li>
	<li><a href="std.bitarray.html" title="Arrays of bits">std.bitarray</a></li>
	<li><a href="std.boxer.html" title="Box/unbox types">std.boxer</a></li>
	<li><a href="std.compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std.conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std.cover.html" title="D coverage analyzer">std.cover</a></li>
	<li><a href="std.cpuid.html" title="CPU identification">std.cpuid</a></li>
	<li><a href="std.ctype.html" title="Simple character classification">std.ctype</a></li>
	<li><a href="std.date.html" title="Date and time functions">std.date</a></li>
	<li><a href="std.demangle.html" title="Demangle D names">std.demangle</a></li>
	<li><a href="std.file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std.format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std.gc.html" title="Control the garbage collector">std.gc</a></li>
	<li><a href="std.intrinsic.html" title="Compiler built in intrinsic functions">std.intrinsic</a></li>
	<li><a href="std.math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std.md5.html" title="Compute MD5 digests">std.md5</a></li>
	<li><a href="std.metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std.mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std.openrj.html" title="Basic database">std.openrj</a></li>
	<li><a href="std.outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std.outofmemory.html" title="Out of memory exception">std.outofmemory</a></li>
	<li><a href="std.path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std.process.html" title="Create/destroy threads">std.process</a></li>
	<li><a href="std.random.html" title="Random number generation">std.random</a></li>
	<li><a href="std.regexp.html" title="regular expressions">std.regexp</a></li>
	<li><a href="std.signals.html" title="Signals">std.signals</a></li>
	<li><a href="std.socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std.socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std.stdint.html" title="Integral types for various purposes">std.stdint</a></li>
	<li><a href="std.stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std.cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std.stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std.string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std.system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std.thread.html" title="Thread operations">std.thread</a></li>
	<li><a href="std.traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std.typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std.uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std.uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std.utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std.zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std.zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std.c.fenv.html" title="Floating point environment">std.c.fenv</a></li>
	<li><a href="std.c.locale.html" title="Locale">std.c.locale</a></li>
	<li><a href="std.c.math.html" title="Math">std.c.math</a></li>
	<li><a href="std.c.process.html" title="Process">std.c.process</a></li>
	<li><a href="std.c.stdarg.html" title="Variadic arguments">std.c.stdarg</a></li>
	<li><a href="std.c.stddef.html" title="Standard definitions">std.c.stddef</a></li>
	<li><a href="std.c.stdio.html" title="Standard I/O">std.c.stdio</a></li>
	<li><a href="std.c.stdlib.html" title="Standard library">std.c.stdlib</a></li>
	<li><a href="std.c.string.html" title="Strings">std.c.string</a></li>
	<li><a href="std.c.time.html" title="Time">std.c.time</a></li>
	<li><a href="std.c.wcharh.html" title="Wide characters">std.c.wcharh</a></li>
	<li><a href="std.windows.charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
	<li><a href="phobos.html#std_windows" title="Modules specific to Windows">std.windows</a></li>
	<li><a href="phobos.html#std_linux" title="Modules specific to Windows">std.linux</a></li>
	<li><a href="phobos.html#std_c_windows" title="C Windows API">std.c.windows</a></li>
	<li><a href="phobos.html#std_c_linux" title="C Linux API">std.c.linux</a></li>
    </ul>
</div>
</div>
<div id="content">
    <h1><a href="./htmlsrc/std.bind.html">std.bind</a></h1>
    
Bind function arguments to functions.<br><br>
<b>References:</b><br><a href="http://www.boost.org/libs/bind/bind.html">boost::bind</a><br><br>
<b>Authors:</b><br>
Tomasz Stachowiak<br><br>
<b>Date:</b><br>
November 28, 2006<br><br>
<dl>
<dt><big>struct <a href="./htmlsrc/std.bind.html#L24" title="At line 24.">DynArg</a>(int i);</big></dt>
<dd>
<dl>
<dt><big>alias i <a href="./htmlsrc/std.bind.html#L27" title="At line 27.">argNr</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>DynArg!(0) <a href="./htmlsrc/std.bind.html#L35" title="At line 35.">_0</a>; [const]</big></dt>
<dt><big>DynArg!(1) <a href="./htmlsrc/std.bind.html#L36" title="At line 36.">_1</a>; [const]</big></dt>
<dt><big>DynArg!(2) <a href="./htmlsrc/std.bind.html#L37" title="At line 37.">_2</a>; [const]</big></dt>
<dt><big>DynArg!(3) <a href="./htmlsrc/std.bind.html#L38" title="At line 38.">_3</a>; [const]</big></dt>
<dt><big>DynArg!(4) <a href="./htmlsrc/std.bind.html#L39" title="At line 39.">_4</a>; [const]</big></dt>
<dt><big>DynArg!(5) <a href="./htmlsrc/std.bind.html#L40" title="At line 40.">_5</a>; [const]</big></dt>
<dt><big>DynArg!(6) <a href="./htmlsrc/std.bind.html#L41" title="At line 41.">_6</a>; [const]</big></dt>
<dt><big>DynArg!(7) <a href="./htmlsrc/std.bind.html#L42" title="At line 42.">_7</a>; [const]</big></dt>
<dt><big>DynArg!(8) <a href="./htmlsrc/std.bind.html#L43" title="At line 43.">_8</a>; [const]</big></dt>
<dt><big>DynArg!(9) <a href="./htmlsrc/std.bind.html#L44" title="At line 44.">_9</a>; [const]</big></dt>
<dd>
When passed to the 'bind' function, they will mark dynamic params - ones that aren't statically bound
	In boost, they're called __1, __2, __3, etc.. here __0, __1, __2, ...
<br><br></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L51" title="At line 51.">isDynArg</a>(T);</big></dt>
<dd></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L63" title="At line 63.">isDynArg</a>(T, int i);</big></dt>
<dd></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L71" title="At line 71.">DynamicArrayType</a>(T);</big></dt>
<dd></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L83" title="At line 83.">_assign</a>(T);</big></dt>
<dd></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L108" title="At line 108.">_assign</a>(T, Y, bool copyStaticArrays = true);</big></dt>
<dd></dd>
<dt><big>struct <a href="./htmlsrc/std.bind.html#L145" title="At line 145.">Tuple</a>(T ...);</big></dt>
<dd>
A simple tuple struct with some basic operations
<br><br>
<dl>
<dt><big>alias Tuple <a href="./htmlsrc/std.bind.html#L146" title="At line 146.">meta</a>;</big></dt>
<dd></dd>
<dt><big>bool <a href="./htmlsrc/std.bind.html#L147" title="At line 147.">expressionTuple</a>; [const]</big></dt>
<dd></dd>
<dt><big>alias T <a href="./htmlsrc/std.bind.html#L150" title="At line 150.">type</a>;</big></dt>
<dd></dd>
<dt><big>T <a href="./htmlsrc/std.bind.html#L151" title="At line 151.">value</a>;</big></dt>
<dd></dd>
<dt><big>int <a href="./htmlsrc/std.bind.html#L157" title="At line 157.">length</a>; [const]</big></dt>
<dd></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L163" title="At line 163.">appendT</a>(X);</big></dt>
<dd>
Statically yields a tuple type with an extra element added at its end
	<br><br>
<dl>
<dt><big>alias .Tuple!(T, X) <a href="./htmlsrc/std.bind.html#L164" title="At line 164.">appendT</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>appendT!(X) <a href="./htmlsrc/std.bind.html#L171" title="At line 171.">append</a>(X)(X <i>x</i>);</big></dt>
<dd>
Yields a tuple with an extra element added at its end
	<br><br></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L184" title="At line 184.">prependT</a>(X);</big></dt>
<dd>
Statically yields a tuple type with an extra element added at its beginning
	<br><br>
<dl>
<dt><big>alias .Tuple!(X, T) <a href="./htmlsrc/std.bind.html#L185" title="At line 185.">prependT</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>prependT!(X) <a href="./htmlsrc/std.bind.html#L192" title="At line 192.">prepend</a>(X)(X <i>x</i>);</big></dt>
<dd>
Yields a tuple with an extra element added at its beginning
	<br><br></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L205" title="At line 205.">concatT</a>(T ...);</big></dt>
<dd>
Statically concatenates this tuple type with another tuple type
	<br><br>
<dl>
<dt><big>alias .Tuple!(value, T) <a href="./htmlsrc/std.bind.html#L207" title="At line 207.">concatT</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>char[] <a href="./htmlsrc/std.bind.html#L214" title="At line 214.">toString</a>();</big></dt>
<dd></dd></dl></dd>
<dt><big>struct <a href="./htmlsrc/std.bind.html#L227" title="At line 227.">Tuple</a>();</big></dt>
<dd>
An empty tuple struct
<br><br>
<dl>
<dt><big>alias Tuple <a href="./htmlsrc/std.bind.html#L228" title="At line 228.">meta</a>;</big></dt>
<dd></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L230" title="At line 230.">EmptyTuple_</a>(T ...);</big></dt>
<dd>
<dl>
<dt><big>alias T <a href="./htmlsrc/std.bind.html#L231" title="At line 231.">EmptyTuple_</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>alias EmptyTuple_!() <a href="./htmlsrc/std.bind.html#L235" title="At line 235.">type</a>;</big></dt>
<dd>
an empty built-in tuple<br><br></dd>
<dt><big>alias EmptyTuple_!() <a href="./htmlsrc/std.bind.html#L236" title="At line 236.">value</a>;</big></dt>
<dd>
an empty built-in tuple<br><br></dd>
<dt><big>bool <a href="./htmlsrc/std.bind.html#L238" title="At line 238.">expressionTuple</a>; [const]</big></dt>
<dd></dd>
<dt><big>int <a href="./htmlsrc/std.bind.html#L239" title="At line 239.">length</a>; [const]</big></dt>
<dd></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L242" title="At line 242.">appendT</a>(X);</big></dt>
<dd>
<dl>
<dt><big>alias .Tuple!(X) <a href="./htmlsrc/std.bind.html#L243" title="At line 243.">appendT</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>alias appendT <a href="./htmlsrc/std.bind.html#L245" title="At line 245.">prependT</a>;</big></dt>
<dd></dd>
<dt><big>appendT!(X) <a href="./htmlsrc/std.bind.html#L248" title="At line 248.">append</a>(X)(X <i>x</i>);</big></dt>
<dd></dd>
<dt><big>alias append <a href="./htmlsrc/std.bind.html#L255" title="At line 255.">prepend</a>;</big></dt>
<dd></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L259" title="At line 259.">concatT</a>(T ...);</big></dt>
<dd>
<dl>
<dt><big>alias .Tuple!(T) <a href="./htmlsrc/std.bind.html#L260" title="At line 260.">concatT</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>char[] <a href="./htmlsrc/std.bind.html#L264" title="At line 264.">toString</a>();</big></dt>
<dd></dd></dl></dd>
<dt><big>Tuple!(T) <a href="./htmlsrc/std.bind.html#L273" title="At line 273.">tuple</a>(T ...)(T <i>t</i>);</big></dt>
<dd>
Dynamically create a tuple from the given items
<br><br></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L285" title="At line 285.">isTypeTuple</a>(T);</big></dt>
<dd>
Checks whether a given type is the Tuple struct of any length
<br><br>
<dl>
<dt><big>bool <a href="./htmlsrc/std.bind.html#L288" title="At line 288.">isTypeTuple</a>; [const]</big></dt>
<dd></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L303" title="At line 303.">minNumArgs_impl</a>(alias fn, fnT);</big></dt>
<dd>
<dl>
<dt><big>alias ParameterTypeTuple!(fnT) <a href="./htmlsrc/std.bind.html#L304" title="At line 304.">Params</a>;</big></dt>
<dd></dd>
<dt><big>Params <a href="./htmlsrc/std.bind.html#L305" title="At line 305.">params</a>;</big></dt>
<dd></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L307" title="At line 307.">loop</a>(int i = 0);</big></dt>
<dd>
<dl>
<dt><big>int <a href="./htmlsrc/std.bind.html#L311" title="At line 311.">res</a>; [const]</big></dt>
<dd></dd></dl></dd>
<dt><big>alias loop!().res <a href="./htmlsrc/std.bind.html#L317" title="At line 317.">res</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L322" title="At line 322.">minNumArgs</a>(alias fn, fnT = typeof(&amp;fn));</big></dt>
<dd>
Finds the minimal number of arguments a given function needs to be provided
<br><br>
<dl>
<dt><big>int <a href="./htmlsrc/std.bind.html#L323" title="At line 323.">minNumArgs</a>; [const]</big></dt>
<dd></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L328" title="At line 328.">MBoundFunc</a>();</big></dt>
<dd>
<dl>
<dt><big>alias FAlias_ <a href="./htmlsrc/std.bind.html#L330" title="At line 330.">FAlias</a>;</big></dt>
<dd></dd>
<dt><big>alias FT <a href="./htmlsrc/std.bind.html#L331" title="At line 331.">FuncType</a>;</big></dt>
<dd></dd>
<dt><big>alias AllBoundArgs_ <a href="./htmlsrc/std.bind.html#L332" title="At line 332.">AllBoundArgs</a>;</big></dt>
<dd></dd>
<dt><big>alias Tuple!(ParameterTypeTuple!(FT)) <a href="./htmlsrc/std.bind.html#L335" title="At line 335.">RealFuncParams</a>;</big></dt>
<dd></dd>
<dt><big>alias FuncReferenceParamsAsPointers!(FAlias) <a href="./htmlsrc/std.bind.html#L336" title="At line 336.">FuncParams</a>;</big></dt>
<dd></dd>
<dt><big>alias ReturnType!(FT) <a href="./htmlsrc/std.bind.html#L341" title="At line 341.">RetType</a>;</big></dt>
<dd></dd>
<dt><big>alias ExtractedBoundArgs!(AllBoundArgs.type) <a href="./htmlsrc/std.bind.html#L342" title="At line 342.">BoundArgs</a>;</big></dt>
<dd></dd>
<dt><big>int <a href="./htmlsrc/std.bind.html#L347" title="At line 347.">minFuncArgs</a>; [const]</big></dt>
<dd></dd>
<dt><big>alias ParamsPassMethodTuple!(FAlias) <a href="./htmlsrc/std.bind.html#L349" title="At line 349.">ParamPassingMethods</a>;</big></dt>
<dd></dd>
<dt><big>alias getDynArgTypes!(FuncParams, AllBoundArgs, minFuncArgs).res.type <a href="./htmlsrc/std.bind.html#L355" title="At line 355.">DynParams</a>;</big></dt>
<dd></dd>
<dt><big>FuncType <a href="./htmlsrc/std.bind.html#L358" title="At line 358.">fp</a>;</big></dt>
<dd></dd>
<dt><big>BoundArgs <a href="./htmlsrc/std.bind.html#L359" title="At line 359.">boundArgs</a>;</big></dt>
<dd></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L362" title="At line 362.">numFuncArgsReallyBound</a>(int argI = 0, int fargI = 0, int bargI = 0);</big></dt>
<dd>
<dl>
<dt><big>alias DerefFunc!(AllBoundArgs.type[argI]).RetType <a href="./htmlsrc/std.bind.html#L369" title="At line 369.">FuncRetType</a>;</big></dt>
<dd></dd>
<dt><big>int <a href="./htmlsrc/std.bind.html#L370" title="At line 370.">argLen</a>; [const]</big></dt>
<dd></dd>
<dt><big>int <a href="./htmlsrc/std.bind.html#L371" title="At line 371.">bargInc</a>; [const]</big></dt>
<dd></dd>
<dt><big>int <a href="./htmlsrc/std.bind.html#L387" title="At line 387.">res</a>; [const]</big></dt>
<dd></dd></dl></dd>
<dt><big>int <a href="./htmlsrc/std.bind.html#L399" title="At line 399.">numSpecifiedParams</a>; [const]</big></dt>
<dd></dd>
<dt><big>alias Tuple!(FuncParams.type[0 .. numSpecifiedParams]) <a href="./htmlsrc/std.bind.html#L402" title="At line 402.">SpecifiedParams</a>;</big></dt>
<dd></dd>
<dt><big>void <a href="./htmlsrc/std.bind.html#L408" title="At line 408.">copyArgs</a>(int argI = 0, int fargI = 0, int bargI = 0)(inout SpecifiedParams <i>funcArgs</i>, DynParams <i>dynArgs</i>);</big></dt>
<dd></dd>
<dt><big>RetType <a href="./htmlsrc/std.bind.html#L496" title="At line 496.">func</a>(DynParams <i>dynArgs</i>);</big></dt>
<dd>
The final wrapped function<br><br></dd>
<dt><big>alias func <a href="./htmlsrc/std.bind.html#L538" title="At line 538.">call</a>;</big></dt>
<dd>
The final wrapped function<br><br></dd>
<dt><big>alias func <a href="./htmlsrc/std.bind.html#L542" title="At line 542.">opCall</a>;</big></dt>
<dd>
The final wrapped function<br><br></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L548" title="At line 548.">PtrType</a>();</big></dt>
<dd>
The type of the delegate that may be returned from this object
	<br><br>
<dl>
<dt><big>alias typeof(&amp;(new BoundFunc).call) <a href="./htmlsrc/std.bind.html#L549" title="At line 549.">PtrType</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>PtrType!() <a href="./htmlsrc/std.bind.html#L555" title="At line 555.">ptr</a>();</big></dt>
<dd>
Get a delegate. Equivalent to getting it thru &foo.call
	<br><br></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L573" title="At line 573.">DerefFunc</a>(T);</big></dt>
<dd>
<dl>
<dt><big>alias T <a href="./htmlsrc/std.bind.html#L574" title="At line 574.">DerefFunc</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>class <a href="./htmlsrc/std.bind.html#L580" title="At line 580.">BoundFunc</a>(FT, alias FAlias_, AllBoundArgs_);</big></dt>
<dd>
A context for bound/curried functions
	<br><br>
</dd>
<dt><big>typeof(new BoundFunc!(FT, NullAlias, Tuple!(ArgList))) <a href="./htmlsrc/std.bind.html#L658" title="At line 658.">bind</a>(FT, ArgList...)(FT <i>fp</i>, ArgList <i>args</i>);</big></dt>
<dd>
bind&#40;&#41; can curry or "bind" arguments of a function, producing a different function which requires less parameters,
	or a different order of parameters. It also allows function composition.
	
	The syntax of a bind&#40;&#41; call is:
	
	bind&#40;function or delegate pointer { , <b>argument</b> }&#41;;
	
	<b>argument</b> can be one of:
	<ul>
	<li> static/bound argument &#40;an immediate value&#41; </li>
	<li> another bound function object </li>
	<li> dynamic argument, of the form __[0-9], e.g. __0, __3 or __9 </li>
	</ul>
	
	The result is a function object, which can be called using call&#40;&#41;, func&#40;&#41; or opCall&#40;&#41;.
	There also exists a convenience function, ptr&#40;&#41; which returns a delegate to call/func/opCall
	
	The resulting delegate accepts exactly as many parameters as many distinct dynamic arguments were used.
<pre class="d_code">

- <span class="i">bind</span>(&amp;<span class="i">foo</span>, <span class="i">_0</span>, <span class="i">_1</span>) <span class="lc">// will yield a delegate accepting two parameters</span>
- <span class="i">bind</span>(&amp;<span class="i">foo</span>, <span class="i">_1</span>, <span class="i">_0</span>) <span class="lc">// will yield a delegate accepting two parameters</span>
- <span class="i">bind</span>(&amp;<span class="i">bar</span>, <span class="i">_0</span>, <span class="i">_1</span>, <span class="i">_2</span>, <span class="i">_0</span>) <span class="lc">// will yield a delegate accepting three parameters</span>

</pre>
	
	<br />
	<br />
	The types of dynamic parameters are extracted from the bound function itself and when necessary, type negotiation
	is performed. For example, binding a function
<pre class="d_code">

<span class="k">void</span> <span class="i">foo</span>(<span class="k">int</span> <span class="i">a</span>, <span class="k">long</span> <span class="i">b</span>)

<span class="lc">// with:</span>
<span class="i">bind</span>(&amp;<span class="i">foo</span>, <span class="i">_0</span>, <span class="i">_0</span>)

</pre>
	will result in a delegate accepting a single, optimal parameter type. The best type is computed
	using std.typetuple.DerivedToFront, so in case of an int and a long, long will be selected. Generally, bind will try to find
	a type that can be implicitly converted to all the other types a given dynamic parameter uses.
		<br><br>
<b>Note:</b><br>in case of numeric types, an explicit, but transparent &#40;to the user&#41; cast will be performed
	
	<br />
	Function composition works intuitively:
<pre class="d_code">

<span class="i">bind</span>(&amp;<span class="i">f1</span>, <span class="i">bind</span>(&amp;<span class="i">f2</span>, <span class="i">_0</span>))

</pre>
	
	which will yield a delegate, that takes the argument, calls f2, then uses the return value of f2 to call f1. Mathematically
	speaking, it will yield a function composition:
<pre class="d_code">

<span class="i">f1</span>(<span class="i">f2</span>(<span class="i">_0</span>))

</pre>
	
	When one function is composed multiple times, it will be called multiple times - Bind does no lazy evaluation, so
<pre class="d_code">

<span class="i">bind</span>(&amp;<span class="i">f3</span>, <span class="i">bind</span>(&amp;<span class="i">f4</span>, <span class="i">_0</span>), <span class="i">bind</span>(&amp;<span class="i">f4</span>, <span class="i">_0</span>))

</pre>
	will produce a delegate, which, upon calling, will invoke f4 two times to evaluate the arguments for f3 and then call f3
	
	
	One another feature that bind&#40;&#41; supports is automatic tuple expansion. It means that having functions:
<pre class="d_code">

<span class="k">void</span> <span class="i">foo</span>(<span class="k">int</span> <span class="i">a</span>, <span class="k">int</span> <span class="i">b</span>)
<span class="i">Tuple</span>!(<span class="k">int</span>, <span class="k">int</span>) <span class="i">bar</span>()

</pre>
	
	Allows them to be bound by writing:
<pre class="d_code">

<span class="i">bind</span>(&amp;<span class="i">foo</span>, <span class="i">bind</span>(&amp;<span class="i">bar</span>))
<span class="lc">// or</span>
<span class="i">bind</span>(&amp;<span class="i">foo</span>, <span class="i">tuple</span>(<span class="n">23</span>, <span class="n">45</span>))

</pre><br><br></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L691" title="At line 691.">bindAlias</a>(alias FT);</big></dt>
<dd>
bindAlias&#40;&#41; is similar to bind&#40;&#41;, but it's more powerful. Use bindAlias&#40;&#41; rather than bind&#40;&#41; where possible. <br/><br><br>
The syntax is:
	
	bindAlias!&#40;Function&#41;&#40;argument, argument, argument, argument, ...&#41;;
	
	bindAlias takes advantage of using aliases directly, thus being able to extract default values from functions and not forcing the user
	to bind them. It doesn't, however mean that the resulting delegate can be called, omitting some of its parameters. It only means that these
	arguments that have default values in the function provided to bindAlias don't have to be bound explicitly.
	
	Additionally, bindAlias takes care of functions with out/inout parameters, by converting them to pointers internally. A function like:
<pre class="d_code">

<span class="k">void</span> <span class="i">foo</span>(<span class="k">inout</span> <span class="i">a</span>)

</pre>	
	can be bound using:
<pre class="d_code">

<span class="k">int</span> <span class="i">x</span>;
<span class="i">bindAlias</span>!(<span class="i">foo</span>)(&amp;<span class="i">x</span>);

</pre>
	
	<br><br>
<b>Note:</b><br>there is no bind-time check for reference nullness, there is however a call-time check on all references which can be disabled
	by using version=BindNoNullCheck or compiling in release mode.<br><br>
<dl>
<dt><big>typeof(new BoundFunc!(typeof(&amp;FT), FT, Tuple!(ArgList))) <a href="./htmlsrc/std.bind.html#L692" title="At line 692.">bindAlias</a>(ArgList...)(ArgList <i>args</i>);</big></dt>
<dd></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L707" title="At line 707.">isBoundFunc</a>(T);</big></dt>
<dd>
<dl>
<dt><big>bool <a href="./htmlsrc/std.bind.html#L712" title="At line 712.">isBoundFunc</a>; [static, const]</big></dt>
<dd></dd></dl></dd>
<dt><big>alias Tuple!(byte, ubyte, short, ushort, int, uint, long, ulong, /+cent, ucent, +/float, double, real, ifloat, idouble, ireal, cfloat, cdouble, creal) <a href="./htmlsrc/std.bind.html#L721" title="At line 721.">NumericTypes</a>;</big></dt>
<dd></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L729" title="At line 729.">dynArgTypes</a>(int i, FuncParams, BoundArgs, int minParamsLeft);</big></dt>
<dd>
<dl>
<dt><big>template <a href="./htmlsrc/std.bind.html#L732" title="At line 732.">sliceOffTuple</a>(T, int i);</big></dt>
<dd>
<dl>
<dt><big>alias Tuple!(T.type[i..length]) <a href="./htmlsrc/std.bind.html#L733" title="At line 733.">res</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L738" title="At line 738.">prependType</a>(T, SkipType);</big></dt>
<dd>
<dl>
<dt><big>alias dynArgTypes!(
					i,
					sliceOffTuple!(FuncParams, SkipType.length).res,
					Tuple!(BoundArgs.type[1..$]),
					minParamsLeft - SkipType.length
				).res <a href="./htmlsrc/std.bind.html#L744" title="At line 744.">tmp</a>;</big></dt>
<dd></dd>
<dt><big>alias tmp <a href="./htmlsrc/std.bind.html#L762" title="At line 762.">res</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>alias Tuple!() <a href="./htmlsrc/std.bind.html#L771" title="At line 771.">res</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L801" title="At line 801.">maxInt</a>(int a, int b); [private]</big></dt>
<dd>
<dl>
<dt><big>int <a href="./htmlsrc/std.bind.html#L802" title="At line 802.">maxInt</a>; [static, const]</big></dt>
<dd></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L810" title="At line 810.">numDynArgs</a>(BoundArgs);</big></dt>
<dd>
<dl>
<dt><big>int <a href="./htmlsrc/std.bind.html#L813" title="At line 813.">res</a>; [static, const]</big></dt>
<dd></dd></dl></dd>
<dt><big>struct <a href="./htmlsrc/std.bind.html#L837" title="At line 837.">EmptySlot</a>;</big></dt>
<dd>
<dl>
<dt><big>char[] <a href="./htmlsrc/std.bind.html#L838" title="At line 838.">toString</a>();</big></dt>
<dd></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L848" title="At line 848.">getDynArgTypes</a>(FuncParams, BoundArgs, int minFuncArgs);</big></dt>
<dd>
<dl>
<dt><big>template <a href="./htmlsrc/std.bind.html#L849" title="At line 849.">loop</a>(int i);</big></dt>
<dd>
<dl>
<dt><big>alias dynArgTypes!(i, FuncParams, BoundArgs, minFuncArgs).res.type <a href="./htmlsrc/std.bind.html#L851" title="At line 851.">dirtyArgTypeList</a>;</big></dt>
<dd></dd>
<dt><big>alias Tuple!(EraseAll!(EmptySlot, dirtyArgTypeList)) <a href="./htmlsrc/std.bind.html#L855" title="At line 855.">argTypeList</a>;</big></dt>
<dd></dd>
<dt><big>alias DerivedToFront!(argTypeList.type)[0] <a href="./htmlsrc/std.bind.html#L860" title="At line 860.">argType</a>;</big></dt>
<dd></dd>
<dt><big>alias loop!(i+1).res.meta.prependT!(argType) <a href="./htmlsrc/std.bind.html#L866" title="At line 866.">res</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>alias loop!(0).res <a href="./htmlsrc/std.bind.html#L872" title="At line 872.">res</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L879" title="At line 879.">ExtractedBoundArgs</a>(BoundArgs ...);</big></dt>
<dd>
<dl>
<dt><big>alias Tuple!() <a href="./htmlsrc/std.bind.html#L881" title="At line 881.">ExtractedBoundArgs</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>void <a href="./htmlsrc/std.bind.html#L899" title="At line 899.">extractBoundArgs</a>(int dst, int src, BoundArgs ...)(inout ExtractedBoundArgs!(BoundArgs) <i>result</i>, BoundArgs <i>boundArgs</i>);</big></dt>
<dd></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L918" title="At line 918.">getArgLen</a>(Dst, Src);</big></dt>
<dd>
<dl>
<dt><big>int <a href="./htmlsrc/std.bind.html#L921" title="At line 921.">getArgLen</a>; [static, const]</big></dt>
<dd></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L934" title="At line 934.">ContainsEmptySlotType</a>(ParamList ...);</big></dt>
<dd>
<dl>
<dt><big>bool <a href="./htmlsrc/std.bind.html#L935" title="At line 935.">ContainsEmptySlotType</a>; [const]</big></dt>
<dd></dd></dl></dd>
<dt><big>EmptySlot <a href="./htmlsrc/std.bind.html#L940" title="At line 940.">NullAlias</a>; [const]</big></dt>
<dd></dd>
<dt><big>struct <a href="./htmlsrc/std.bind.html#L945" title="At line 945.">PassByCopy</a>;</big></dt>
<dd>
</dd>
<dt><big>struct <a href="./htmlsrc/std.bind.html#L946" title="At line 946.">PassByRef</a>;</big></dt>
<dd>
</dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L948" title="At line 948.">ParamsPassMethodTuple_impl</a>(alias Func, int i = 0);</big></dt>
<dd>
<dl>
<dt><big>alias Tuple!(ParameterTypeTuple!(typeof(&amp;Func))) <a href="./htmlsrc/std.bind.html#L949" title="At line 949.">Params</a>;</big></dt>
<dd></dd>
<dt><big>alias Tuple!() <a href="./htmlsrc/std.bind.html#L952" title="At line 952.">res</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L969" title="At line 969.">ParamsPassMethodTuple</a>(alias Func);</big></dt>
<dd>
<dl>
<dt><big>alias ParamsPassMethodTuple_impl!(Func).res <a href="./htmlsrc/std.bind.html#L970" title="At line 970.">ParamsPassMethodTuple</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L974" title="At line 974.">FuncReferenceParamsAsPointers_impl</a>(alias Func);</big></dt>
<dd>
<dl>
<dt><big>alias Tuple!(ParameterTypeTuple!(typeof(&amp;Func))) <a href="./htmlsrc/std.bind.html#L975" title="At line 975.">Params</a>;</big></dt>
<dd></dd>
<dt><big>alias ParamsPassMethodTuple!(Func) <a href="./htmlsrc/std.bind.html#L976" title="At line 976.">PassMethods</a>;</big></dt>
<dd></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L978" title="At line 978.">loop</a>(int i);</big></dt>
<dd>
<dl>
<dt><big>alias Tuple!() <a href="./htmlsrc/std.bind.html#L980" title="At line 980.">res</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>alias loop!(0).res <a href="./htmlsrc/std.bind.html#L992" title="At line 992.">res</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L1000" title="At line 1000.">FuncReferenceParamsAsPointers</a>(alias Func);</big></dt>
<dd>
<dl>
<dt><big>alias FuncReferenceParamsAsPointers_impl!(Func).res <a href="./htmlsrc/std.bind.html#L1001" title="At line 1001.">FuncReferenceParamsAsPointers</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>template <a href="./htmlsrc/std.bind.html#L1009" title="At line 1009.">PointerTuple</a>(T);</big></dt>
<dd>
<dl>
<dt><big>alias PointerTuple!(Tuple!(T.type[1..$])).meta.prependT!(T.type[0]*) <a href="./htmlsrc/std.bind.html#L1011" title="At line 1011.">PointerTuple</a>;</big></dt>
<dd></dd></dl></dd>
<dt><big>RetType <a href="./htmlsrc/std.bind.html#L1022" title="At line 1022.">ptrApply</a>(RetType, FN, T ...)(FN <i>fn</i>, T <i>t</i>);</big></dt>
<dd></dd></dl>
    <br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>


<div id="copyright">
Public Domain |
Page generated by <a href="http://code.google.com/p/dil">dil</a> on Wed Oct  1 23:47:51 2008
</div>

</body>
</html>
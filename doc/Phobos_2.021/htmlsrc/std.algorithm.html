<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>std.algorithm</title>
  <link href="html.css" rel="stylesheet" type="text/css">
</head>
<body>
<table><tr>
<td class="linescolumn"><a id="L1" href="#L1">1</a><a id="L2" href="#L2">2</a><a id="L3" href="#L3">3</a><a id="L4" href="#L4">4</a><a id="L5" href="#L5">5</a><a id="L6" href="#L6">6</a><a id="L7" href="#L7">7</a><a id="L8" href="#L8">8</a><a id="L9" href="#L9">9</a><a id="L10" href="#L10">10</a><a id="L11" href="#L11">11</a><a id="L12" href="#L12">12</a><a id="L13" href="#L13">13</a><a id="L14" href="#L14">14</a><a id="L15" href="#L15">15</a><a id="L16" href="#L16">16</a><a id="L17" href="#L17">17</a><a id="L18" href="#L18">18</a><a id="L19" href="#L19">19</a><a id="L20" href="#L20">20</a><a id="L21" href="#L21">21</a><a id="L22" href="#L22">22</a><a id="L23" href="#L23">23</a><a id="L24" href="#L24">24</a><a id="L25" href="#L25">25</a><a id="L26" href="#L26">26</a><a id="L27" href="#L27">27</a><a id="L28" href="#L28">28</a><a id="L29" href="#L29">29</a><a id="L30" href="#L30">30</a><a id="L31" href="#L31">31</a><a id="L32" href="#L32">32</a><a id="L33" href="#L33">33</a><a id="L34" href="#L34">34</a><a id="L35" href="#L35">35</a><a id="L36" href="#L36">36</a><a id="L37" href="#L37">37</a><a id="L38" href="#L38">38</a><a id="L39" href="#L39">39</a><a id="L40" href="#L40">40</a><a id="L41" href="#L41">41</a><a id="L42" href="#L42">42</a><a id="L43" href="#L43">43</a><a id="L44" href="#L44">44</a><a id="L45" href="#L45">45</a><a id="L46" href="#L46">46</a><a id="L47" href="#L47">47</a><a id="L48" href="#L48">48</a><a id="L49" href="#L49">49</a><a id="L50" href="#L50">50</a><a id="L51" href="#L51">51</a><a id="L52" href="#L52">52</a><a id="L53" href="#L53">53</a><a id="L54" href="#L54">54</a><a id="L55" href="#L55">55</a><a id="L56" href="#L56">56</a><a id="L57" href="#L57">57</a><a id="L58" href="#L58">58</a><a id="L59" href="#L59">59</a><a id="L60" href="#L60">60</a><a id="L61" href="#L61">61</a><a id="L62" href="#L62">62</a><a id="L63" href="#L63">63</a><a id="L64" href="#L64">64</a><a id="L65" href="#L65">65</a><a id="L66" href="#L66">66</a><a id="L67" href="#L67">67</a><a id="L68" href="#L68">68</a><a id="L69" href="#L69">69</a><a id="L70" href="#L70">70</a><a id="L71" href="#L71">71</a><a id="L72" href="#L72">72</a><a id="L73" href="#L73">73</a><a id="L74" href="#L74">74</a><a id="L75" href="#L75">75</a><a id="L76" href="#L76">76</a><a id="L77" href="#L77">77</a><a id="L78" href="#L78">78</a><a id="L79" href="#L79">79</a><a id="L80" href="#L80">80</a><a id="L81" href="#L81">81</a><a id="L82" href="#L82">82</a><a id="L83" href="#L83">83</a><a id="L84" href="#L84">84</a><a id="L85" href="#L85">85</a><a id="L86" href="#L86">86</a><a id="L87" href="#L87">87</a><a id="L88" href="#L88">88</a><a id="L89" href="#L89">89</a><a id="L90" href="#L90">90</a><a id="L91" href="#L91">91</a><a id="L92" href="#L92">92</a><a id="L93" href="#L93">93</a><a id="L94" href="#L94">94</a><a id="L95" href="#L95">95</a><a id="L96" href="#L96">96</a><a id="L97" href="#L97">97</a><a id="L98" href="#L98">98</a><a id="L99" href="#L99">99</a><a id="L100" href="#L100">100</a><a id="L101" href="#L101">101</a><a id="L102" href="#L102">102</a><a id="L103" href="#L103">103</a><a id="L104" href="#L104">104</a><a id="L105" href="#L105">105</a><a id="L106" href="#L106">106</a><a id="L107" href="#L107">107</a><a id="L108" href="#L108">108</a><a id="L109" href="#L109">109</a><a id="L110" href="#L110">110</a><a id="L111" href="#L111">111</a><a id="L112" href="#L112">112</a><a id="L113" href="#L113">113</a><a id="L114" href="#L114">114</a><a id="L115" href="#L115">115</a><a id="L116" href="#L116">116</a><a id="L117" href="#L117">117</a><a id="L118" href="#L118">118</a><a id="L119" href="#L119">119</a><a id="L120" href="#L120">120</a><a id="L121" href="#L121">121</a><a id="L122" href="#L122">122</a><a id="L123" href="#L123">123</a><a id="L124" href="#L124">124</a><a id="L125" href="#L125">125</a><a id="L126" href="#L126">126</a><a id="L127" href="#L127">127</a><a id="L128" href="#L128">128</a><a id="L129" href="#L129">129</a><a id="L130" href="#L130">130</a><a id="L131" href="#L131">131</a><a id="L132" href="#L132">132</a><a id="L133" href="#L133">133</a><a id="L134" href="#L134">134</a><a id="L135" href="#L135">135</a><a id="L136" href="#L136">136</a><a id="L137" href="#L137">137</a><a id="L138" href="#L138">138</a><a id="L139" href="#L139">139</a><a id="L140" href="#L140">140</a><a id="L141" href="#L141">141</a><a id="L142" href="#L142">142</a><a id="L143" href="#L143">143</a><a id="L144" href="#L144">144</a><a id="L145" href="#L145">145</a><a id="L146" href="#L146">146</a><a id="L147" href="#L147">147</a><a id="L148" href="#L148">148</a><a id="L149" href="#L149">149</a><a id="L150" href="#L150">150</a><a id="L151" href="#L151">151</a><a id="L152" href="#L152">152</a><a id="L153" href="#L153">153</a><a id="L154" href="#L154">154</a><a id="L155" href="#L155">155</a><a id="L156" href="#L156">156</a><a id="L157" href="#L157">157</a><a id="L158" href="#L158">158</a><a id="L159" href="#L159">159</a><a id="L160" href="#L160">160</a><a id="L161" href="#L161">161</a><a id="L162" href="#L162">162</a><a id="L163" href="#L163">163</a><a id="L164" href="#L164">164</a><a id="L165" href="#L165">165</a><a id="L166" href="#L166">166</a><a id="L167" href="#L167">167</a><a id="L168" href="#L168">168</a><a id="L169" href="#L169">169</a><a id="L170" href="#L170">170</a><a id="L171" href="#L171">171</a><a id="L172" href="#L172">172</a><a id="L173" href="#L173">173</a><a id="L174" href="#L174">174</a><a id="L175" href="#L175">175</a><a id="L176" href="#L176">176</a><a id="L177" href="#L177">177</a><a id="L178" href="#L178">178</a><a id="L179" href="#L179">179</a><a id="L180" href="#L180">180</a><a id="L181" href="#L181">181</a><a id="L182" href="#L182">182</a><a id="L183" href="#L183">183</a><a id="L184" href="#L184">184</a><a id="L185" href="#L185">185</a><a id="L186" href="#L186">186</a><a id="L187" href="#L187">187</a><a id="L188" href="#L188">188</a><a id="L189" href="#L189">189</a><a id="L190" href="#L190">190</a><a id="L191" href="#L191">191</a><a id="L192" href="#L192">192</a><a id="L193" href="#L193">193</a><a id="L194" href="#L194">194</a><a id="L195" href="#L195">195</a><a id="L196" href="#L196">196</a><a id="L197" href="#L197">197</a><a id="L198" href="#L198">198</a><a id="L199" href="#L199">199</a><a id="L200" href="#L200">200</a><a id="L201" href="#L201">201</a><a id="L202" href="#L202">202</a><a id="L203" href="#L203">203</a><a id="L204" href="#L204">204</a><a id="L205" href="#L205">205</a><a id="L206" href="#L206">206</a><a id="L207" href="#L207">207</a><a id="L208" href="#L208">208</a><a id="L209" href="#L209">209</a><a id="L210" href="#L210">210</a><a id="L211" href="#L211">211</a><a id="L212" href="#L212">212</a><a id="L213" href="#L213">213</a><a id="L214" href="#L214">214</a><a id="L215" href="#L215">215</a><a id="L216" href="#L216">216</a><a id="L217" href="#L217">217</a><a id="L218" href="#L218">218</a><a id="L219" href="#L219">219</a><a id="L220" href="#L220">220</a><a id="L221" href="#L221">221</a><a id="L222" href="#L222">222</a><a id="L223" href="#L223">223</a><a id="L224" href="#L224">224</a><a id="L225" href="#L225">225</a><a id="L226" href="#L226">226</a><a id="L227" href="#L227">227</a><a id="L228" href="#L228">228</a><a id="L229" href="#L229">229</a><a id="L230" href="#L230">230</a><a id="L231" href="#L231">231</a><a id="L232" href="#L232">232</a><a id="L233" href="#L233">233</a><a id="L234" href="#L234">234</a><a id="L235" href="#L235">235</a><a id="L236" href="#L236">236</a><a id="L237" href="#L237">237</a><a id="L238" href="#L238">238</a><a id="L239" href="#L239">239</a><a id="L240" href="#L240">240</a><a id="L241" href="#L241">241</a><a id="L242" href="#L242">242</a><a id="L243" href="#L243">243</a><a id="L244" href="#L244">244</a><a id="L245" href="#L245">245</a><a id="L246" href="#L246">246</a><a id="L247" href="#L247">247</a><a id="L248" href="#L248">248</a><a id="L249" href="#L249">249</a><a id="L250" href="#L250">250</a><a id="L251" href="#L251">251</a><a id="L252" href="#L252">252</a><a id="L253" href="#L253">253</a><a id="L254" href="#L254">254</a><a id="L255" href="#L255">255</a><a id="L256" href="#L256">256</a><a id="L257" href="#L257">257</a><a id="L258" href="#L258">258</a><a id="L259" href="#L259">259</a><a id="L260" href="#L260">260</a><a id="L261" href="#L261">261</a><a id="L262" href="#L262">262</a><a id="L263" href="#L263">263</a><a id="L264" href="#L264">264</a><a id="L265" href="#L265">265</a><a id="L266" href="#L266">266</a><a id="L267" href="#L267">267</a><a id="L268" href="#L268">268</a><a id="L269" href="#L269">269</a><a id="L270" href="#L270">270</a><a id="L271" href="#L271">271</a><a id="L272" href="#L272">272</a><a id="L273" href="#L273">273</a><a id="L274" href="#L274">274</a><a id="L275" href="#L275">275</a><a id="L276" href="#L276">276</a><a id="L277" href="#L277">277</a><a id="L278" href="#L278">278</a><a id="L279" href="#L279">279</a><a id="L280" href="#L280">280</a><a id="L281" href="#L281">281</a><a id="L282" href="#L282">282</a><a id="L283" href="#L283">283</a><a id="L284" href="#L284">284</a><a id="L285" href="#L285">285</a><a id="L286" href="#L286">286</a><a id="L287" href="#L287">287</a><a id="L288" href="#L288">288</a><a id="L289" href="#L289">289</a><a id="L290" href="#L290">290</a><a id="L291" href="#L291">291</a><a id="L292" href="#L292">292</a><a id="L293" href="#L293">293</a><a id="L294" href="#L294">294</a><a id="L295" href="#L295">295</a><a id="L296" href="#L296">296</a><a id="L297" href="#L297">297</a><a id="L298" href="#L298">298</a><a id="L299" href="#L299">299</a><a id="L300" href="#L300">300</a><a id="L301" href="#L301">301</a><a id="L302" href="#L302">302</a><a id="L303" href="#L303">303</a><a id="L304" href="#L304">304</a><a id="L305" href="#L305">305</a><a id="L306" href="#L306">306</a><a id="L307" href="#L307">307</a><a id="L308" href="#L308">308</a><a id="L309" href="#L309">309</a><a id="L310" href="#L310">310</a><a id="L311" href="#L311">311</a><a id="L312" href="#L312">312</a><a id="L313" href="#L313">313</a><a id="L314" href="#L314">314</a><a id="L315" href="#L315">315</a><a id="L316" href="#L316">316</a><a id="L317" href="#L317">317</a><a id="L318" href="#L318">318</a><a id="L319" href="#L319">319</a><a id="L320" href="#L320">320</a><a id="L321" href="#L321">321</a><a id="L322" href="#L322">322</a><a id="L323" href="#L323">323</a><a id="L324" href="#L324">324</a><a id="L325" href="#L325">325</a><a id="L326" href="#L326">326</a><a id="L327" href="#L327">327</a><a id="L328" href="#L328">328</a><a id="L329" href="#L329">329</a><a id="L330" href="#L330">330</a><a id="L331" href="#L331">331</a><a id="L332" href="#L332">332</a><a id="L333" href="#L333">333</a><a id="L334" href="#L334">334</a><a id="L335" href="#L335">335</a><a id="L336" href="#L336">336</a><a id="L337" href="#L337">337</a><a id="L338" href="#L338">338</a><a id="L339" href="#L339">339</a><a id="L340" href="#L340">340</a><a id="L341" href="#L341">341</a><a id="L342" href="#L342">342</a><a id="L343" href="#L343">343</a><a id="L344" href="#L344">344</a><a id="L345" href="#L345">345</a><a id="L346" href="#L346">346</a><a id="L347" href="#L347">347</a><a id="L348" href="#L348">348</a><a id="L349" href="#L349">349</a><a id="L350" href="#L350">350</a><a id="L351" href="#L351">351</a><a id="L352" href="#L352">352</a><a id="L353" href="#L353">353</a><a id="L354" href="#L354">354</a><a id="L355" href="#L355">355</a><a id="L356" href="#L356">356</a><a id="L357" href="#L357">357</a><a id="L358" href="#L358">358</a><a id="L359" href="#L359">359</a><a id="L360" href="#L360">360</a><a id="L361" href="#L361">361</a><a id="L362" href="#L362">362</a><a id="L363" href="#L363">363</a><a id="L364" href="#L364">364</a><a id="L365" href="#L365">365</a><a id="L366" href="#L366">366</a><a id="L367" href="#L367">367</a><a id="L368" href="#L368">368</a><a id="L369" href="#L369">369</a><a id="L370" href="#L370">370</a><a id="L371" href="#L371">371</a><a id="L372" href="#L372">372</a><a id="L373" href="#L373">373</a><a id="L374" href="#L374">374</a><a id="L375" href="#L375">375</a><a id="L376" href="#L376">376</a><a id="L377" href="#L377">377</a><a id="L378" href="#L378">378</a><a id="L379" href="#L379">379</a><a id="L380" href="#L380">380</a><a id="L381" href="#L381">381</a><a id="L382" href="#L382">382</a><a id="L383" href="#L383">383</a><a id="L384" href="#L384">384</a><a id="L385" href="#L385">385</a><a id="L386" href="#L386">386</a><a id="L387" href="#L387">387</a><a id="L388" href="#L388">388</a><a id="L389" href="#L389">389</a><a id="L390" href="#L390">390</a><a id="L391" href="#L391">391</a><a id="L392" href="#L392">392</a><a id="L393" href="#L393">393</a><a id="L394" href="#L394">394</a><a id="L395" href="#L395">395</a><a id="L396" href="#L396">396</a><a id="L397" href="#L397">397</a><a id="L398" href="#L398">398</a><a id="L399" href="#L399">399</a><a id="L400" href="#L400">400</a><a id="L401" href="#L401">401</a><a id="L402" href="#L402">402</a><a id="L403" href="#L403">403</a><a id="L404" href="#L404">404</a><a id="L405" href="#L405">405</a><a id="L406" href="#L406">406</a><a id="L407" href="#L407">407</a><a id="L408" href="#L408">408</a><a id="L409" href="#L409">409</a><a id="L410" href="#L410">410</a><a id="L411" href="#L411">411</a><a id="L412" href="#L412">412</a><a id="L413" href="#L413">413</a><a id="L414" href="#L414">414</a><a id="L415" href="#L415">415</a><a id="L416" href="#L416">416</a><a id="L417" href="#L417">417</a><a id="L418" href="#L418">418</a><a id="L419" href="#L419">419</a><a id="L420" href="#L420">420</a><a id="L421" href="#L421">421</a><a id="L422" href="#L422">422</a><a id="L423" href="#L423">423</a><a id="L424" href="#L424">424</a><a id="L425" href="#L425">425</a><a id="L426" href="#L426">426</a><a id="L427" href="#L427">427</a><a id="L428" href="#L428">428</a><a id="L429" href="#L429">429</a><a id="L430" href="#L430">430</a><a id="L431" href="#L431">431</a><a id="L432" href="#L432">432</a><a id="L433" href="#L433">433</a><a id="L434" href="#L434">434</a><a id="L435" href="#L435">435</a><a id="L436" href="#L436">436</a><a id="L437" href="#L437">437</a><a id="L438" href="#L438">438</a><a id="L439" href="#L439">439</a><a id="L440" href="#L440">440</a><a id="L441" href="#L441">441</a><a id="L442" href="#L442">442</a><a id="L443" href="#L443">443</a><a id="L444" href="#L444">444</a><a id="L445" href="#L445">445</a><a id="L446" href="#L446">446</a><a id="L447" href="#L447">447</a><a id="L448" href="#L448">448</a><a id="L449" href="#L449">449</a><a id="L450" href="#L450">450</a><a id="L451" href="#L451">451</a><a id="L452" href="#L452">452</a><a id="L453" href="#L453">453</a><a id="L454" href="#L454">454</a><a id="L455" href="#L455">455</a><a id="L456" href="#L456">456</a><a id="L457" href="#L457">457</a><a id="L458" href="#L458">458</a><a id="L459" href="#L459">459</a><a id="L460" href="#L460">460</a><a id="L461" href="#L461">461</a><a id="L462" href="#L462">462</a><a id="L463" href="#L463">463</a><a id="L464" href="#L464">464</a><a id="L465" href="#L465">465</a><a id="L466" href="#L466">466</a><a id="L467" href="#L467">467</a><a id="L468" href="#L468">468</a><a id="L469" href="#L469">469</a><a id="L470" href="#L470">470</a><a id="L471" href="#L471">471</a><a id="L472" href="#L472">472</a><a id="L473" href="#L473">473</a><a id="L474" href="#L474">474</a><a id="L475" href="#L475">475</a><a id="L476" href="#L476">476</a><a id="L477" href="#L477">477</a><a id="L478" href="#L478">478</a><a id="L479" href="#L479">479</a><a id="L480" href="#L480">480</a><a id="L481" href="#L481">481</a><a id="L482" href="#L482">482</a><a id="L483" href="#L483">483</a><a id="L484" href="#L484">484</a><a id="L485" href="#L485">485</a><a id="L486" href="#L486">486</a><a id="L487" href="#L487">487</a><a id="L488" href="#L488">488</a><a id="L489" href="#L489">489</a><a id="L490" href="#L490">490</a><a id="L491" href="#L491">491</a><a id="L492" href="#L492">492</a><a id="L493" href="#L493">493</a><a id="L494" href="#L494">494</a><a id="L495" href="#L495">495</a><a id="L496" href="#L496">496</a><a id="L497" href="#L497">497</a><a id="L498" href="#L498">498</a><a id="L499" href="#L499">499</a><a id="L500" href="#L500">500</a><a id="L501" href="#L501">501</a><a id="L502" href="#L502">502</a><a id="L503" href="#L503">503</a><a id="L504" href="#L504">504</a><a id="L505" href="#L505">505</a><a id="L506" href="#L506">506</a><a id="L507" href="#L507">507</a><a id="L508" href="#L508">508</a><a id="L509" href="#L509">509</a><a id="L510" href="#L510">510</a><a id="L511" href="#L511">511</a><a id="L512" href="#L512">512</a><a id="L513" href="#L513">513</a><a id="L514" href="#L514">514</a><a id="L515" href="#L515">515</a><a id="L516" href="#L516">516</a><a id="L517" href="#L517">517</a><a id="L518" href="#L518">518</a><a id="L519" href="#L519">519</a><a id="L520" href="#L520">520</a><a id="L521" href="#L521">521</a><a id="L522" href="#L522">522</a><a id="L523" href="#L523">523</a><a id="L524" href="#L524">524</a><a id="L525" href="#L525">525</a><a id="L526" href="#L526">526</a><a id="L527" href="#L527">527</a><a id="L528" href="#L528">528</a><a id="L529" href="#L529">529</a><a id="L530" href="#L530">530</a><a id="L531" href="#L531">531</a><a id="L532" href="#L532">532</a><a id="L533" href="#L533">533</a><a id="L534" href="#L534">534</a><a id="L535" href="#L535">535</a><a id="L536" href="#L536">536</a><a id="L537" href="#L537">537</a><a id="L538" href="#L538">538</a><a id="L539" href="#L539">539</a><a id="L540" href="#L540">540</a><a id="L541" href="#L541">541</a><a id="L542" href="#L542">542</a><a id="L543" href="#L543">543</a><a id="L544" href="#L544">544</a><a id="L545" href="#L545">545</a><a id="L546" href="#L546">546</a><a id="L547" href="#L547">547</a><a id="L548" href="#L548">548</a><a id="L549" href="#L549">549</a><a id="L550" href="#L550">550</a><a id="L551" href="#L551">551</a><a id="L552" href="#L552">552</a><a id="L553" href="#L553">553</a><a id="L554" href="#L554">554</a><a id="L555" href="#L555">555</a><a id="L556" href="#L556">556</a><a id="L557" href="#L557">557</a><a id="L558" href="#L558">558</a><a id="L559" href="#L559">559</a><a id="L560" href="#L560">560</a><a id="L561" href="#L561">561</a><a id="L562" href="#L562">562</a><a id="L563" href="#L563">563</a><a id="L564" href="#L564">564</a><a id="L565" href="#L565">565</a><a id="L566" href="#L566">566</a><a id="L567" href="#L567">567</a><a id="L568" href="#L568">568</a><a id="L569" href="#L569">569</a><a id="L570" href="#L570">570</a><a id="L571" href="#L571">571</a><a id="L572" href="#L572">572</a><a id="L573" href="#L573">573</a><a id="L574" href="#L574">574</a><a id="L575" href="#L575">575</a><a id="L576" href="#L576">576</a><a id="L577" href="#L577">577</a><a id="L578" href="#L578">578</a><a id="L579" href="#L579">579</a><a id="L580" href="#L580">580</a><a id="L581" href="#L581">581</a><a id="L582" href="#L582">582</a><a id="L583" href="#L583">583</a><a id="L584" href="#L584">584</a><a id="L585" href="#L585">585</a><a id="L586" href="#L586">586</a><a id="L587" href="#L587">587</a><a id="L588" href="#L588">588</a><a id="L589" href="#L589">589</a><a id="L590" href="#L590">590</a><a id="L591" href="#L591">591</a><a id="L592" href="#L592">592</a><a id="L593" href="#L593">593</a><a id="L594" href="#L594">594</a><a id="L595" href="#L595">595</a><a id="L596" href="#L596">596</a><a id="L597" href="#L597">597</a><a id="L598" href="#L598">598</a><a id="L599" href="#L599">599</a><a id="L600" href="#L600">600</a><a id="L601" href="#L601">601</a><a id="L602" href="#L602">602</a><a id="L603" href="#L603">603</a><a id="L604" href="#L604">604</a><a id="L605" href="#L605">605</a><a id="L606" href="#L606">606</a><a id="L607" href="#L607">607</a><a id="L608" href="#L608">608</a><a id="L609" href="#L609">609</a><a id="L610" href="#L610">610</a><a id="L611" href="#L611">611</a><a id="L612" href="#L612">612</a><a id="L613" href="#L613">613</a><a id="L614" href="#L614">614</a><a id="L615" href="#L615">615</a><a id="L616" href="#L616">616</a><a id="L617" href="#L617">617</a><a id="L618" href="#L618">618</a><a id="L619" href="#L619">619</a><a id="L620" href="#L620">620</a><a id="L621" href="#L621">621</a><a id="L622" href="#L622">622</a><a id="L623" href="#L623">623</a><a id="L624" href="#L624">624</a><a id="L625" href="#L625">625</a><a id="L626" href="#L626">626</a><a id="L627" href="#L627">627</a><a id="L628" href="#L628">628</a><a id="L629" href="#L629">629</a><a id="L630" href="#L630">630</a><a id="L631" href="#L631">631</a><a id="L632" href="#L632">632</a><a id="L633" href="#L633">633</a><a id="L634" href="#L634">634</a><a id="L635" href="#L635">635</a><a id="L636" href="#L636">636</a><a id="L637" href="#L637">637</a><a id="L638" href="#L638">638</a><a id="L639" href="#L639">639</a><a id="L640" href="#L640">640</a><a id="L641" href="#L641">641</a><a id="L642" href="#L642">642</a><a id="L643" href="#L643">643</a><a id="L644" href="#L644">644</a><a id="L645" href="#L645">645</a><a id="L646" href="#L646">646</a><a id="L647" href="#L647">647</a><a id="L648" href="#L648">648</a><a id="L649" href="#L649">649</a><a id="L650" href="#L650">650</a><a id="L651" href="#L651">651</a><a id="L652" href="#L652">652</a><a id="L653" href="#L653">653</a><a id="L654" href="#L654">654</a><a id="L655" href="#L655">655</a><a id="L656" href="#L656">656</a><a id="L657" href="#L657">657</a><a id="L658" href="#L658">658</a><a id="L659" href="#L659">659</a><a id="L660" href="#L660">660</a><a id="L661" href="#L661">661</a><a id="L662" href="#L662">662</a><a id="L663" href="#L663">663</a><a id="L664" href="#L664">664</a><a id="L665" href="#L665">665</a><a id="L666" href="#L666">666</a><a id="L667" href="#L667">667</a><a id="L668" href="#L668">668</a><a id="L669" href="#L669">669</a><a id="L670" href="#L670">670</a><a id="L671" href="#L671">671</a><a id="L672" href="#L672">672</a><a id="L673" href="#L673">673</a><a id="L674" href="#L674">674</a><a id="L675" href="#L675">675</a><a id="L676" href="#L676">676</a><a id="L677" href="#L677">677</a><a id="L678" href="#L678">678</a><a id="L679" href="#L679">679</a><a id="L680" href="#L680">680</a><a id="L681" href="#L681">681</a><a id="L682" href="#L682">682</a><a id="L683" href="#L683">683</a><a id="L684" href="#L684">684</a><a id="L685" href="#L685">685</a><a id="L686" href="#L686">686</a><a id="L687" href="#L687">687</a><a id="L688" href="#L688">688</a><a id="L689" href="#L689">689</a><a id="L690" href="#L690">690</a><a id="L691" href="#L691">691</a><a id="L692" href="#L692">692</a><a id="L693" href="#L693">693</a><a id="L694" href="#L694">694</a><a id="L695" href="#L695">695</a><a id="L696" href="#L696">696</a><a id="L697" href="#L697">697</a><a id="L698" href="#L698">698</a><a id="L699" href="#L699">699</a><a id="L700" href="#L700">700</a><a id="L701" href="#L701">701</a><a id="L702" href="#L702">702</a><a id="L703" href="#L703">703</a><a id="L704" href="#L704">704</a><a id="L705" href="#L705">705</a><a id="L706" href="#L706">706</a><a id="L707" href="#L707">707</a><a id="L708" href="#L708">708</a><a id="L709" href="#L709">709</a><a id="L710" href="#L710">710</a><a id="L711" href="#L711">711</a><a id="L712" href="#L712">712</a><a id="L713" href="#L713">713</a><a id="L714" href="#L714">714</a><a id="L715" href="#L715">715</a><a id="L716" href="#L716">716</a><a id="L717" href="#L717">717</a><a id="L718" href="#L718">718</a><a id="L719" href="#L719">719</a><a id="L720" href="#L720">720</a><a id="L721" href="#L721">721</a><a id="L722" href="#L722">722</a><a id="L723" href="#L723">723</a><a id="L724" href="#L724">724</a><a id="L725" href="#L725">725</a><a id="L726" href="#L726">726</a><a id="L727" href="#L727">727</a><a id="L728" href="#L728">728</a><a id="L729" href="#L729">729</a><a id="L730" href="#L730">730</a><a id="L731" href="#L731">731</a><a id="L732" href="#L732">732</a><a id="L733" href="#L733">733</a><a id="L734" href="#L734">734</a><a id="L735" href="#L735">735</a><a id="L736" href="#L736">736</a><a id="L737" href="#L737">737</a><a id="L738" href="#L738">738</a><a id="L739" href="#L739">739</a><a id="L740" href="#L740">740</a><a id="L741" href="#L741">741</a><a id="L742" href="#L742">742</a><a id="L743" href="#L743">743</a><a id="L744" href="#L744">744</a><a id="L745" href="#L745">745</a><a id="L746" href="#L746">746</a><a id="L747" href="#L747">747</a><a id="L748" href="#L748">748</a><a id="L749" href="#L749">749</a><a id="L750" href="#L750">750</a><a id="L751" href="#L751">751</a><a id="L752" href="#L752">752</a><a id="L753" href="#L753">753</a><a id="L754" href="#L754">754</a><a id="L755" href="#L755">755</a><a id="L756" href="#L756">756</a><a id="L757" href="#L757">757</a><a id="L758" href="#L758">758</a><a id="L759" href="#L759">759</a><a id="L760" href="#L760">760</a><a id="L761" href="#L761">761</a><a id="L762" href="#L762">762</a><a id="L763" href="#L763">763</a><a id="L764" href="#L764">764</a><a id="L765" href="#L765">765</a><a id="L766" href="#L766">766</a><a id="L767" href="#L767">767</a><a id="L768" href="#L768">768</a><a id="L769" href="#L769">769</a><a id="L770" href="#L770">770</a><a id="L771" href="#L771">771</a><a id="L772" href="#L772">772</a><a id="L773" href="#L773">773</a><a id="L774" href="#L774">774</a><a id="L775" href="#L775">775</a><a id="L776" href="#L776">776</a><a id="L777" href="#L777">777</a><a id="L778" href="#L778">778</a><a id="L779" href="#L779">779</a><a id="L780" href="#L780">780</a><a id="L781" href="#L781">781</a><a id="L782" href="#L782">782</a><a id="L783" href="#L783">783</a><a id="L784" href="#L784">784</a><a id="L785" href="#L785">785</a><a id="L786" href="#L786">786</a><a id="L787" href="#L787">787</a><a id="L788" href="#L788">788</a><a id="L789" href="#L789">789</a><a id="L790" href="#L790">790</a><a id="L791" href="#L791">791</a><a id="L792" href="#L792">792</a><a id="L793" href="#L793">793</a><a id="L794" href="#L794">794</a><a id="L795" href="#L795">795</a><a id="L796" href="#L796">796</a><a id="L797" href="#L797">797</a><a id="L798" href="#L798">798</a><a id="L799" href="#L799">799</a><a id="L800" href="#L800">800</a><a id="L801" href="#L801">801</a><a id="L802" href="#L802">802</a><a id="L803" href="#L803">803</a><a id="L804" href="#L804">804</a><a id="L805" href="#L805">805</a><a id="L806" href="#L806">806</a><a id="L807" href="#L807">807</a><a id="L808" href="#L808">808</a><a id="L809" href="#L809">809</a><a id="L810" href="#L810">810</a><a id="L811" href="#L811">811</a><a id="L812" href="#L812">812</a><a id="L813" href="#L813">813</a><a id="L814" href="#L814">814</a><a id="L815" href="#L815">815</a><a id="L816" href="#L816">816</a><a id="L817" href="#L817">817</a><a id="L818" href="#L818">818</a><a id="L819" href="#L819">819</a><a id="L820" href="#L820">820</a><a id="L821" href="#L821">821</a><a id="L822" href="#L822">822</a><a id="L823" href="#L823">823</a><a id="L824" href="#L824">824</a><a id="L825" href="#L825">825</a><a id="L826" href="#L826">826</a><a id="L827" href="#L827">827</a><a id="L828" href="#L828">828</a><a id="L829" href="#L829">829</a><a id="L830" href="#L830">830</a><a id="L831" href="#L831">831</a><a id="L832" href="#L832">832</a><a id="L833" href="#L833">833</a><a id="L834" href="#L834">834</a><a id="L835" href="#L835">835</a><a id="L836" href="#L836">836</a><a id="L837" href="#L837">837</a><a id="L838" href="#L838">838</a><a id="L839" href="#L839">839</a><a id="L840" href="#L840">840</a><a id="L841" href="#L841">841</a><a id="L842" href="#L842">842</a><a id="L843" href="#L843">843</a><a id="L844" href="#L844">844</a><a id="L845" href="#L845">845</a><a id="L846" href="#L846">846</a><a id="L847" href="#L847">847</a><a id="L848" href="#L848">848</a><a id="L849" href="#L849">849</a><a id="L850" href="#L850">850</a><a id="L851" href="#L851">851</a><a id="L852" href="#L852">852</a><a id="L853" href="#L853">853</a><a id="L854" href="#L854">854</a><a id="L855" href="#L855">855</a><a id="L856" href="#L856">856</a><a id="L857" href="#L857">857</a><a id="L858" href="#L858">858</a><a id="L859" href="#L859">859</a><a id="L860" href="#L860">860</a><a id="L861" href="#L861">861</a><a id="L862" href="#L862">862</a><a id="L863" href="#L863">863</a><a id="L864" href="#L864">864</a><a id="L865" href="#L865">865</a><a id="L866" href="#L866">866</a><a id="L867" href="#L867">867</a><a id="L868" href="#L868">868</a><a id="L869" href="#L869">869</a><a id="L870" href="#L870">870</a><a id="L871" href="#L871">871</a><a id="L872" href="#L872">872</a><a id="L873" href="#L873">873</a><a id="L874" href="#L874">874</a><a id="L875" href="#L875">875</a><a id="L876" href="#L876">876</a><a id="L877" href="#L877">877</a><a id="L878" href="#L878">878</a><a id="L879" href="#L879">879</a><a id="L880" href="#L880">880</a><a id="L881" href="#L881">881</a><a id="L882" href="#L882">882</a><a id="L883" href="#L883">883</a><a id="L884" href="#L884">884</a><a id="L885" href="#L885">885</a><a id="L886" href="#L886">886</a><a id="L887" href="#L887">887</a><a id="L888" href="#L888">888</a><a id="L889" href="#L889">889</a><a id="L890" href="#L890">890</a><a id="L891" href="#L891">891</a><a id="L892" href="#L892">892</a><a id="L893" href="#L893">893</a><a id="L894" href="#L894">894</a><a id="L895" href="#L895">895</a><a id="L896" href="#L896">896</a><a id="L897" href="#L897">897</a><a id="L898" href="#L898">898</a><a id="L899" href="#L899">899</a><a id="L900" href="#L900">900</a><a id="L901" href="#L901">901</a><a id="L902" href="#L902">902</a><a id="L903" href="#L903">903</a><a id="L904" href="#L904">904</a><a id="L905" href="#L905">905</a><a id="L906" href="#L906">906</a><a id="L907" href="#L907">907</a><a id="L908" href="#L908">908</a><a id="L909" href="#L909">909</a><a id="L910" href="#L910">910</a><a id="L911" href="#L911">911</a><a id="L912" href="#L912">912</a><a id="L913" href="#L913">913</a><a id="L914" href="#L914">914</a><a id="L915" href="#L915">915</a><a id="L916" href="#L916">916</a><a id="L917" href="#L917">917</a><a id="L918" href="#L918">918</a><a id="L919" href="#L919">919</a><a id="L920" href="#L920">920</a><a id="L921" href="#L921">921</a><a id="L922" href="#L922">922</a><a id="L923" href="#L923">923</a><a id="L924" href="#L924">924</a><a id="L925" href="#L925">925</a><a id="L926" href="#L926">926</a><a id="L927" href="#L927">927</a><a id="L928" href="#L928">928</a><a id="L929" href="#L929">929</a><a id="L930" href="#L930">930</a><a id="L931" href="#L931">931</a><a id="L932" href="#L932">932</a><a id="L933" href="#L933">933</a><a id="L934" href="#L934">934</a><a id="L935" href="#L935">935</a><a id="L936" href="#L936">936</a><a id="L937" href="#L937">937</a><a id="L938" href="#L938">938</a><a id="L939" href="#L939">939</a><a id="L940" href="#L940">940</a><a id="L941" href="#L941">941</a><a id="L942" href="#L942">942</a><a id="L943" href="#L943">943</a><a id="L944" href="#L944">944</a><a id="L945" href="#L945">945</a><a id="L946" href="#L946">946</a><a id="L947" href="#L947">947</a><a id="L948" href="#L948">948</a><a id="L949" href="#L949">949</a><a id="L950" href="#L950">950</a><a id="L951" href="#L951">951</a><a id="L952" href="#L952">952</a><a id="L953" href="#L953">953</a><a id="L954" href="#L954">954</a><a id="L955" href="#L955">955</a><a id="L956" href="#L956">956</a><a id="L957" href="#L957">957</a><a id="L958" href="#L958">958</a><a id="L959" href="#L959">959</a><a id="L960" href="#L960">960</a><a id="L961" href="#L961">961</a><a id="L962" href="#L962">962</a><a id="L963" href="#L963">963</a><a id="L964" href="#L964">964</a><a id="L965" href="#L965">965</a><a id="L966" href="#L966">966</a><a id="L967" href="#L967">967</a><a id="L968" href="#L968">968</a><a id="L969" href="#L969">969</a><a id="L970" href="#L970">970</a><a id="L971" href="#L971">971</a><a id="L972" href="#L972">972</a><a id="L973" href="#L973">973</a><a id="L974" href="#L974">974</a><a id="L975" href="#L975">975</a><a id="L976" href="#L976">976</a><a id="L977" href="#L977">977</a><a id="L978" href="#L978">978</a><a id="L979" href="#L979">979</a><a id="L980" href="#L980">980</a><a id="L981" href="#L981">981</a><a id="L982" href="#L982">982</a><a id="L983" href="#L983">983</a><a id="L984" href="#L984">984</a><a id="L985" href="#L985">985</a><a id="L986" href="#L986">986</a><a id="L987" href="#L987">987</a><a id="L988" href="#L988">988</a><a id="L989" href="#L989">989</a><a id="L990" href="#L990">990</a><a id="L991" href="#L991">991</a><a id="L992" href="#L992">992</a><a id="L993" href="#L993">993</a><a id="L994" href="#L994">994</a><a id="L995" href="#L995">995</a><a id="L996" href="#L996">996</a><a id="L997" href="#L997">997</a><a id="L998" href="#L998">998</a><a id="L999" href="#L999">999</a><a id="L1000" href="#L1000">1000</a><a id="L1001" href="#L1001">1001</a><a id="L1002" href="#L1002">1002</a><a id="L1003" href="#L1003">1003</a><a id="L1004" href="#L1004">1004</a><a id="L1005" href="#L1005">1005</a><a id="L1006" href="#L1006">1006</a><a id="L1007" href="#L1007">1007</a><a id="L1008" href="#L1008">1008</a><a id="L1009" href="#L1009">1009</a><a id="L1010" href="#L1010">1010</a><a id="L1011" href="#L1011">1011</a><a id="L1012" href="#L1012">1012</a><a id="L1013" href="#L1013">1013</a><a id="L1014" href="#L1014">1014</a><a id="L1015" href="#L1015">1015</a><a id="L1016" href="#L1016">1016</a><a id="L1017" href="#L1017">1017</a><a id="L1018" href="#L1018">1018</a><a id="L1019" href="#L1019">1019</a><a id="L1020" href="#L1020">1020</a><a id="L1021" href="#L1021">1021</a><a id="L1022" href="#L1022">1022</a><a id="L1023" href="#L1023">1023</a><a id="L1024" href="#L1024">1024</a><a id="L1025" href="#L1025">1025</a><a id="L1026" href="#L1026">1026</a><a id="L1027" href="#L1027">1027</a><a id="L1028" href="#L1028">1028</a><a id="L1029" href="#L1029">1029</a><a id="L1030" href="#L1030">1030</a><a id="L1031" href="#L1031">1031</a><a id="L1032" href="#L1032">1032</a><a id="L1033" href="#L1033">1033</a><a id="L1034" href="#L1034">1034</a><a id="L1035" href="#L1035">1035</a><a id="L1036" href="#L1036">1036</a><a id="L1037" href="#L1037">1037</a><a id="L1038" href="#L1038">1038</a><a id="L1039" href="#L1039">1039</a><a id="L1040" href="#L1040">1040</a><a id="L1041" href="#L1041">1041</a><a id="L1042" href="#L1042">1042</a><a id="L1043" href="#L1043">1043</a><a id="L1044" href="#L1044">1044</a><a id="L1045" href="#L1045">1045</a><a id="L1046" href="#L1046">1046</a><a id="L1047" href="#L1047">1047</a><a id="L1048" href="#L1048">1048</a><a id="L1049" href="#L1049">1049</a><a id="L1050" href="#L1050">1050</a><a id="L1051" href="#L1051">1051</a><a id="L1052" href="#L1052">1052</a><a id="L1053" href="#L1053">1053</a><a id="L1054" href="#L1054">1054</a><a id="L1055" href="#L1055">1055</a><a id="L1056" href="#L1056">1056</a><a id="L1057" href="#L1057">1057</a><a id="L1058" href="#L1058">1058</a><a id="L1059" href="#L1059">1059</a><a id="L1060" href="#L1060">1060</a><a id="L1061" href="#L1061">1061</a><a id="L1062" href="#L1062">1062</a><a id="L1063" href="#L1063">1063</a><a id="L1064" href="#L1064">1064</a><a id="L1065" href="#L1065">1065</a><a id="L1066" href="#L1066">1066</a><a id="L1067" href="#L1067">1067</a><a id="L1068" href="#L1068">1068</a><a id="L1069" href="#L1069">1069</a><a id="L1070" href="#L1070">1070</a><a id="L1071" href="#L1071">1071</a><a id="L1072" href="#L1072">1072</a><a id="L1073" href="#L1073">1073</a><a id="L1074" href="#L1074">1074</a><a id="L1075" href="#L1075">1075</a><a id="L1076" href="#L1076">1076</a><a id="L1077" href="#L1077">1077</a><a id="L1078" href="#L1078">1078</a><a id="L1079" href="#L1079">1079</a><a id="L1080" href="#L1080">1080</a><a id="L1081" href="#L1081">1081</a><a id="L1082" href="#L1082">1082</a><a id="L1083" href="#L1083">1083</a><a id="L1084" href="#L1084">1084</a><a id="L1085" href="#L1085">1085</a><a id="L1086" href="#L1086">1086</a><a id="L1087" href="#L1087">1087</a><a id="L1088" href="#L1088">1088</a><a id="L1089" href="#L1089">1089</a><a id="L1090" href="#L1090">1090</a><a id="L1091" href="#L1091">1091</a><a id="L1092" href="#L1092">1092</a><a id="L1093" href="#L1093">1093</a><a id="L1094" href="#L1094">1094</a><a id="L1095" href="#L1095">1095</a><a id="L1096" href="#L1096">1096</a><a id="L1097" href="#L1097">1097</a><a id="L1098" href="#L1098">1098</a><a id="L1099" href="#L1099">1099</a><a id="L1100" href="#L1100">1100</a><a id="L1101" href="#L1101">1101</a><a id="L1102" href="#L1102">1102</a><a id="L1103" href="#L1103">1103</a><a id="L1104" href="#L1104">1104</a><a id="L1105" href="#L1105">1105</a><a id="L1106" href="#L1106">1106</a><a id="L1107" href="#L1107">1107</a><a id="L1108" href="#L1108">1108</a><a id="L1109" href="#L1109">1109</a><a id="L1110" href="#L1110">1110</a><a id="L1111" href="#L1111">1111</a><a id="L1112" href="#L1112">1112</a><a id="L1113" href="#L1113">1113</a><a id="L1114" href="#L1114">1114</a><a id="L1115" href="#L1115">1115</a><a id="L1116" href="#L1116">1116</a><a id="L1117" href="#L1117">1117</a><a id="L1118" href="#L1118">1118</a><a id="L1119" href="#L1119">1119</a><a id="L1120" href="#L1120">1120</a><a id="L1121" href="#L1121">1121</a><a id="L1122" href="#L1122">1122</a><a id="L1123" href="#L1123">1123</a><a id="L1124" href="#L1124">1124</a><a id="L1125" href="#L1125">1125</a><a id="L1126" href="#L1126">1126</a><a id="L1127" href="#L1127">1127</a><a id="L1128" href="#L1128">1128</a><a id="L1129" href="#L1129">1129</a><a id="L1130" href="#L1130">1130</a><a id="L1131" href="#L1131">1131</a><a id="L1132" href="#L1132">1132</a><a id="L1133" href="#L1133">1133</a><a id="L1134" href="#L1134">1134</a><a id="L1135" href="#L1135">1135</a><a id="L1136" href="#L1136">1136</a><a id="L1137" href="#L1137">1137</a><a id="L1138" href="#L1138">1138</a><a id="L1139" href="#L1139">1139</a><a id="L1140" href="#L1140">1140</a><a id="L1141" href="#L1141">1141</a><a id="L1142" href="#L1142">1142</a><a id="L1143" href="#L1143">1143</a><a id="L1144" href="#L1144">1144</a><a id="L1145" href="#L1145">1145</a><a id="L1146" href="#L1146">1146</a><a id="L1147" href="#L1147">1147</a><a id="L1148" href="#L1148">1148</a><a id="L1149" href="#L1149">1149</a><a id="L1150" href="#L1150">1150</a><a id="L1151" href="#L1151">1151</a><a id="L1152" href="#L1152">1152</a><a id="L1153" href="#L1153">1153</a><a id="L1154" href="#L1154">1154</a><a id="L1155" href="#L1155">1155</a><a id="L1156" href="#L1156">1156</a><a id="L1157" href="#L1157">1157</a><a id="L1158" href="#L1158">1158</a><a id="L1159" href="#L1159">1159</a><a id="L1160" href="#L1160">1160</a><a id="L1161" href="#L1161">1161</a><a id="L1162" href="#L1162">1162</a><a id="L1163" href="#L1163">1163</a><a id="L1164" href="#L1164">1164</a><a id="L1165" href="#L1165">1165</a><a id="L1166" href="#L1166">1166</a><a id="L1167" href="#L1167">1167</a><a id="L1168" href="#L1168">1168</a><a id="L1169" href="#L1169">1169</a><a id="L1170" href="#L1170">1170</a><a id="L1171" href="#L1171">1171</a><a id="L1172" href="#L1172">1172</a><a id="L1173" href="#L1173">1173</a><a id="L1174" href="#L1174">1174</a><a id="L1175" href="#L1175">1175</a><a id="L1176" href="#L1176">1176</a><a id="L1177" href="#L1177">1177</a><a id="L1178" href="#L1178">1178</a><a id="L1179" href="#L1179">1179</a><a id="L1180" href="#L1180">1180</a><a id="L1181" href="#L1181">1181</a><a id="L1182" href="#L1182">1182</a><a id="L1183" href="#L1183">1183</a><a id="L1184" href="#L1184">1184</a><a id="L1185" href="#L1185">1185</a><a id="L1186" href="#L1186">1186</a><a id="L1187" href="#L1187">1187</a><a id="L1188" href="#L1188">1188</a><a id="L1189" href="#L1189">1189</a><a id="L1190" href="#L1190">1190</a><a id="L1191" href="#L1191">1191</a><a id="L1192" href="#L1192">1192</a><a id="L1193" href="#L1193">1193</a><a id="L1194" href="#L1194">1194</a><a id="L1195" href="#L1195">1195</a><a id="L1196" href="#L1196">1196</a><a id="L1197" href="#L1197">1197</a><a id="L1198" href="#L1198">1198</a><a id="L1199" href="#L1199">1199</a><a id="L1200" href="#L1200">1200</a><a id="L1201" href="#L1201">1201</a><a id="L1202" href="#L1202">1202</a><a id="L1203" href="#L1203">1203</a><a id="L1204" href="#L1204">1204</a><a id="L1205" href="#L1205">1205</a><a id="L1206" href="#L1206">1206</a><a id="L1207" href="#L1207">1207</a><a id="L1208" href="#L1208">1208</a><a id="L1209" href="#L1209">1209</a><a id="L1210" href="#L1210">1210</a><a id="L1211" href="#L1211">1211</a><a id="L1212" href="#L1212">1212</a><a id="L1213" href="#L1213">1213</a><a id="L1214" href="#L1214">1214</a><a id="L1215" href="#L1215">1215</a><a id="L1216" href="#L1216">1216</a><a id="L1217" href="#L1217">1217</a><a id="L1218" href="#L1218">1218</a><a id="L1219" href="#L1219">1219</a><a id="L1220" href="#L1220">1220</a><a id="L1221" href="#L1221">1221</a><a id="L1222" href="#L1222">1222</a><a id="L1223" href="#L1223">1223</a><a id="L1224" href="#L1224">1224</a><a id="L1225" href="#L1225">1225</a><a id="L1226" href="#L1226">1226</a><a id="L1227" href="#L1227">1227</a><a id="L1228" href="#L1228">1228</a><a id="L1229" href="#L1229">1229</a><a id="L1230" href="#L1230">1230</a><a id="L1231" href="#L1231">1231</a><a id="L1232" href="#L1232">1232</a><a id="L1233" href="#L1233">1233</a><a id="L1234" href="#L1234">1234</a><a id="L1235" href="#L1235">1235</a><a id="L1236" href="#L1236">1236</a><a id="L1237" href="#L1237">1237</a><a id="L1238" href="#L1238">1238</a><a id="L1239" href="#L1239">1239</a><a id="L1240" href="#L1240">1240</a><a id="L1241" href="#L1241">1241</a><a id="L1242" href="#L1242">1242</a><a id="L1243" href="#L1243">1243</a><a id="L1244" href="#L1244">1244</a><a id="L1245" href="#L1245">1245</a><a id="L1246" href="#L1246">1246</a><a id="L1247" href="#L1247">1247</a><a id="L1248" href="#L1248">1248</a><a id="L1249" href="#L1249">1249</a><a id="L1250" href="#L1250">1250</a><a id="L1251" href="#L1251">1251</a><a id="L1252" href="#L1252">1252</a><a id="L1253" href="#L1253">1253</a><a id="L1254" href="#L1254">1254</a><a id="L1255" href="#L1255">1255</a><a id="L1256" href="#L1256">1256</a><a id="L1257" href="#L1257">1257</a><a id="L1258" href="#L1258">1258</a><a id="L1259" href="#L1259">1259</a><a id="L1260" href="#L1260">1260</a><a id="L1261" href="#L1261">1261</a><a id="L1262" href="#L1262">1262</a><a id="L1263" href="#L1263">1263</a><a id="L1264" href="#L1264">1264</a><a id="L1265" href="#L1265">1265</a><a id="L1266" href="#L1266">1266</a><a id="L1267" href="#L1267">1267</a><a id="L1268" href="#L1268">1268</a><a id="L1269" href="#L1269">1269</a><a id="L1270" href="#L1270">1270</a><a id="L1271" href="#L1271">1271</a><a id="L1272" href="#L1272">1272</a><a id="L1273" href="#L1273">1273</a><a id="L1274" href="#L1274">1274</a><a id="L1275" href="#L1275">1275</a><a id="L1276" href="#L1276">1276</a><a id="L1277" href="#L1277">1277</a><a id="L1278" href="#L1278">1278</a><a id="L1279" href="#L1279">1279</a><a id="L1280" href="#L1280">1280</a><a id="L1281" href="#L1281">1281</a><a id="L1282" href="#L1282">1282</a><a id="L1283" href="#L1283">1283</a><a id="L1284" href="#L1284">1284</a><a id="L1285" href="#L1285">1285</a><a id="L1286" href="#L1286">1286</a><a id="L1287" href="#L1287">1287</a><a id="L1288" href="#L1288">1288</a><a id="L1289" href="#L1289">1289</a><a id="L1290" href="#L1290">1290</a><a id="L1291" href="#L1291">1291</a><a id="L1292" href="#L1292">1292</a><a id="L1293" href="#L1293">1293</a><a id="L1294" href="#L1294">1294</a><a id="L1295" href="#L1295">1295</a><a id="L1296" href="#L1296">1296</a><a id="L1297" href="#L1297">1297</a><a id="L1298" href="#L1298">1298</a><a id="L1299" href="#L1299">1299</a><a id="L1300" href="#L1300">1300</a><a id="L1301" href="#L1301">1301</a><a id="L1302" href="#L1302">1302</a><a id="L1303" href="#L1303">1303</a><a id="L1304" href="#L1304">1304</a><a id="L1305" href="#L1305">1305</a><a id="L1306" href="#L1306">1306</a><a id="L1307" href="#L1307">1307</a><a id="L1308" href="#L1308">1308</a><a id="L1309" href="#L1309">1309</a><a id="L1310" href="#L1310">1310</a><a id="L1311" href="#L1311">1311</a><a id="L1312" href="#L1312">1312</a><a id="L1313" href="#L1313">1313</a><a id="L1314" href="#L1314">1314</a><a id="L1315" href="#L1315">1315</a><a id="L1316" href="#L1316">1316</a><a id="L1317" href="#L1317">1317</a><a id="L1318" href="#L1318">1318</a><a id="L1319" href="#L1319">1319</a><a id="L1320" href="#L1320">1320</a><a id="L1321" href="#L1321">1321</a><a id="L1322" href="#L1322">1322</a><a id="L1323" href="#L1323">1323</a><a id="L1324" href="#L1324">1324</a><a id="L1325" href="#L1325">1325</a><a id="L1326" href="#L1326">1326</a><a id="L1327" href="#L1327">1327</a><a id="L1328" href="#L1328">1328</a><a id="L1329" href="#L1329">1329</a><a id="L1330" href="#L1330">1330</a><a id="L1331" href="#L1331">1331</a><a id="L1332" href="#L1332">1332</a><a id="L1333" href="#L1333">1333</a><a id="L1334" href="#L1334">1334</a><a id="L1335" href="#L1335">1335</a><a id="L1336" href="#L1336">1336</a><a id="L1337" href="#L1337">1337</a><a id="L1338" href="#L1338">1338</a><a id="L1339" href="#L1339">1339</a><a id="L1340" href="#L1340">1340</a><a id="L1341" href="#L1341">1341</a><a id="L1342" href="#L1342">1342</a><a id="L1343" href="#L1343">1343</a><a id="L1344" href="#L1344">1344</a><a id="L1345" href="#L1345">1345</a><a id="L1346" href="#L1346">1346</a><a id="L1347" href="#L1347">1347</a><a id="L1348" href="#L1348">1348</a><a id="L1349" href="#L1349">1349</a><a id="L1350" href="#L1350">1350</a><a id="L1351" href="#L1351">1351</a><a id="L1352" href="#L1352">1352</a><a id="L1353" href="#L1353">1353</a><a id="L1354" href="#L1354">1354</a><a id="L1355" href="#L1355">1355</a><a id="L1356" href="#L1356">1356</a><a id="L1357" href="#L1357">1357</a><a id="L1358" href="#L1358">1358</a><a id="L1359" href="#L1359">1359</a><a id="L1360" href="#L1360">1360</a><a id="L1361" href="#L1361">1361</a><a id="L1362" href="#L1362">1362</a><a id="L1363" href="#L1363">1363</a><a id="L1364" href="#L1364">1364</a><a id="L1365" href="#L1365">1365</a><a id="L1366" href="#L1366">1366</a><a id="L1367" href="#L1367">1367</a><a id="L1368" href="#L1368">1368</a><a id="L1369" href="#L1369">1369</a><a id="L1370" href="#L1370">1370</a><a id="L1371" href="#L1371">1371</a><a id="L1372" href="#L1372">1372</a><a id="L1373" href="#L1373">1373</a><a id="L1374" href="#L1374">1374</a><a id="L1375" href="#L1375">1375</a><a id="L1376" href="#L1376">1376</a><a id="L1377" href="#L1377">1377</a><a id="L1378" href="#L1378">1378</a><a id="L1379" href="#L1379">1379</a><a id="L1380" href="#L1380">1380</a><a id="L1381" href="#L1381">1381</a><a id="L1382" href="#L1382">1382</a><a id="L1383" href="#L1383">1383</a><a id="L1384" href="#L1384">1384</a><a id="L1385" href="#L1385">1385</a><a id="L1386" href="#L1386">1386</a><a id="L1387" href="#L1387">1387</a><a id="L1388" href="#L1388">1388</a><a id="L1389" href="#L1389">1389</a><a id="L1390" href="#L1390">1390</a><a id="L1391" href="#L1391">1391</a><a id="L1392" href="#L1392">1392</a><a id="L1393" href="#L1393">1393</a><a id="L1394" href="#L1394">1394</a><a id="L1395" href="#L1395">1395</a><a id="L1396" href="#L1396">1396</a><a id="L1397" href="#L1397">1397</a><a id="L1398" href="#L1398">1398</a><a id="L1399" href="#L1399">1399</a><a id="L1400" href="#L1400">1400</a><a id="L1401" href="#L1401">1401</a><a id="L1402" href="#L1402">1402</a><a id="L1403" href="#L1403">1403</a><a id="L1404" href="#L1404">1404</a><a id="L1405" href="#L1405">1405</a><a id="L1406" href="#L1406">1406</a><a id="L1407" href="#L1407">1407</a><a id="L1408" href="#L1408">1408</a><a id="L1409" href="#L1409">1409</a><a id="L1410" href="#L1410">1410</a><a id="L1411" href="#L1411">1411</a><a id="L1412" href="#L1412">1412</a><a id="L1413" href="#L1413">1413</a><a id="L1414" href="#L1414">1414</a><a id="L1415" href="#L1415">1415</a><a id="L1416" href="#L1416">1416</a><a id="L1417" href="#L1417">1417</a><a id="L1418" href="#L1418">1418</a><a id="L1419" href="#L1419">1419</a><a id="L1420" href="#L1420">1420</a><a id="L1421" href="#L1421">1421</a><a id="L1422" href="#L1422">1422</a><a id="L1423" href="#L1423">1423</a><a id="L1424" href="#L1424">1424</a><a id="L1425" href="#L1425">1425</a><a id="L1426" href="#L1426">1426</a><a id="L1427" href="#L1427">1427</a><a id="L1428" href="#L1428">1428</a><a id="L1429" href="#L1429">1429</a><a id="L1430" href="#L1430">1430</a><a id="L1431" href="#L1431">1431</a><a id="L1432" href="#L1432">1432</a><a id="L1433" href="#L1433">1433</a><a id="L1434" href="#L1434">1434</a><a id="L1435" href="#L1435">1435</a><a id="L1436" href="#L1436">1436</a><a id="L1437" href="#L1437">1437</a><a id="L1438" href="#L1438">1438</a><a id="L1439" href="#L1439">1439</a><a id="L1440" href="#L1440">1440</a><a id="L1441" href="#L1441">1441</a><a id="L1442" href="#L1442">1442</a><a id="L1443" href="#L1443">1443</a><a id="L1444" href="#L1444">1444</a><a id="L1445" href="#L1445">1445</a><a id="L1446" href="#L1446">1446</a><a id="L1447" href="#L1447">1447</a><a id="L1448" href="#L1448">1448</a><a id="L1449" href="#L1449">1449</a><a id="L1450" href="#L1450">1450</a><a id="L1451" href="#L1451">1451</a><a id="L1452" href="#L1452">1452</a><a id="L1453" href="#L1453">1453</a><a id="L1454" href="#L1454">1454</a><a id="L1455" href="#L1455">1455</a><a id="L1456" href="#L1456">1456</a><a id="L1457" href="#L1457">1457</a><a id="L1458" href="#L1458">1458</a><a id="L1459" href="#L1459">1459</a><a id="L1460" href="#L1460">1460</a><a id="L1461" href="#L1461">1461</a><a id="L1462" href="#L1462">1462</a><a id="L1463" href="#L1463">1463</a><a id="L1464" href="#L1464">1464</a><a id="L1465" href="#L1465">1465</a><a id="L1466" href="#L1466">1466</a><a id="L1467" href="#L1467">1467</a><a id="L1468" href="#L1468">1468</a><a id="L1469" href="#L1469">1469</a><a id="L1470" href="#L1470">1470</a><a id="L1471" href="#L1471">1471</a><a id="L1472" href="#L1472">1472</a><a id="L1473" href="#L1473">1473</a><a id="L1474" href="#L1474">1474</a><a id="L1475" href="#L1475">1475</a><a id="L1476" href="#L1476">1476</a><a id="L1477" href="#L1477">1477</a><a id="L1478" href="#L1478">1478</a><a id="L1479" href="#L1479">1479</a><a id="L1480" href="#L1480">1480</a><a id="L1481" href="#L1481">1481</a><a id="L1482" href="#L1482">1482</a><a id="L1483" href="#L1483">1483</a><a id="L1484" href="#L1484">1484</a><a id="L1485" href="#L1485">1485</a><a id="L1486" href="#L1486">1486</a><a id="L1487" href="#L1487">1487</a><a id="L1488" href="#L1488">1488</a><a id="L1489" href="#L1489">1489</a><a id="L1490" href="#L1490">1490</a><a id="L1491" href="#L1491">1491</a><a id="L1492" href="#L1492">1492</a><a id="L1493" href="#L1493">1493</a><a id="L1494" href="#L1494">1494</a><a id="L1495" href="#L1495">1495</a><a id="L1496" href="#L1496">1496</a><a id="L1497" href="#L1497">1497</a><a id="L1498" href="#L1498">1498</a><a id="L1499" href="#L1499">1499</a><a id="L1500" href="#L1500">1500</a><a id="L1501" href="#L1501">1501</a><a id="L1502" href="#L1502">1502</a><a id="L1503" href="#L1503">1503</a><a id="L1504" href="#L1504">1504</a><a id="L1505" href="#L1505">1505</a><a id="L1506" href="#L1506">1506</a><a id="L1507" href="#L1507">1507</a><a id="L1508" href="#L1508">1508</a><a id="L1509" href="#L1509">1509</a><a id="L1510" href="#L1510">1510</a><a id="L1511" href="#L1511">1511</a><a id="L1512" href="#L1512">1512</a><a id="L1513" href="#L1513">1513</a><a id="L1514" href="#L1514">1514</a><a id="L1515" href="#L1515">1515</a><a id="L1516" href="#L1516">1516</a><a id="L1517" href="#L1517">1517</a><a id="L1518" href="#L1518">1518</a><a id="L1519" href="#L1519">1519</a><a id="L1520" href="#L1520">1520</a><a id="L1521" href="#L1521">1521</a><a id="L1522" href="#L1522">1522</a><a id="L1523" href="#L1523">1523</a><a id="L1524" href="#L1524">1524</a><a id="L1525" href="#L1525">1525</a><a id="L1526" href="#L1526">1526</a><a id="L1527" href="#L1527">1527</a><a id="L1528" href="#L1528">1528</a><a id="L1529" href="#L1529">1529</a><a id="L1530" href="#L1530">1530</a><a id="L1531" href="#L1531">1531</a><a id="L1532" href="#L1532">1532</a><a id="L1533" href="#L1533">1533</a><a id="L1534" href="#L1534">1534</a><a id="L1535" href="#L1535">1535</a><a id="L1536" href="#L1536">1536</a><a id="L1537" href="#L1537">1537</a><a id="L1538" href="#L1538">1538</a><a id="L1539" href="#L1539">1539</a><a id="L1540" href="#L1540">1540</a><a id="L1541" href="#L1541">1541</a><a id="L1542" href="#L1542">1542</a><a id="L1543" href="#L1543">1543</a><a id="L1544" href="#L1544">1544</a><a id="L1545" href="#L1545">1545</a><a id="L1546" href="#L1546">1546</a><a id="L1547" href="#L1547">1547</a><a id="L1548" href="#L1548">1548</a><a id="L1549" href="#L1549">1549</a><a id="L1550" href="#L1550">1550</a><a id="L1551" href="#L1551">1551</a><a id="L1552" href="#L1552">1552</a><a id="L1553" href="#L1553">1553</a><a id="L1554" href="#L1554">1554</a><a id="L1555" href="#L1555">1555</a><a id="L1556" href="#L1556">1556</a><a id="L1557" href="#L1557">1557</a><a id="L1558" href="#L1558">1558</a><a id="L1559" href="#L1559">1559</a><a id="L1560" href="#L1560">1560</a><a id="L1561" href="#L1561">1561</a><a id="L1562" href="#L1562">1562</a><a id="L1563" href="#L1563">1563</a><a id="L1564" href="#L1564">1564</a><a id="L1565" href="#L1565">1565</a><a id="L1566" href="#L1566">1566</a><a id="L1567" href="#L1567">1567</a><a id="L1568" href="#L1568">1568</a><a id="L1569" href="#L1569">1569</a><a id="L1570" href="#L1570">1570</a><a id="L1571" href="#L1571">1571</a><a id="L1572" href="#L1572">1572</a><a id="L1573" href="#L1573">1573</a><a id="L1574" href="#L1574">1574</a><a id="L1575" href="#L1575">1575</a><a id="L1576" href="#L1576">1576</a><a id="L1577" href="#L1577">1577</a><a id="L1578" href="#L1578">1578</a><a id="L1579" href="#L1579">1579</a><a id="L1580" href="#L1580">1580</a><a id="L1581" href="#L1581">1581</a><a id="L1582" href="#L1582">1582</a><a id="L1583" href="#L1583">1583</a><a id="L1584" href="#L1584">1584</a><a id="L1585" href="#L1585">1585</a><a id="L1586" href="#L1586">1586</a><a id="L1587" href="#L1587">1587</a><a id="L1588" href="#L1588">1588</a><a id="L1589" href="#L1589">1589</a><a id="L1590" href="#L1590">1590</a><a id="L1591" href="#L1591">1591</a><a id="L1592" href="#L1592">1592</a><a id="L1593" href="#L1593">1593</a><a id="L1594" href="#L1594">1594</a><a id="L1595" href="#L1595">1595</a><a id="L1596" href="#L1596">1596</a><a id="L1597" href="#L1597">1597</a><a id="L1598" href="#L1598">1598</a><a id="L1599" href="#L1599">1599</a><a id="L1600" href="#L1600">1600</a><a id="L1601" href="#L1601">1601</a><a id="L1602" href="#L1602">1602</a><a id="L1603" href="#L1603">1603</a><a id="L1604" href="#L1604">1604</a><a id="L1605" href="#L1605">1605</a><a id="L1606" href="#L1606">1606</a><a id="L1607" href="#L1607">1607</a><a id="L1608" href="#L1608">1608</a><a id="L1609" href="#L1609">1609</a><a id="L1610" href="#L1610">1610</a><a id="L1611" href="#L1611">1611</a><a id="L1612" href="#L1612">1612</a><a id="L1613" href="#L1613">1613</a><a id="L1614" href="#L1614">1614</a><a id="L1615" href="#L1615">1615</a><a id="L1616" href="#L1616">1616</a><a id="L1617" href="#L1617">1617</a><a id="L1618" href="#L1618">1618</a><a id="L1619" href="#L1619">1619</a><a id="L1620" href="#L1620">1620</a><a id="L1621" href="#L1621">1621</a><a id="L1622" href="#L1622">1622</a><a id="L1623" href="#L1623">1623</a><a id="L1624" href="#L1624">1624</a><a id="L1625" href="#L1625">1625</a><a id="L1626" href="#L1626">1626</a><a id="L1627" href="#L1627">1627</a><a id="L1628" href="#L1628">1628</a><a id="L1629" href="#L1629">1629</a><a id="L1630" href="#L1630">1630</a><a id="L1631" href="#L1631">1631</a><a id="L1632" href="#L1632">1632</a><a id="L1633" href="#L1633">1633</a><a id="L1634" href="#L1634">1634</a><a id="L1635" href="#L1635">1635</a><a id="L1636" href="#L1636">1636</a><a id="L1637" href="#L1637">1637</a><a id="L1638" href="#L1638">1638</a><a id="L1639" href="#L1639">1639</a><a id="L1640" href="#L1640">1640</a><a id="L1641" href="#L1641">1641</a><a id="L1642" href="#L1642">1642</a><a id="L1643" href="#L1643">1643</a><a id="L1644" href="#L1644">1644</a><a id="L1645" href="#L1645">1645</a><a id="L1646" href="#L1646">1646</a><a id="L1647" href="#L1647">1647</a><a id="L1648" href="#L1648">1648</a><a id="L1649" href="#L1649">1649</a><a id="L1650" href="#L1650">1650</a><a id="L1651" href="#L1651">1651</a><a id="L1652" href="#L1652">1652</a><a id="L1653" href="#L1653">1653</a><a id="L1654" href="#L1654">1654</a><a id="L1655" href="#L1655">1655</a><a id="L1656" href="#L1656">1656</a><a id="L1657" href="#L1657">1657</a><a id="L1658" href="#L1658">1658</a><a id="L1659" href="#L1659">1659</a><a id="L1660" href="#L1660">1660</a><a id="L1661" href="#L1661">1661</a><a id="L1662" href="#L1662">1662</a><a id="L1663" href="#L1663">1663</a><a id="L1664" href="#L1664">1664</a><a id="L1665" href="#L1665">1665</a><a id="L1666" href="#L1666">1666</a><a id="L1667" href="#L1667">1667</a><a id="L1668" href="#L1668">1668</a><a id="L1669" href="#L1669">1669</a><a id="L1670" href="#L1670">1670</a><a id="L1671" href="#L1671">1671</a><a id="L1672" href="#L1672">1672</a><a id="L1673" href="#L1673">1673</a><a id="L1674" href="#L1674">1674</a><a id="L1675" href="#L1675">1675</a><a id="L1676" href="#L1676">1676</a><a id="L1677" href="#L1677">1677</a><a id="L1678" href="#L1678">1678</a><a id="L1679" href="#L1679">1679</a><a id="L1680" href="#L1680">1680</a><a id="L1681" href="#L1681">1681</a><a id="L1682" href="#L1682">1682</a><a id="L1683" href="#L1683">1683</a><a id="L1684" href="#L1684">1684</a><a id="L1685" href="#L1685">1685</a><a id="L1686" href="#L1686">1686</a><a id="L1687" href="#L1687">1687</a><a id="L1688" href="#L1688">1688</a><a id="L1689" href="#L1689">1689</a><a id="L1690" href="#L1690">1690</a><a id="L1691" href="#L1691">1691</a><a id="L1692" href="#L1692">1692</a><a id="L1693" href="#L1693">1693</a><a id="L1694" href="#L1694">1694</a><a id="L1695" href="#L1695">1695</a><a id="L1696" href="#L1696">1696</a><a id="L1697" href="#L1697">1697</a><a id="L1698" href="#L1698">1698</a><a id="L1699" href="#L1699">1699</a><a id="L1700" href="#L1700">1700</a><a id="L1701" href="#L1701">1701</a><a id="L1702" href="#L1702">1702</a><a id="L1703" href="#L1703">1703</a><a id="L1704" href="#L1704">1704</a><a id="L1705" href="#L1705">1705</a><a id="L1706" href="#L1706">1706</a><a id="L1707" href="#L1707">1707</a><a id="L1708" href="#L1708">1708</a><a id="L1709" href="#L1709">1709</a><a id="L1710" href="#L1710">1710</a><a id="L1711" href="#L1711">1711</a><a id="L1712" href="#L1712">1712</a><a id="L1713" href="#L1713">1713</a><a id="L1714" href="#L1714">1714</a><a id="L1715" href="#L1715">1715</a><a id="L1716" href="#L1716">1716</a><a id="L1717" href="#L1717">1717</a><a id="L1718" href="#L1718">1718</a><a id="L1719" href="#L1719">1719</a><a id="L1720" href="#L1720">1720</a><a id="L1721" href="#L1721">1721</a><a id="L1722" href="#L1722">1722</a><a id="L1723" href="#L1723">1723</a><a id="L1724" href="#L1724">1724</a><a id="L1725" href="#L1725">1725</a><a id="L1726" href="#L1726">1726</a><a id="L1727" href="#L1727">1727</a><a id="L1728" href="#L1728">1728</a><a id="L1729" href="#L1729">1729</a><a id="L1730" href="#L1730">1730</a><a id="L1731" href="#L1731">1731</a><a id="L1732" href="#L1732">1732</a><a id="L1733" href="#L1733">1733</a><a id="L1734" href="#L1734">1734</a><a id="L1735" href="#L1735">1735</a><a id="L1736" href="#L1736">1736</a><a id="L1737" href="#L1737">1737</a><a id="L1738" href="#L1738">1738</a><a id="L1739" href="#L1739">1739</a><a id="L1740" href="#L1740">1740</a><a id="L1741" href="#L1741">1741</a><a id="L1742" href="#L1742">1742</a><a id="L1743" href="#L1743">1743</a><a id="L1744" href="#L1744">1744</a><a id="L1745" href="#L1745">1745</a><a id="L1746" href="#L1746">1746</a><a id="L1747" href="#L1747">1747</a><a id="L1748" href="#L1748">1748</a><a id="L1749" href="#L1749">1749</a><a id="L1750" href="#L1750">1750</a><a id="L1751" href="#L1751">1751</a><a id="L1752" href="#L1752">1752</a><a id="L1753" href="#L1753">1753</a><a id="L1754" href="#L1754">1754</a><a id="L1755" href="#L1755">1755</a><a id="L1756" href="#L1756">1756</a><a id="L1757" href="#L1757">1757</a><a id="L1758" href="#L1758">1758</a><a id="L1759" href="#L1759">1759</a><a id="L1760" href="#L1760">1760</a><a id="L1761" href="#L1761">1761</a><a id="L1762" href="#L1762">1762</a><a id="L1763" href="#L1763">1763</a><a id="L1764" href="#L1764">1764</a><a id="L1765" href="#L1765">1765</a><a id="L1766" href="#L1766">1766</a><a id="L1767" href="#L1767">1767</a><a id="L1768" href="#L1768">1768</a><a id="L1769" href="#L1769">1769</a><a id="L1770" href="#L1770">1770</a><a id="L1771" href="#L1771">1771</a><a id="L1772" href="#L1772">1772</a><a id="L1773" href="#L1773">1773</a><a id="L1774" href="#L1774">1774</a><a id="L1775" href="#L1775">1775</a><a id="L1776" href="#L1776">1776</a><a id="L1777" href="#L1777">1777</a><a id="L1778" href="#L1778">1778</a><a id="L1779" href="#L1779">1779</a><a id="L1780" href="#L1780">1780</a><a id="L1781" href="#L1781">1781</a><a id="L1782" href="#L1782">1782</a><a id="L1783" href="#L1783">1783</a><a id="L1784" href="#L1784">1784</a><a id="L1785" href="#L1785">1785</a><a id="L1786" href="#L1786">1786</a><a id="L1787" href="#L1787">1787</a><a id="L1788" href="#L1788">1788</a><a id="L1789" href="#L1789">1789</a><a id="L1790" href="#L1790">1790</a><a id="L1791" href="#L1791">1791</a><a id="L1792" href="#L1792">1792</a><a id="L1793" href="#L1793">1793</a><a id="L1794" href="#L1794">1794</a><a id="L1795" href="#L1795">1795</a><a id="L1796" href="#L1796">1796</a><a id="L1797" href="#L1797">1797</a><a id="L1798" href="#L1798">1798</a><a id="L1799" href="#L1799">1799</a><a id="L1800" href="#L1800">1800</a><a id="L1801" href="#L1801">1801</a><a id="L1802" href="#L1802">1802</a><a id="L1803" href="#L1803">1803</a><a id="L1804" href="#L1804">1804</a><a id="L1805" href="#L1805">1805</a><a id="L1806" href="#L1806">1806</a><a id="L1807" href="#L1807">1807</a><a id="L1808" href="#L1808">1808</a><a id="L1809" href="#L1809">1809</a><a id="L1810" href="#L1810">1810</a><a id="L1811" href="#L1811">1811</a><a id="L1812" href="#L1812">1812</a><a id="L1813" href="#L1813">1813</a><a id="L1814" href="#L1814">1814</a><a id="L1815" href="#L1815">1815</a><a id="L1816" href="#L1816">1816</a><a id="L1817" href="#L1817">1817</a><a id="L1818" href="#L1818">1818</a><a id="L1819" href="#L1819">1819</a><a id="L1820" href="#L1820">1820</a><a id="L1821" href="#L1821">1821</a><a id="L1822" href="#L1822">1822</a><a id="L1823" href="#L1823">1823</a><a id="L1824" href="#L1824">1824</a><a id="L1825" href="#L1825">1825</a><a id="L1826" href="#L1826">1826</a><a id="L1827" href="#L1827">1827</a><a id="L1828" href="#L1828">1828</a><a id="L1829" href="#L1829">1829</a><a id="L1830" href="#L1830">1830</a><a id="L1831" href="#L1831">1831</a><a id="L1832" href="#L1832">1832</a><a id="L1833" href="#L1833">1833</a><a id="L1834" href="#L1834">1834</a><a id="L1835" href="#L1835">1835</a><a id="L1836" href="#L1836">1836</a><a id="L1837" href="#L1837">1837</a><a id="L1838" href="#L1838">1838</a><a id="L1839" href="#L1839">1839</a><a id="L1840" href="#L1840">1840</a><a id="L1841" href="#L1841">1841</a><a id="L1842" href="#L1842">1842</a><a id="L1843" href="#L1843">1843</a><a id="L1844" href="#L1844">1844</a><a id="L1845" href="#L1845">1845</a><a id="L1846" href="#L1846">1846</a><a id="L1847" href="#L1847">1847</a><a id="L1848" href="#L1848">1848</a><a id="L1849" href="#L1849">1849</a><a id="L1850" href="#L1850">1850</a><a id="L1851" href="#L1851">1851</a><a id="L1852" href="#L1852">1852</a><a id="L1853" href="#L1853">1853</a><a id="L1854" href="#L1854">1854</a><a id="L1855" href="#L1855">1855</a><a id="L1856" href="#L1856">1856</a><a id="L1857" href="#L1857">1857</a><a id="L1858" href="#L1858">1858</a><a id="L1859" href="#L1859">1859</a><a id="L1860" href="#L1860">1860</a><a id="L1861" href="#L1861">1861</a><a id="L1862" href="#L1862">1862</a><a id="L1863" href="#L1863">1863</a><a id="L1864" href="#L1864">1864</a><a id="L1865" href="#L1865">1865</a><a id="L1866" href="#L1866">1866</a><a id="L1867" href="#L1867">1867</a><a id="L1868" href="#L1868">1868</a><a id="L1869" href="#L1869">1869</a><a id="L1870" href="#L1870">1870</a><a id="L1871" href="#L1871">1871</a><a id="L1872" href="#L1872">1872</a><a id="L1873" href="#L1873">1873</a><a id="L1874" href="#L1874">1874</a><a id="L1875" href="#L1875">1875</a><a id="L1876" href="#L1876">1876</a><a id="L1877" href="#L1877">1877</a><a id="L1878" href="#L1878">1878</a><a id="L1879" href="#L1879">1879</a><a id="L1880" href="#L1880">1880</a><a id="L1881" href="#L1881">1881</a><a id="L1882" href="#L1882">1882</a><a id="L1883" href="#L1883">1883</a><a id="L1884" href="#L1884">1884</a><a id="L1885" href="#L1885">1885</a><a id="L1886" href="#L1886">1886</a><a id="L1887" href="#L1887">1887</a><a id="L1888" href="#L1888">1888</a><a id="L1889" href="#L1889">1889</a><a id="L1890" href="#L1890">1890</a><a id="L1891" href="#L1891">1891</a><a id="L1892" href="#L1892">1892</a><a id="L1893" href="#L1893">1893</a><a id="L1894" href="#L1894">1894</a><a id="L1895" href="#L1895">1895</a><a id="L1896" href="#L1896">1896</a><a id="L1897" href="#L1897">1897</a><a id="L1898" href="#L1898">1898</a><a id="L1899" href="#L1899">1899</a><a id="L1900" href="#L1900">1900</a><a id="L1901" href="#L1901">1901</a><a id="L1902" href="#L1902">1902</a><a id="L1903" href="#L1903">1903</a><a id="L1904" href="#L1904">1904</a><a id="L1905" href="#L1905">1905</a><a id="L1906" href="#L1906">1906</a><a id="L1907" href="#L1907">1907</a><a id="L1908" href="#L1908">1908</a><a id="L1909" href="#L1909">1909</a><a id="L1910" href="#L1910">1910</a><a id="L1911" href="#L1911">1911</a><a id="L1912" href="#L1912">1912</a><a id="L1913" href="#L1913">1913</a><a id="L1914" href="#L1914">1914</a><a id="L1915" href="#L1915">1915</a><a id="L1916" href="#L1916">1916</a><a id="L1917" href="#L1917">1917</a><a id="L1918" href="#L1918">1918</a><a id="L1919" href="#L1919">1919</a><a id="L1920" href="#L1920">1920</a><a id="L1921" href="#L1921">1921</a><a id="L1922" href="#L1922">1922</a><a id="L1923" href="#L1923">1923</a><a id="L1924" href="#L1924">1924</a><a id="L1925" href="#L1925">1925</a><a id="L1926" href="#L1926">1926</a><a id="L1927" href="#L1927">1927</a><a id="L1928" href="#L1928">1928</a><a id="L1929" href="#L1929">1929</a><a id="L1930" href="#L1930">1930</a><a id="L1931" href="#L1931">1931</a><a id="L1932" href="#L1932">1932</a><a id="L1933" href="#L1933">1933</a><a id="L1934" href="#L1934">1934</a><a id="L1935" href="#L1935">1935</a><a id="L1936" href="#L1936">1936</a><a id="L1937" href="#L1937">1937</a><a id="L1938" href="#L1938">1938</a><a id="L1939" href="#L1939">1939</a><a id="L1940" href="#L1940">1940</a><a id="L1941" href="#L1941">1941</a><a id="L1942" href="#L1942">1942</a><a id="L1943" href="#L1943">1943</a><a id="L1944" href="#L1944">1944</a><a id="L1945" href="#L1945">1945</a><a id="L1946" href="#L1946">1946</a><a id="L1947" href="#L1947">1947</a><a id="L1948" href="#L1948">1948</a><a id="L1949" href="#L1949">1949</a><a id="L1950" href="#L1950">1950</a><a id="L1951" href="#L1951">1951</a><a id="L1952" href="#L1952">1952</a><a id="L1953" href="#L1953">1953</a><a id="L1954" href="#L1954">1954</a><a id="L1955" href="#L1955">1955</a><a id="L1956" href="#L1956">1956</a><a id="L1957" href="#L1957">1957</a><a id="L1958" href="#L1958">1958</a><a id="L1959" href="#L1959">1959</a><a id="L1960" href="#L1960">1960</a><a id="L1961" href="#L1961">1961</a><a id="L1962" href="#L1962">1962</a><a id="L1963" href="#L1963">1963</a><a id="L1964" href="#L1964">1964</a><a id="L1965" href="#L1965">1965</a><a id="L1966" href="#L1966">1966</a><a id="L1967" href="#L1967">1967</a><a id="L1968" href="#L1968">1968</a><a id="L1969" href="#L1969">1969</a><a id="L1970" href="#L1970">1970</a><a id="L1971" href="#L1971">1971</a><a id="L1972" href="#L1972">1972</a><a id="L1973" href="#L1973">1973</a><a id="L1974" href="#L1974">1974</a><a id="L1975" href="#L1975">1975</a><a id="L1976" href="#L1976">1976</a><a id="L1977" href="#L1977">1977</a><a id="L1978" href="#L1978">1978</a><a id="L1979" href="#L1979">1979</a><a id="L1980" href="#L1980">1980</a><a id="L1981" href="#L1981">1981</a><a id="L1982" href="#L1982">1982</a><a id="L1983" href="#L1983">1983</a><a id="L1984" href="#L1984">1984</a><a id="L1985" href="#L1985">1985</a><a id="L1986" href="#L1986">1986</a><a id="L1987" href="#L1987">1987</a><a id="L1988" href="#L1988">1988</a><a id="L1989" href="#L1989">1989</a><a id="L1990" href="#L1990">1990</a><a id="L1991" href="#L1991">1991</a><a id="L1992" href="#L1992">1992</a><a id="L1993" href="#L1993">1993</a><a id="L1994" href="#L1994">1994</a><a id="L1995" href="#L1995">1995</a><a id="L1996" href="#L1996">1996</a><a id="L1997" href="#L1997">1997</a><a id="L1998" href="#L1998">1998</a><a id="L1999" href="#L1999">1999</a><a id="L2000" href="#L2000">2000</a><a id="L2001" href="#L2001">2001</a><a id="L2002" href="#L2002">2002</a><a id="L2003" href="#L2003">2003</a><a id="L2004" href="#L2004">2004</a><a id="L2005" href="#L2005">2005</a><a id="L2006" href="#L2006">2006</a><a id="L2007" href="#L2007">2007</a><a id="L2008" href="#L2008">2008</a><a id="L2009" href="#L2009">2009</a><a id="L2010" href="#L2010">2010</a><a id="L2011" href="#L2011">2011</a><a id="L2012" href="#L2012">2012</a><a id="L2013" href="#L2013">2013</a><a id="L2014" href="#L2014">2014</a><a id="L2015" href="#L2015">2015</a><a id="L2016" href="#L2016">2016</a><a id="L2017" href="#L2017">2017</a><a id="L2018" href="#L2018">2018</a><a id="L2019" href="#L2019">2019</a><a id="L2020" href="#L2020">2020</a><a id="L2021" href="#L2021">2021</a><a id="L2022" href="#L2022">2022</a><a id="L2023" href="#L2023">2023</a><a id="L2024" href="#L2024">2024</a><a id="L2025" href="#L2025">2025</a><a id="L2026" href="#L2026">2026</a><a id="L2027" href="#L2027">2027</a><a id="L2028" href="#L2028">2028</a><a id="L2029" href="#L2029">2029</a><a id="L2030" href="#L2030">2030</a><a id="L2031" href="#L2031">2031</a><a id="L2032" href="#L2032">2032</a><a id="L2033" href="#L2033">2033</a><a id="L2034" href="#L2034">2034</a><a id="L2035" href="#L2035">2035</a><a id="L2036" href="#L2036">2036</a><a id="L2037" href="#L2037">2037</a><a id="L2038" href="#L2038">2038</a><a id="L2039" href="#L2039">2039</a><a id="L2040" href="#L2040">2040</a><a id="L2041" href="#L2041">2041</a><a id="L2042" href="#L2042">2042</a><a id="L2043" href="#L2043">2043</a><a id="L2044" href="#L2044">2044</a><a id="L2045" href="#L2045">2045</a><a id="L2046" href="#L2046">2046</a><a id="L2047" href="#L2047">2047</a><a id="L2048" href="#L2048">2048</a><a id="L2049" href="#L2049">2049</a><a id="L2050" href="#L2050">2050</a><a id="L2051" href="#L2051">2051</a><a id="L2052" href="#L2052">2052</a><a id="L2053" href="#L2053">2053</a><a id="L2054" href="#L2054">2054</a><a id="L2055" href="#L2055">2055</a><a id="L2056" href="#L2056">2056</a><a id="L2057" href="#L2057">2057</a><a id="L2058" href="#L2058">2058</a><a id="L2059" href="#L2059">2059</a><a id="L2060" href="#L2060">2060</a><a id="L2061" href="#L2061">2061</a><a id="L2062" href="#L2062">2062</a><a id="L2063" href="#L2063">2063</a><a id="L2064" href="#L2064">2064</a><a id="L2065" href="#L2065">2065</a><a id="L2066" href="#L2066">2066</a><a id="L2067" href="#L2067">2067</a><a id="L2068" href="#L2068">2068</a><a id="L2069" href="#L2069">2069</a><a id="L2070" href="#L2070">2070</a><a id="L2071" href="#L2071">2071</a><a id="L2072" href="#L2072">2072</a><a id="L2073" href="#L2073">2073</a><a id="L2074" href="#L2074">2074</a><a id="L2075" href="#L2075">2075</a><a id="L2076" href="#L2076">2076</a><a id="L2077" href="#L2077">2077</a><a id="L2078" href="#L2078">2078</a><a id="L2079" href="#L2079">2079</a><a id="L2080" href="#L2080">2080</a><a id="L2081" href="#L2081">2081</a><a id="L2082" href="#L2082">2082</a><a id="L2083" href="#L2083">2083</a><a id="L2084" href="#L2084">2084</a><a id="L2085" href="#L2085">2085</a><a id="L2086" href="#L2086">2086</a><a id="L2087" href="#L2087">2087</a><a id="L2088" href="#L2088">2088</a><a id="L2089" href="#L2089">2089</a><a id="L2090" href="#L2090">2090</a><a id="L2091" href="#L2091">2091</a><a id="L2092" href="#L2092">2092</a><a id="L2093" href="#L2093">2093</a><a id="L2094" href="#L2094">2094</a><a id="L2095" href="#L2095">2095</a><a id="L2096" href="#L2096">2096</a><a id="L2097" href="#L2097">2097</a><a id="L2098" href="#L2098">2098</a><a id="L2099" href="#L2099">2099</a><a id="L2100" href="#L2100">2100</a><a id="L2101" href="#L2101">2101</a><a id="L2102" href="#L2102">2102</a><a id="L2103" href="#L2103">2103</a><a id="L2104" href="#L2104">2104</a><a id="L2105" href="#L2105">2105</a><a id="L2106" href="#L2106">2106</a><a id="L2107" href="#L2107">2107</a><a id="L2108" href="#L2108">2108</a><a id="L2109" href="#L2109">2109</a><a id="L2110" href="#L2110">2110</a><a id="L2111" href="#L2111">2111</a><a id="L2112" href="#L2112">2112</a><a id="L2113" href="#L2113">2113</a><a id="L2114" href="#L2114">2114</a><a id="L2115" href="#L2115">2115</a><a id="L2116" href="#L2116">2116</a><a id="L2117" href="#L2117">2117</a><a id="L2118" href="#L2118">2118</a><a id="L2119" href="#L2119">2119</a><a id="L2120" href="#L2120">2120</a><a id="L2121" href="#L2121">2121</a><a id="L2122" href="#L2122">2122</a><a id="L2123" href="#L2123">2123</a><a id="L2124" href="#L2124">2124</a><a id="L2125" href="#L2125">2125</a><a id="L2126" href="#L2126">2126</a><a id="L2127" href="#L2127">2127</a><a id="L2128" href="#L2128">2128</a><a id="L2129" href="#L2129">2129</a><a id="L2130" href="#L2130">2130</a><a id="L2131" href="#L2131">2131</a><a id="L2132" href="#L2132">2132</a><a id="L2133" href="#L2133">2133</a><a id="L2134" href="#L2134">2134</a><a id="L2135" href="#L2135">2135</a><a id="L2136" href="#L2136">2136</a><a id="L2137" href="#L2137">2137</a><a id="L2138" href="#L2138">2138</a><a id="L2139" href="#L2139">2139</a><a id="L2140" href="#L2140">2140</a><a id="L2141" href="#L2141">2141</a><a id="L2142" href="#L2142">2142</a><a id="L2143" href="#L2143">2143</a><a id="L2144" href="#L2144">2144</a><a id="L2145" href="#L2145">2145</a><a id="L2146" href="#L2146">2146</a><a id="L2147" href="#L2147">2147</a><a id="L2148" href="#L2148">2148</a><a id="L2149" href="#L2149">2149</a><a id="L2150" href="#L2150">2150</a><a id="L2151" href="#L2151">2151</a><a id="L2152" href="#L2152">2152</a><a id="L2153" href="#L2153">2153</a><a id="L2154" href="#L2154">2154</a><a id="L2155" href="#L2155">2155</a><a id="L2156" href="#L2156">2156</a><a id="L2157" href="#L2157">2157</a><a id="L2158" href="#L2158">2158</a><a id="L2159" href="#L2159">2159</a><a id="L2160" href="#L2160">2160</a><a id="L2161" href="#L2161">2161</a><a id="L2162" href="#L2162">2162</a><a id="L2163" href="#L2163">2163</a><a id="L2164" href="#L2164">2164</a><a id="L2165" href="#L2165">2165</a><a id="L2166" href="#L2166">2166</a><a id="L2167" href="#L2167">2167</a><a id="L2168" href="#L2168">2168</a><a id="L2169" href="#L2169">2169</a><a id="L2170" href="#L2170">2170</a><a id="L2171" href="#L2171">2171</a><a id="L2172" href="#L2172">2172</a><a id="L2173" href="#L2173">2173</a><a id="L2174" href="#L2174">2174</a><a id="L2175" href="#L2175">2175</a><a id="L2176" href="#L2176">2176</a><a id="L2177" href="#L2177">2177</a><a id="L2178" href="#L2178">2178</a><a id="L2179" href="#L2179">2179</a><a id="L2180" href="#L2180">2180</a><a id="L2181" href="#L2181">2181</a><a id="L2182" href="#L2182">2182</a><a id="L2183" href="#L2183">2183</a><a id="L2184" href="#L2184">2184</a><a id="L2185" href="#L2185">2185</a><a id="L2186" href="#L2186">2186</a><a id="L2187" href="#L2187">2187</a><a id="L2188" href="#L2188">2188</a><a id="L2189" href="#L2189">2189</a><a id="L2190" href="#L2190">2190</a><a id="L2191" href="#L2191">2191</a><a id="L2192" href="#L2192">2192</a><a id="L2193" href="#L2193">2193</a><a id="L2194" href="#L2194">2194</a><a id="L2195" href="#L2195">2195</a><a id="L2196" href="#L2196">2196</a><a id="L2197" href="#L2197">2197</a><a id="L2198" href="#L2198">2198</a><a id="L2199" href="#L2199">2199</a><a id="L2200" href="#L2200">2200</a><a id="L2201" href="#L2201">2201</a><a id="L2202" href="#L2202">2202</a><a id="L2203" href="#L2203">2203</a><a id="L2204" href="#L2204">2204</a><a id="L2205" href="#L2205">2205</a><a id="L2206" href="#L2206">2206</a><a id="L2207" href="#L2207">2207</a><a id="L2208" href="#L2208">2208</a><a id="L2209" href="#L2209">2209</a><a id="L2210" href="#L2210">2210</a><a id="L2211" href="#L2211">2211</a><a id="L2212" href="#L2212">2212</a><a id="L2213" href="#L2213">2213</a><a id="L2214" href="#L2214">2214</a><a id="L2215" href="#L2215">2215</a><a id="L2216" href="#L2216">2216</a><a id="L2217" href="#L2217">2217</a><a id="L2218" href="#L2218">2218</a><a id="L2219" href="#L2219">2219</a><a id="L2220" href="#L2220">2220</a><a id="L2221" href="#L2221">2221</a><a id="L2222" href="#L2222">2222</a><a id="L2223" href="#L2223">2223</a><a id="L2224" href="#L2224">2224</a><a id="L2225" href="#L2225">2225</a><a id="L2226" href="#L2226">2226</a><a id="L2227" href="#L2227">2227</a><a id="L2228" href="#L2228">2228</a><a id="L2229" href="#L2229">2229</a><a id="L2230" href="#L2230">2230</a><a id="L2231" href="#L2231">2231</a><a id="L2232" href="#L2232">2232</a><a id="L2233" href="#L2233">2233</a><a id="L2234" href="#L2234">2234</a><a id="L2235" href="#L2235">2235</a><a id="L2236" href="#L2236">2236</a><a id="L2237" href="#L2237">2237</a><a id="L2238" href="#L2238">2238</a><a id="L2239" href="#L2239">2239</a><a id="L2240" href="#L2240">2240</a><a id="L2241" href="#L2241">2241</a><a id="L2242" href="#L2242">2242</a><a id="L2243" href="#L2243">2243</a><a id="L2244" href="#L2244">2244</a><a id="L2245" href="#L2245">2245</a><a id="L2246" href="#L2246">2246</a><a id="L2247" href="#L2247">2247</a><a id="L2248" href="#L2248">2248</a><a id="L2249" href="#L2249">2249</a><a id="L2250" href="#L2250">2250</a><a id="L2251" href="#L2251">2251</a><a id="L2252" href="#L2252">2252</a><a id="L2253" href="#L2253">2253</a><a id="L2254" href="#L2254">2254</a><a id="L2255" href="#L2255">2255</a><a id="L2256" href="#L2256">2256</a><a id="L2257" href="#L2257">2257</a><a id="L2258" href="#L2258">2258</a><a id="L2259" href="#L2259">2259</a><a id="L2260" href="#L2260">2260</a><a id="L2261" href="#L2261">2261</a><a id="L2262" href="#L2262">2262</a><a id="L2263" href="#L2263">2263</a><a id="L2264" href="#L2264">2264</a><a id="L2265" href="#L2265">2265</a><a id="L2266" href="#L2266">2266</a><a id="L2267" href="#L2267">2267</a><a id="L2268" href="#L2268">2268</a><a id="L2269" href="#L2269">2269</a><a id="L2270" href="#L2270">2270</a><a id="L2271" href="#L2271">2271</a><a id="L2272" href="#L2272">2272</a><a id="L2273" href="#L2273">2273</a><a id="L2274" href="#L2274">2274</a><a id="L2275" href="#L2275">2275</a><a id="L2276" href="#L2276">2276</a><a id="L2277" href="#L2277">2277</a><a id="L2278" href="#L2278">2278</a><a id="L2279" href="#L2279">2279</a><a id="L2280" href="#L2280">2280</a><a id="L2281" href="#L2281">2281</a><a id="L2282" href="#L2282">2282</a><a id="L2283" href="#L2283">2283</a><a id="L2284" href="#L2284">2284</a><a id="L2285" href="#L2285">2285</a><a id="L2286" href="#L2286">2286</a><a id="L2287" href="#L2287">2287</a><a id="L2288" href="#L2288">2288</a><a id="L2289" href="#L2289">2289</a><a id="L2290" href="#L2290">2290</a><a id="L2291" href="#L2291">2291</a><a id="L2292" href="#L2292">2292</a><a id="L2293" href="#L2293">2293</a><a id="L2294" href="#L2294">2294</a><a id="L2295" href="#L2295">2295</a><a id="L2296" href="#L2296">2296</a><a id="L2297" href="#L2297">2297</a><a id="L2298" href="#L2298">2298</a><a id="L2299" href="#L2299">2299</a><a id="L2300" href="#L2300">2300</a><a id="L2301" href="#L2301">2301</a><a id="L2302" href="#L2302">2302</a><a id="L2303" href="#L2303">2303</a><a id="L2304" href="#L2304">2304</a><a id="L2305" href="#L2305">2305</a><a id="L2306" href="#L2306">2306</a><a id="L2307" href="#L2307">2307</a><a id="L2308" href="#L2308">2308</a><a id="L2309" href="#L2309">2309</a><a id="L2310" href="#L2310">2310</a><a id="L2311" href="#L2311">2311</a><a id="L2312" href="#L2312">2312</a><a id="L2313" href="#L2313">2313</a><a id="L2314" href="#L2314">2314</a><a id="L2315" href="#L2315">2315</a><a id="L2316" href="#L2316">2316</a><a id="L2317" href="#L2317">2317</a><a id="L2318" href="#L2318">2318</a><a id="L2319" href="#L2319">2319</a><a id="L2320" href="#L2320">2320</a><a id="L2321" href="#L2321">2321</a><a id="L2322" href="#L2322">2322</a><a id="L2323" href="#L2323">2323</a><a id="L2324" href="#L2324">2324</a><a id="L2325" href="#L2325">2325</a><a id="L2326" href="#L2326">2326</a><a id="L2327" href="#L2327">2327</a><a id="L2328" href="#L2328">2328</a><a id="L2329" href="#L2329">2329</a><a id="L2330" href="#L2330">2330</a><a id="L2331" href="#L2331">2331</a><a id="L2332" href="#L2332">2332</a><a id="L2333" href="#L2333">2333</a><a id="L2334" href="#L2334">2334</a><a id="L2335" href="#L2335">2335</a><a id="L2336" href="#L2336">2336</a><a id="L2337" href="#L2337">2337</a><a id="L2338" href="#L2338">2338</a><a id="L2339" href="#L2339">2339</a><a id="L2340" href="#L2340">2340</a><a id="L2341" href="#L2341">2341</a><a id="L2342" href="#L2342">2342</a><a id="L2343" href="#L2343">2343</a><a id="L2344" href="#L2344">2344</a><a id="L2345" href="#L2345">2345</a><a id="L2346" href="#L2346">2346</a><a id="L2347" href="#L2347">2347</a><a id="L2348" href="#L2348">2348</a><a id="L2349" href="#L2349">2349</a><a id="L2350" href="#L2350">2350</a><a id="L2351" href="#L2351">2351</a><a id="L2352" href="#L2352">2352</a><a id="L2353" href="#L2353">2353</a><a id="L2354" href="#L2354">2354</a><a id="L2355" href="#L2355">2355</a><a id="L2356" href="#L2356">2356</a><a id="L2357" href="#L2357">2357</a><a id="L2358" href="#L2358">2358</a><a id="L2359" href="#L2359">2359</a><a id="L2360" href="#L2360">2360</a><a id="L2361" href="#L2361">2361</a><a id="L2362" href="#L2362">2362</a><a id="L2363" href="#L2363">2363</a><a id="L2364" href="#L2364">2364</a><a id="L2365" href="#L2365">2365</a><a id="L2366" href="#L2366">2366</a><a id="L2367" href="#L2367">2367</a><a id="L2368" href="#L2368">2368</a><a id="L2369" href="#L2369">2369</a><a id="L2370" href="#L2370">2370</a><a id="L2371" href="#L2371">2371</a><a id="L2372" href="#L2372">2372</a><a id="L2373" href="#L2373">2373</a><a id="L2374" href="#L2374">2374</a><a id="L2375" href="#L2375">2375</a><a id="L2376" href="#L2376">2376</a><a id="L2377" href="#L2377">2377</a><a id="L2378" href="#L2378">2378</a><a id="L2379" href="#L2379">2379</a><a id="L2380" href="#L2380">2380</a><a id="L2381" href="#L2381">2381</a><a id="L2382" href="#L2382">2382</a><a id="L2383" href="#L2383">2383</a><a id="L2384" href="#L2384">2384</a><a id="L2385" href="#L2385">2385</a><a id="L2386" href="#L2386">2386</a><a id="L2387" href="#L2387">2387</a><a id="L2388" href="#L2388">2388</a><a id="L2389" href="#L2389">2389</a><a id="L2390" href="#L2390">2390</a><a id="L2391" href="#L2391">2391</a><a id="L2392" href="#L2392">2392</a><a id="L2393" href="#L2393">2393</a><a id="L2394" href="#L2394">2394</a><a id="L2395" href="#L2395">2395</a><a id="L2396" href="#L2396">2396</a><a id="L2397" href="#L2397">2397</a><a id="L2398" href="#L2398">2398</a><a id="L2399" href="#L2399">2399</a><a id="L2400" href="#L2400">2400</a><a id="L2401" href="#L2401">2401</a><a id="L2402" href="#L2402">2402</a><a id="L2403" href="#L2403">2403</a><a id="L2404" href="#L2404">2404</a><a id="L2405" href="#L2405">2405</a><a id="L2406" href="#L2406">2406</a><a id="L2407" href="#L2407">2407</a><a id="L2408" href="#L2408">2408</a><a id="L2409" href="#L2409">2409</a><a id="L2410" href="#L2410">2410</a><a id="L2411" href="#L2411">2411</a><a id="L2412" href="#L2412">2412</a><a id="L2413" href="#L2413">2413</a><a id="L2414" href="#L2414">2414</a><a id="L2415" href="#L2415">2415</a><a id="L2416" href="#L2416">2416</a><a id="L2417" href="#L2417">2417</a><a id="L2418" href="#L2418">2418</a><a id="L2419" href="#L2419">2419</a><a id="L2420" href="#L2420">2420</a><a id="L2421" href="#L2421">2421</a><a id="L2422" href="#L2422">2422</a><a id="L2423" href="#L2423">2423</a><a id="L2424" href="#L2424">2424</a><a id="L2425" href="#L2425">2425</a><a id="L2426" href="#L2426">2426</a><a id="L2427" href="#L2427">2427</a><a id="L2428" href="#L2428">2428</a><a id="L2429" href="#L2429">2429</a><a id="L2430" href="#L2430">2430</a><a id="L2431" href="#L2431">2431</a><a id="L2432" href="#L2432">2432</a><a id="L2433" href="#L2433">2433</a><a id="L2434" href="#L2434">2434</a><a id="L2435" href="#L2435">2435</a><a id="L2436" href="#L2436">2436</a><a id="L2437" href="#L2437">2437</a><a id="L2438" href="#L2438">2438</a><a id="L2439" href="#L2439">2439</a><a id="L2440" href="#L2440">2440</a><a id="L2441" href="#L2441">2441</a><a id="L2442" href="#L2442">2442</a><a id="L2443" href="#L2443">2443</a><a id="L2444" href="#L2444">2444</a><a id="L2445" href="#L2445">2445</a><a id="L2446" href="#L2446">2446</a><a id="L2447" href="#L2447">2447</a><a id="L2448" href="#L2448">2448</a><a id="L2449" href="#L2449">2449</a><a id="L2450" href="#L2450">2450</a><a id="L2451" href="#L2451">2451</a><a id="L2452" href="#L2452">2452</a><a id="L2453" href="#L2453">2453</a><a id="L2454" href="#L2454">2454</a><a id="L2455" href="#L2455">2455</a><a id="L2456" href="#L2456">2456</a><a id="L2457" href="#L2457">2457</a><a id="L2458" href="#L2458">2458</a><a id="L2459" href="#L2459">2459</a><a id="L2460" href="#L2460">2460</a><a id="L2461" href="#L2461">2461</a><a id="L2462" href="#L2462">2462</a><a id="L2463" href="#L2463">2463</a><a id="L2464" href="#L2464">2464</a><a id="L2465" href="#L2465">2465</a><a id="L2466" href="#L2466">2466</a><a id="L2467" href="#L2467">2467</a><a id="L2468" href="#L2468">2468</a><a id="L2469" href="#L2469">2469</a><a id="L2470" href="#L2470">2470</a><a id="L2471" href="#L2471">2471</a><a id="L2472" href="#L2472">2472</a><a id="L2473" href="#L2473">2473</a><a id="L2474" href="#L2474">2474</a><a id="L2475" href="#L2475">2475</a><a id="L2476" href="#L2476">2476</a><a id="L2477" href="#L2477">2477</a><a id="L2478" href="#L2478">2478</a><a id="L2479" href="#L2479">2479</a><a id="L2480" href="#L2480">2480</a><a id="L2481" href="#L2481">2481</a><a id="L2482" href="#L2482">2482</a><a id="L2483" href="#L2483">2483</a><a id="L2484" href="#L2484">2484</a><a id="L2485" href="#L2485">2485</a><a id="L2486" href="#L2486">2486</a><a id="L2487" href="#L2487">2487</a><a id="L2488" href="#L2488">2488</a><a id="L2489" href="#L2489">2489</a><a id="L2490" href="#L2490">2490</a><a id="L2491" href="#L2491">2491</a><a id="L2492" href="#L2492">2492</a><a id="L2493" href="#L2493">2493</a><a id="L2494" href="#L2494">2494</a><a id="L2495" href="#L2495">2495</a><a id="L2496" href="#L2496">2496</a><a id="L2497" href="#L2497">2497</a><a id="L2498" href="#L2498">2498</a><a id="L2499" href="#L2499">2499</a><a id="L2500" href="#L2500">2500</a><a id="L2501" href="#L2501">2501</a><a id="L2502" href="#L2502">2502</a><a id="L2503" href="#L2503">2503</a><a id="L2504" href="#L2504">2504</a><a id="L2505" href="#L2505">2505</a><a id="L2506" href="#L2506">2506</a><a id="L2507" href="#L2507">2507</a><a id="L2508" href="#L2508">2508</a><a id="L2509" href="#L2509">2509</a><a id="L2510" href="#L2510">2510</a><a id="L2511" href="#L2511">2511</a><a id="L2512" href="#L2512">2512</a><a id="L2513" href="#L2513">2513</a><a id="L2514" href="#L2514">2514</a><a id="L2515" href="#L2515">2515</a><a id="L2516" href="#L2516">2516</a><a id="L2517" href="#L2517">2517</a><a id="L2518" href="#L2518">2518</a><a id="L2519" href="#L2519">2519</a><a id="L2520" href="#L2520">2520</a><a id="L2521" href="#L2521">2521</a><a id="L2522" href="#L2522">2522</a><a id="L2523" href="#L2523">2523</a><a id="L2524" href="#L2524">2524</a><a id="L2525" href="#L2525">2525</a><a id="L2526" href="#L2526">2526</a><a id="L2527" href="#L2527">2527</a><a id="L2528" href="#L2528">2528</a><a id="L2529" href="#L2529">2529</a><a id="L2530" href="#L2530">2530</a><a id="L2531" href="#L2531">2531</a><a id="L2532" href="#L2532">2532</a><a id="L2533" href="#L2533">2533</a><a id="L2534" href="#L2534">2534</a><a id="L2535" href="#L2535">2535</a><a id="L2536" href="#L2536">2536</a><a id="L2537" href="#L2537">2537</a><a id="L2538" href="#L2538">2538</a><a id="L2539" href="#L2539">2539</a><a id="L2540" href="#L2540">2540</a><a id="L2541" href="#L2541">2541</a><a id="L2542" href="#L2542">2542</a><a id="L2543" href="#L2543">2543</a><a id="L2544" href="#L2544">2544</a><a id="L2545" href="#L2545">2545</a><a id="L2546" href="#L2546">2546</a><a id="L2547" href="#L2547">2547</a><a id="L2548" href="#L2548">2548</a><a id="L2549" href="#L2549">2549</a><a id="L2550" href="#L2550">2550</a><a id="L2551" href="#L2551">2551</a><a id="L2552" href="#L2552">2552</a><a id="L2553" href="#L2553">2553</a><a id="L2554" href="#L2554">2554</a><a id="L2555" href="#L2555">2555</a><a id="L2556" href="#L2556">2556</a><a id="L2557" href="#L2557">2557</a><a id="L2558" href="#L2558">2558</a><a id="L2559" href="#L2559">2559</a><a id="L2560" href="#L2560">2560</a><a id="L2561" href="#L2561">2561</a><a id="L2562" href="#L2562">2562</a><a id="L2563" href="#L2563">2563</a><a id="L2564" href="#L2564">2564</a><a id="L2565" href="#L2565">2565</a><a id="L2566" href="#L2566">2566</a><a id="L2567" href="#L2567">2567</a><a id="L2568" href="#L2568">2568</a><a id="L2569" href="#L2569">2569</a><a id="L2570" href="#L2570">2570</a><a id="L2571" href="#L2571">2571</a><a id="L2572" href="#L2572">2572</a><a id="L2573" href="#L2573">2573</a><a id="L2574" href="#L2574">2574</a><a id="L2575" href="#L2575">2575</a><a id="L2576" href="#L2576">2576</a><a id="L2577" href="#L2577">2577</a><a id="L2578" href="#L2578">2578</a><a id="L2579" href="#L2579">2579</a><a id="L2580" href="#L2580">2580</a><a id="L2581" href="#L2581">2581</a><a id="L2582" href="#L2582">2582</a><a id="L2583" href="#L2583">2583</a><a id="L2584" href="#L2584">2584</a><a id="L2585" href="#L2585">2585</a><a id="L2586" href="#L2586">2586</a><a id="L2587" href="#L2587">2587</a><a id="L2588" href="#L2588">2588</a><a id="L2589" href="#L2589">2589</a><a id="L2590" href="#L2590">2590</a><a id="L2591" href="#L2591">2591</a><a id="L2592" href="#L2592">2592</a><a id="L2593" href="#L2593">2593</a><a id="L2594" href="#L2594">2594</a><a id="L2595" href="#L2595">2595</a><a id="L2596" href="#L2596">2596</a><a id="L2597" href="#L2597">2597</a><a id="L2598" href="#L2598">2598</a><a id="L2599" href="#L2599">2599</a><a id="L2600" href="#L2600">2600</a><a id="L2601" href="#L2601">2601</a><a id="L2602" href="#L2602">2602</a><a id="L2603" href="#L2603">2603</a><a id="L2604" href="#L2604">2604</a><a id="L2605" href="#L2605">2605</a><a id="L2606" href="#L2606">2606</a><a id="L2607" href="#L2607">2607</a><a id="L2608" href="#L2608">2608</a><a id="L2609" href="#L2609">2609</a><a id="L2610" href="#L2610">2610</a><a id="L2611" href="#L2611">2611</a><a id="L2612" href="#L2612">2612</a><a id="L2613" href="#L2613">2613</a><a id="L2614" href="#L2614">2614</a><a id="L2615" href="#L2615">2615</a><a id="L2616" href="#L2616">2616</a><a id="L2617" href="#L2617">2617</a><a id="L2618" href="#L2618">2618</a><a id="L2619" href="#L2619">2619</a><a id="L2620" href="#L2620">2620</a><a id="L2621" href="#L2621">2621</a><a id="L2622" href="#L2622">2622</a><a id="L2623" href="#L2623">2623</a><a id="L2624" href="#L2624">2624</a><a id="L2625" href="#L2625">2625</a><a id="L2626" href="#L2626">2626</a><a id="L2627" href="#L2627">2627</a><a id="L2628" href="#L2628">2628</a><a id="L2629" href="#L2629">2629</a><a id="L2630" href="#L2630">2630</a><a id="L2631" href="#L2631">2631</a><a id="L2632" href="#L2632">2632</a><a id="L2633" href="#L2633">2633</a><a id="L2634" href="#L2634">2634</a><a id="L2635" href="#L2635">2635</a><a id="L2636" href="#L2636">2636</a><a id="L2637" href="#L2637">2637</a><a id="L2638" href="#L2638">2638</a><a id="L2639" href="#L2639">2639</a><a id="L2640" href="#L2640">2640</a><a id="L2641" href="#L2641">2641</a><a id="L2642" href="#L2642">2642</a><a id="L2643" href="#L2643">2643</a><a id="L2644" href="#L2644">2644</a><a id="L2645" href="#L2645">2645</a><a id="L2646" href="#L2646">2646</a><a id="L2647" href="#L2647">2647</a><a id="L2648" href="#L2648">2648</a><a id="L2649" href="#L2649">2649</a><a id="L2650" href="#L2650">2650</a><a id="L2651" href="#L2651">2651</a><a id="L2652" href="#L2652">2652</a><a id="L2653" href="#L2653">2653</a><a id="L2654" href="#L2654">2654</a><a id="L2655" href="#L2655">2655</a><a id="L2656" href="#L2656">2656</a><a id="L2657" href="#L2657">2657</a><a id="L2658" href="#L2658">2658</a><a id="L2659" href="#L2659">2659</a><a id="L2660" href="#L2660">2660</a><a id="L2661" href="#L2661">2661</a><a id="L2662" href="#L2662">2662</a><a id="L2663" href="#L2663">2663</a><a id="L2664" href="#L2664">2664</a><a id="L2665" href="#L2665">2665</a><a id="L2666" href="#L2666">2666</a><a id="L2667" href="#L2667">2667</a><a id="L2668" href="#L2668">2668</a><a id="L2669" href="#L2669">2669</a><a id="L2670" href="#L2670">2670</a><a id="L2671" href="#L2671">2671</a><a id="L2672" href="#L2672">2672</a><a id="L2673" href="#L2673">2673</a><a id="L2674" href="#L2674">2674</a><a id="L2675" href="#L2675">2675</a><a id="L2676" href="#L2676">2676</a><a id="L2677" href="#L2677">2677</a><a id="L2678" href="#L2678">2678</a><a id="L2679" href="#L2679">2679</a><a id="L2680" href="#L2680">2680</a><a id="L2681" href="#L2681">2681</a><a id="L2682" href="#L2682">2682</a><a id="L2683" href="#L2683">2683</a><a id="L2684" href="#L2684">2684</a><a id="L2685" href="#L2685">2685</a><a id="L2686" href="#L2686">2686</a><a id="L2687" href="#L2687">2687</a><a id="L2688" href="#L2688">2688</a><a id="L2689" href="#L2689">2689</a><a id="L2690" href="#L2690">2690</a><a id="L2691" href="#L2691">2691</a><a id="L2692" href="#L2692">2692</a><a id="L2693" href="#L2693">2693</a><a id="L2694" href="#L2694">2694</a><a id="L2695" href="#L2695">2695</a><a id="L2696" href="#L2696">2696</a><a id="L2697" href="#L2697">2697</a><a id="L2698" href="#L2698">2698</a><a id="L2699" href="#L2699">2699</a><a id="L2700" href="#L2700">2700</a><a id="L2701" href="#L2701">2701</a><a id="L2702" href="#L2702">2702</a><a id="L2703" href="#L2703">2703</a><a id="L2704" href="#L2704">2704</a><a id="L2705" href="#L2705">2705</a><a id="L2706" href="#L2706">2706</a><a id="L2707" href="#L2707">2707</a><a id="L2708" href="#L2708">2708</a><a id="L2709" href="#L2709">2709</a><a id="L2710" href="#L2710">2710</a><a id="L2711" href="#L2711">2711</a><a id="L2712" href="#L2712">2712</a><a id="L2713" href="#L2713">2713</a><a id="L2714" href="#L2714">2714</a><a id="L2715" href="#L2715">2715</a><a id="L2716" href="#L2716">2716</a><a id="L2717" href="#L2717">2717</a><a id="L2718" href="#L2718">2718</a><a id="L2719" href="#L2719">2719</a><a id="L2720" href="#L2720">2720</a><a id="L2721" href="#L2721">2721</a><a id="L2722" href="#L2722">2722</a><a id="L2723" href="#L2723">2723</a><a id="L2724" href="#L2724">2724</a><a id="L2725" href="#L2725">2725</a><a id="L2726" href="#L2726">2726</a><a id="L2727" href="#L2727">2727</a><a id="L2728" href="#L2728">2728</a><a id="L2729" href="#L2729">2729</a><a id="L2730" href="#L2730">2730</a><a id="L2731" href="#L2731">2731</a><a id="L2732" href="#L2732">2732</a><a id="L2733" href="#L2733">2733</a><a id="L2734" href="#L2734">2734</a><a id="L2735" href="#L2735">2735</a><a id="L2736" href="#L2736">2736</a><a id="L2737" href="#L2737">2737</a><a id="L2738" href="#L2738">2738</a><a id="L2739" href="#L2739">2739</a><a id="L2740" href="#L2740">2740</a><a id="L2741" href="#L2741">2741</a><a id="L2742" href="#L2742">2742</a><a id="L2743" href="#L2743">2743</a><a id="L2744" href="#L2744">2744</a><a id="L2745" href="#L2745">2745</a><a id="L2746" href="#L2746">2746</a><a id="L2747" href="#L2747">2747</a><a id="L2748" href="#L2748">2748</a><a id="L2749" href="#L2749">2749</a><a id="L2750" href="#L2750">2750</a><a id="L2751" href="#L2751">2751</a><a id="L2752" href="#L2752">2752</a><a id="L2753" href="#L2753">2753</a><a id="L2754" href="#L2754">2754</a><a id="L2755" href="#L2755">2755</a><a id="L2756" href="#L2756">2756</a><a id="L2757" href="#L2757">2757</a><a id="L2758" href="#L2758">2758</a><a id="L2759" href="#L2759">2759</a><a id="L2760" href="#L2760">2760</a><a id="L2761" href="#L2761">2761</a><a id="L2762" href="#L2762">2762</a><a id="L2763" href="#L2763">2763</a><a id="L2764" href="#L2764">2764</a><a id="L2765" href="#L2765">2765</a><a id="L2766" href="#L2766">2766</a><a id="L2767" href="#L2767">2767</a><a id="L2768" href="#L2768">2768</a><a id="L2769" href="#L2769">2769</a><a id="L2770" href="#L2770">2770</a><a id="L2771" href="#L2771">2771</a><a id="L2772" href="#L2772">2772</a><a id="L2773" href="#L2773">2773</a><a id="L2774" href="#L2774">2774</a><a id="L2775" href="#L2775">2775</a><a id="L2776" href="#L2776">2776</a><a id="L2777" href="#L2777">2777</a><a id="L2778" href="#L2778">2778</a><a id="L2779" href="#L2779">2779</a><a id="L2780" href="#L2780">2780</a><a id="L2781" href="#L2781">2781</a><a id="L2782" href="#L2782">2782</a><a id="L2783" href="#L2783">2783</a><a id="L2784" href="#L2784">2784</a><a id="L2785" href="#L2785">2785</a><a id="L2786" href="#L2786">2786</a><a id="L2787" href="#L2787">2787</a><a id="L2788" href="#L2788">2788</a><a id="L2789" href="#L2789">2789</a><a id="L2790" href="#L2790">2790</a><a id="L2791" href="#L2791">2791</a><a id="L2792" href="#L2792">2792</a><a id="L2793" href="#L2793">2793</a><a id="L2794" href="#L2794">2794</a><a id="L2795" href="#L2795">2795</a><a id="L2796" href="#L2796">2796</a><a id="L2797" href="#L2797">2797</a><a id="L2798" href="#L2798">2798</a><a id="L2799" href="#L2799">2799</a><a id="L2800" href="#L2800">2800</a><a id="L2801" href="#L2801">2801</a><a id="L2802" href="#L2802">2802</a><a id="L2803" href="#L2803">2803</a><a id="L2804" href="#L2804">2804</a><a id="L2805" href="#L2805">2805</a><a id="L2806" href="#L2806">2806</a><a id="L2807" href="#L2807">2807</a><a id="L2808" href="#L2808">2808</a><a id="L2809" href="#L2809">2809</a><a id="L2810" href="#L2810">2810</a><a id="L2811" href="#L2811">2811</a><a id="L2812" href="#L2812">2812</a><a id="L2813" href="#L2813">2813</a><a id="L2814" href="#L2814">2814</a><a id="L2815" href="#L2815">2815</a><a id="L2816" href="#L2816">2816</a><a id="L2817" href="#L2817">2817</a><a id="L2818" href="#L2818">2818</a><a id="L2819" href="#L2819">2819</a><a id="L2820" href="#L2820">2820</a><a id="L2821" href="#L2821">2821</a><a id="L2822" href="#L2822">2822</a><a id="L2823" href="#L2823">2823</a><a id="L2824" href="#L2824">2824</a><a id="L2825" href="#L2825">2825</a><a id="L2826" href="#L2826">2826</a><a id="L2827" href="#L2827">2827</a><a id="L2828" href="#L2828">2828</a><a id="L2829" href="#L2829">2829</a><a id="L2830" href="#L2830">2830</a><a id="L2831" href="#L2831">2831</a><a id="L2832" href="#L2832">2832</a><a id="L2833" href="#L2833">2833</a><a id="L2834" href="#L2834">2834</a><a id="L2835" href="#L2835">2835</a><a id="L2836" href="#L2836">2836</a><a id="L2837" href="#L2837">2837</a><a id="L2838" href="#L2838">2838</a><a id="L2839" href="#L2839">2839</a><a id="L2840" href="#L2840">2840</a><a id="L2841" href="#L2841">2841</a><a id="L2842" href="#L2842">2842</a><a id="L2843" href="#L2843">2843</a><a id="L2844" href="#L2844">2844</a><a id="L2845" href="#L2845">2845</a><a id="L2846" href="#L2846">2846</a><a id="L2847" href="#L2847">2847</a><a id="L2848" href="#L2848">2848</a><a id="L2849" href="#L2849">2849</a><a id="L2850" href="#L2850">2850</a><a id="L2851" href="#L2851">2851</a><a id="L2852" href="#L2852">2852</a><a id="L2853" href="#L2853">2853</a><a id="L2854" href="#L2854">2854</a><a id="L2855" href="#L2855">2855</a><a id="L2856" href="#L2856">2856</a><a id="L2857" href="#L2857">2857</a><a id="L2858" href="#L2858">2858</a><a id="L2859" href="#L2859">2859</a><a id="L2860" href="#L2860">2860</a><a id="L2861" href="#L2861">2861</a><a id="L2862" href="#L2862">2862</a><a id="L2863" href="#L2863">2863</a><a id="L2864" href="#L2864">2864</a><a id="L2865" href="#L2865">2865</a><a id="L2866" href="#L2866">2866</a><a id="L2867" href="#L2867">2867</a><a id="L2868" href="#L2868">2868</a><a id="L2869" href="#L2869">2869</a><a id="L2870" href="#L2870">2870</a><a id="L2871" href="#L2871">2871</a><a id="L2872" href="#L2872">2872</a><a id="L2873" href="#L2873">2873</a><a id="L2874" href="#L2874">2874</a><a id="L2875" href="#L2875">2875</a><a id="L2876" href="#L2876">2876</a><a id="L2877" href="#L2877">2877</a><a id="L2878" href="#L2878">2878</a><a id="L2879" href="#L2879">2879</a><a id="L2880" href="#L2880">2880</a><a id="L2881" href="#L2881">2881</a><a id="L2882" href="#L2882">2882</a><a id="L2883" href="#L2883">2883</a><a id="L2884" href="#L2884">2884</a><a id="L2885" href="#L2885">2885</a><a id="L2886" href="#L2886">2886</a><a id="L2887" href="#L2887">2887</a><a id="L2888" href="#L2888">2888</a><a id="L2889" href="#L2889">2889</a><a id="L2890" href="#L2890">2890</a><a id="L2891" href="#L2891">2891</a><a id="L2892" href="#L2892">2892</a><a id="L2893" href="#L2893">2893</a><a id="L2894" href="#L2894">2894</a><a id="L2895" href="#L2895">2895</a><a id="L2896" href="#L2896">2896</a><a id="L2897" href="#L2897">2897</a><a id="L2898" href="#L2898">2898</a><a id="L2899" href="#L2899">2899</a><a id="L2900" href="#L2900">2900</a><a id="L2901" href="#L2901">2901</a><a id="L2902" href="#L2902">2902</a><a id="L2903" href="#L2903">2903</a><a id="L2904" href="#L2904">2904</a><a id="L2905" href="#L2905">2905</a><a id="L2906" href="#L2906">2906</a><a id="L2907" href="#L2907">2907</a><a id="L2908" href="#L2908">2908</a><a id="L2909" href="#L2909">2909</a><a id="L2910" href="#L2910">2910</a><a id="L2911" href="#L2911">2911</a><a id="L2912" href="#L2912">2912</a><a id="L2913" href="#L2913">2913</a><a id="L2914" href="#L2914">2914</a><a id="L2915" href="#L2915">2915</a><a id="L2916" href="#L2916">2916</a><a id="L2917" href="#L2917">2917</a><a id="L2918" href="#L2918">2918</a><a id="L2919" href="#L2919">2919</a><a id="L2920" href="#L2920">2920</a><a id="L2921" href="#L2921">2921</a><a id="L2922" href="#L2922">2922</a><a id="L2923" href="#L2923">2923</a><a id="L2924" href="#L2924">2924</a><a id="L2925" href="#L2925">2925</a><a id="L2926" href="#L2926">2926</a><a id="L2927" href="#L2927">2927</a><a id="L2928" href="#L2928">2928</a><a id="L2929" href="#L2929">2929</a><a id="L2930" href="#L2930">2930</a><a id="L2931" href="#L2931">2931</a><a id="L2932" href="#L2932">2932</a><a id="L2933" href="#L2933">2933</a><a id="L2934" href="#L2934">2934</a><a id="L2935" href="#L2935">2935</a><a id="L2936" href="#L2936">2936</a><a id="L2937" href="#L2937">2937</a><a id="L2938" href="#L2938">2938</a><a id="L2939" href="#L2939">2939</a><a id="L2940" href="#L2940">2940</a><a id="L2941" href="#L2941">2941</a><a id="L2942" href="#L2942">2942</a><a id="L2943" href="#L2943">2943</a><a id="L2944" href="#L2944">2944</a><a id="L2945" href="#L2945">2945</a><a id="L2946" href="#L2946">2946</a><a id="L2947" href="#L2947">2947</a><a id="L2948" href="#L2948">2948</a><a id="L2949" href="#L2949">2949</a><a id="L2950" href="#L2950">2950</a><a id="L2951" href="#L2951">2951</a><a id="L2952" href="#L2952">2952</a><a id="L2953" href="#L2953">2953</a><a id="L2954" href="#L2954">2954</a><a id="L2955" href="#L2955">2955</a><a id="L2956" href="#L2956">2956</a><a id="L2957" href="#L2957">2957</a><a id="L2958" href="#L2958">2958</a><a id="L2959" href="#L2959">2959</a><a id="L2960" href="#L2960">2960</a><a id="L2961" href="#L2961">2961</a><a id="L2962" href="#L2962">2962</a><a id="L2963" href="#L2963">2963</a><a id="L2964" href="#L2964">2964</a><a id="L2965" href="#L2965">2965</a><a id="L2966" href="#L2966">2966</a><a id="L2967" href="#L2967">2967</a><a id="L2968" href="#L2968">2968</a><a id="L2969" href="#L2969">2969</a><a id="L2970" href="#L2970">2970</a><a id="L2971" href="#L2971">2971</a><a id="L2972" href="#L2972">2972</a><a id="L2973" href="#L2973">2973</a><a id="L2974" href="#L2974">2974</a><a id="L2975" href="#L2975">2975</a><a id="L2976" href="#L2976">2976</a><a id="L2977" href="#L2977">2977</a><a id="L2978" href="#L2978">2978</a><a id="L2979" href="#L2979">2979</a><a id="L2980" href="#L2980">2980</a><a id="L2981" href="#L2981">2981</a><a id="L2982" href="#L2982">2982</a><a id="L2983" href="#L2983">2983</a><a id="L2984" href="#L2984">2984</a><a id="L2985" href="#L2985">2985</a><a id="L2986" href="#L2986">2986</a><a id="L2987" href="#L2987">2987</a><a id="L2988" href="#L2988">2988</a><a id="L2989" href="#L2989">2989</a><a id="L2990" href="#L2990">2990</a><a id="L2991" href="#L2991">2991</a><a id="L2992" href="#L2992">2992</a><a id="L2993" href="#L2993">2993</a><a id="L2994" href="#L2994">2994</a><a id="L2995" href="#L2995">2995</a><a id="L2996" href="#L2996">2996</a><a id="L2997" href="#L2997">2997</a><a id="L2998" href="#L2998">2998</a><a id="L2999" href="#L2999">2999</a><a id="L3000" href="#L3000">3000</a><a id="L3001" href="#L3001">3001</a><a id="L3002" href="#L3002">3002</a><a id="L3003" href="#L3003">3003</a><a id="L3004" href="#L3004">3004</a><a id="L3005" href="#L3005">3005</a><a id="L3006" href="#L3006">3006</a><a id="L3007" href="#L3007">3007</a><a id="L3008" href="#L3008">3008</a><a id="L3009" href="#L3009">3009</a><a id="L3010" href="#L3010">3010</a><a id="L3011" href="#L3011">3011</a><a id="L3012" href="#L3012">3012</a><a id="L3013" href="#L3013">3013</a><a id="L3014" href="#L3014">3014</a><a id="L3015" href="#L3015">3015</a><a id="L3016" href="#L3016">3016</a><a id="L3017" href="#L3017">3017</a><a id="L3018" href="#L3018">3018</a><a id="L3019" href="#L3019">3019</a><a id="L3020" href="#L3020">3020</a><a id="L3021" href="#L3021">3021</a><a id="L3022" href="#L3022">3022</a><a id="L3023" href="#L3023">3023</a><a id="L3024" href="#L3024">3024</a><a id="L3025" href="#L3025">3025</a><a id="L3026" href="#L3026">3026</a><a id="L3027" href="#L3027">3027</a><a id="L3028" href="#L3028">3028</a><a id="L3029" href="#L3029">3029</a><a id="L3030" href="#L3030">3030</a><a id="L3031" href="#L3031">3031</a><a id="L3032" href="#L3032">3032</a><a id="L3033" href="#L3033">3033</a><a id="L3034" href="#L3034">3034</a><a id="L3035" href="#L3035">3035</a><a id="L3036" href="#L3036">3036</a><a id="L3037" href="#L3037">3037</a><a id="L3038" href="#L3038">3038</a><a id="L3039" href="#L3039">3039</a><a id="L3040" href="#L3040">3040</a><a id="L3041" href="#L3041">3041</a><a id="L3042" href="#L3042">3042</a><a id="L3043" href="#L3043">3043</a><a id="L3044" href="#L3044">3044</a><a id="L3045" href="#L3045">3045</a><a id="L3046" href="#L3046">3046</a><a id="L3047" href="#L3047">3047</a><a id="L3048" href="#L3048">3048</a><a id="L3049" href="#L3049">3049</a><a id="L3050" href="#L3050">3050</a><a id="L3051" href="#L3051">3051</a><a id="L3052" href="#L3052">3052</a><a id="L3053" href="#L3053">3053</a><a id="L3054" href="#L3054">3054</a><a id="L3055" href="#L3055">3055</a><a id="L3056" href="#L3056">3056</a><a id="L3057" href="#L3057">3057</a><a id="L3058" href="#L3058">3058</a><a id="L3059" href="#L3059">3059</a><a id="L3060" href="#L3060">3060</a><a id="L3061" href="#L3061">3061</a><a id="L3062" href="#L3062">3062</a><a id="L3063" href="#L3063">3063</a><a id="L3064" href="#L3064">3064</a><a id="L3065" href="#L3065">3065</a><a id="L3066" href="#L3066">3066</a><a id="L3067" href="#L3067">3067</a><a id="L3068" href="#L3068">3068</a><a id="L3069" href="#L3069">3069</a><a id="L3070" href="#L3070">3070</a><a id="L3071" href="#L3071">3071</a><a id="L3072" href="#L3072">3072</a><a id="L3073" href="#L3073">3073</a><a id="L3074" href="#L3074">3074</a><a id="L3075" href="#L3075">3075</a><a id="L3076" href="#L3076">3076</a><a id="L3077" href="#L3077">3077</a><a id="L3078" href="#L3078">3078</a><a id="L3079" href="#L3079">3079</a><a id="L3080" href="#L3080">3080</a><a id="L3081" href="#L3081">3081</a><a id="L3082" href="#L3082">3082</a><a id="L3083" href="#L3083">3083</a><a id="L3084" href="#L3084">3084</a><a id="L3085" href="#L3085">3085</a><a id="L3086" href="#L3086">3086</a><a id="L3087" href="#L3087">3087</a><a id="L3088" href="#L3088">3088</a><a id="L3089" href="#L3089">3089</a><a id="L3090" href="#L3090">3090</a><a id="L3091" href="#L3091">3091</a><a id="L3092" href="#L3092">3092</a><a id="L3093" href="#L3093">3093</a><a id="L3094" href="#L3094">3094</a><a id="L3095" href="#L3095">3095</a><a id="L3096" href="#L3096">3096</a><a id="L3097" href="#L3097">3097</a><a id="L3098" href="#L3098">3098</a><a id="L3099" href="#L3099">3099</a><a id="L3100" href="#L3100">3100</a><a id="L3101" href="#L3101">3101</a><a id="L3102" href="#L3102">3102</a><a id="L3103" href="#L3103">3103</a><a id="L3104" href="#L3104">3104</a><a id="L3105" href="#L3105">3105</a><a id="L3106" href="#L3106">3106</a><a id="L3107" href="#L3107">3107</a><a id="L3108" href="#L3108">3108</a><a id="L3109" href="#L3109">3109</a><a id="L3110" href="#L3110">3110</a><a id="L3111" href="#L3111">3111</a><a id="L3112" href="#L3112">3112</a><a id="L3113" href="#L3113">3113</a><a id="L3114" href="#L3114">3114</a><a id="L3115" href="#L3115">3115</a><a id="L3116" href="#L3116">3116</a><a id="L3117" href="#L3117">3117</a><a id="L3118" href="#L3118">3118</a><a id="L3119" href="#L3119">3119</a><a id="L3120" href="#L3120">3120</a><a id="L3121" href="#L3121">3121</a><a id="L3122" href="#L3122">3122</a><a id="L3123" href="#L3123">3123</a><a id="L3124" href="#L3124">3124</a><a id="L3125" href="#L3125">3125</a><a id="L3126" href="#L3126">3126</a><a id="L3127" href="#L3127">3127</a><a id="L3128" href="#L3128">3128</a><a id="L3129" href="#L3129">3129</a><a id="L3130" href="#L3130">3130</a><a id="L3131" href="#L3131">3131</a><a id="L3132" href="#L3132">3132</a><a id="L3133" href="#L3133">3133</a><a id="L3134" href="#L3134">3134</a><a id="L3135" href="#L3135">3135</a><a id="L3136" href="#L3136">3136</a><a id="L3137" href="#L3137">3137</a><a id="L3138" href="#L3138">3138</a><a id="L3139" href="#L3139">3139</a><a id="L3140" href="#L3140">3140</a><a id="L3141" href="#L3141">3141</a><a id="L3142" href="#L3142">3142</a><a id="L3143" href="#L3143">3143</a><a id="L3144" href="#L3144">3144</a><a id="L3145" href="#L3145">3145</a><a id="L3146" href="#L3146">3146</a><a id="L3147" href="#L3147">3147</a><a id="L3148" href="#L3148">3148</a><a id="L3149" href="#L3149">3149</a><a id="L3150" href="#L3150">3150</a><a id="L3151" href="#L3151">3151</a><a id="L3152" href="#L3152">3152</a><a id="L3153" href="#L3153">3153</a><a id="L3154" href="#L3154">3154</a><a id="L3155" href="#L3155">3155</a><a id="L3156" href="#L3156">3156</a><a id="L3157" href="#L3157">3157</a><a id="L3158" href="#L3158">3158</a><a id="L3159" href="#L3159">3159</a><a id="L3160" href="#L3160">3160</a><a id="L3161" href="#L3161">3161</a><a id="L3162" href="#L3162">3162</a><a id="L3163" href="#L3163">3163</a><a id="L3164" href="#L3164">3164</a><a id="L3165" href="#L3165">3165</a><a id="L3166" href="#L3166">3166</a><a id="L3167" href="#L3167">3167</a><a id="L3168" href="#L3168">3168</a><a id="L3169" href="#L3169">3169</a><a id="L3170" href="#L3170">3170</a><a id="L3171" href="#L3171">3171</a><a id="L3172" href="#L3172">3172</a><a id="L3173" href="#L3173">3173</a><a id="L3174" href="#L3174">3174</a><a id="L3175" href="#L3175">3175</a><a id="L3176" href="#L3176">3176</a><a id="L3177" href="#L3177">3177</a><a id="L3178" href="#L3178">3178</a><a id="L3179" href="#L3179">3179</a><a id="L3180" href="#L3180">3180</a><a id="L3181" href="#L3181">3181</a><a id="L3182" href="#L3182">3182</a><a id="L3183" href="#L3183">3183</a><a id="L3184" href="#L3184">3184</a><a id="L3185" href="#L3185">3185</a><a id="L3186" href="#L3186">3186</a><a id="L3187" href="#L3187">3187</a><a id="L3188" href="#L3188">3188</a><a id="L3189" href="#L3189">3189</a><a id="L3190" href="#L3190">3190</a><a id="L3191" href="#L3191">3191</a><a id="L3192" href="#L3192">3192</a><a id="L3193" href="#L3193">3193</a><a id="L3194" href="#L3194">3194</a><a id="L3195" href="#L3195">3195</a><a id="L3196" href="#L3196">3196</a><a id="L3197" href="#L3197">3197</a><a id="L3198" href="#L3198">3198</a><a id="L3199" href="#L3199">3199</a><a id="L3200" href="#L3200">3200</a><a id="L3201" href="#L3201">3201</a><a id="L3202" href="#L3202">3202</a><a id="L3203" href="#L3203">3203</a><a id="L3204" href="#L3204">3204</a><a id="L3205" href="#L3205">3205</a><a id="L3206" href="#L3206">3206</a><a id="L3207" href="#L3207">3207</a><a id="L3208" href="#L3208">3208</a><a id="L3209" href="#L3209">3209</a><a id="L3210" href="#L3210">3210</a><a id="L3211" href="#L3211">3211</a><a id="L3212" href="#L3212">3212</a><a id="L3213" href="#L3213">3213</a><a id="L3214" href="#L3214">3214</a><a id="L3215" href="#L3215">3215</a><a id="L3216" href="#L3216">3216</a><a id="L3217" href="#L3217">3217</a><a id="L3218" href="#L3218">3218</a><a id="L3219" href="#L3219">3219</a><a id="L3220" href="#L3220">3220</a><a id="L3221" href="#L3221">3221</a><a id="L3222" href="#L3222">3222</a><a id="L3223" href="#L3223">3223</a><a id="L3224" href="#L3224">3224</a><a id="L3225" href="#L3225">3225</a><a id="L3226" href="#L3226">3226</a><a id="L3227" href="#L3227">3227</a><a id="L3228" href="#L3228">3228</a><a id="L3229" href="#L3229">3229</a><a id="L3230" href="#L3230">3230</a><a id="L3231" href="#L3231">3231</a><a id="L3232" href="#L3232">3232</a><a id="L3233" href="#L3233">3233</a><a id="L3234" href="#L3234">3234</a><a id="L3235" href="#L3235">3235</a><a id="L3236" href="#L3236">3236</a><a id="L3237" href="#L3237">3237</a><a id="L3238" href="#L3238">3238</a><a id="L3239" href="#L3239">3239</a><a id="L3240" href="#L3240">3240</a><a id="L3241" href="#L3241">3241</a><a id="L3242" href="#L3242">3242</a><a id="L3243" href="#L3243">3243</a><a id="L3244" href="#L3244">3244</a><a id="L3245" href="#L3245">3245</a><a id="L3246" href="#L3246">3246</a><a id="L3247" href="#L3247">3247</a><a id="L3248" href="#L3248">3248</a><a id="L3249" href="#L3249">3249</a><a id="L3250" href="#L3250">3250</a><a id="L3251" href="#L3251">3251</a><a id="L3252" href="#L3252">3252</a><a id="L3253" href="#L3253">3253</a><a id="L3254" href="#L3254">3254</a><a id="L3255" href="#L3255">3255</a><a id="L3256" href="#L3256">3256</a><a id="L3257" href="#L3257">3257</a><a id="L3258" href="#L3258">3258</a><a id="L3259" href="#L3259">3259</a><a id="L3260" href="#L3260">3260</a><a id="L3261" href="#L3261">3261</a><a id="L3262" href="#L3262">3262</a><a id="L3263" href="#L3263">3263</a><a id="L3264" href="#L3264">3264</a><a id="L3265" href="#L3265">3265</a><a id="L3266" href="#L3266">3266</a><a id="L3267" href="#L3267">3267</a><a id="L3268" href="#L3268">3268</a><a id="L3269" href="#L3269">3269</a><a id="L3270" href="#L3270">3270</a><a id="L3271" href="#L3271">3271</a><a id="L3272" href="#L3272">3272</a><a id="L3273" href="#L3273">3273</a><a id="L3274" href="#L3274">3274</a><a id="L3275" href="#L3275">3275</a><a id="L3276" href="#L3276">3276</a><a id="L3277" href="#L3277">3277</a><a id="L3278" href="#L3278">3278</a><a id="L3279" href="#L3279">3279</a><a id="L3280" href="#L3280">3280</a><a id="L3281" href="#L3281">3281</a><a id="L3282" href="#L3282">3282</a><a id="L3283" href="#L3283">3283</a><a id="L3284" href="#L3284">3284</a><a id="L3285" href="#L3285">3285</a><a id="L3286" href="#L3286">3286</a><a id="L3287" href="#L3287">3287</a><a id="L3288" href="#L3288">3288</a><a id="L3289" href="#L3289">3289</a><a id="L3290" href="#L3290">3290</a><a id="L3291" href="#L3291">3291</a><a id="L3292" href="#L3292">3292</a><a id="L3293" href="#L3293">3293</a><a id="L3294" href="#L3294">3294</a><a id="L3295" href="#L3295">3295</a><a id="L3296" href="#L3296">3296</a><a id="L3297" href="#L3297">3297</a><a id="L3298" href="#L3298">3298</a><a id="L3299" href="#L3299">3299</a><a id="L3300" href="#L3300">3300</a><a id="L3301" href="#L3301">3301</a><a id="L3302" href="#L3302">3302</a><a id="L3303" href="#L3303">3303</a><a id="L3304" href="#L3304">3304</a><a id="L3305" href="#L3305">3305</a><a id="L3306" href="#L3306">3306</a><a id="L3307" href="#L3307">3307</a><a id="L3308" href="#L3308">3308</a><a id="L3309" href="#L3309">3309</a><a id="L3310" href="#L3310">3310</a><a id="L3311" href="#L3311">3311</a><a id="L3312" href="#L3312">3312</a><a id="L3313" href="#L3313">3313</a><a id="L3314" href="#L3314">3314</a><a id="L3315" href="#L3315">3315</a><a id="L3316" href="#L3316">3316</a><a id="L3317" href="#L3317">3317</a><a id="L3318" href="#L3318">3318</a><a id="L3319" href="#L3319">3319</a><a id="L3320" href="#L3320">3320</a><a id="L3321" href="#L3321">3321</a><a id="L3322" href="#L3322">3322</a><a id="L3323" href="#L3323">3323</a><a id="L3324" href="#L3324">3324</a><a id="L3325" href="#L3325">3325</a><a id="L3326" href="#L3326">3326</a><a id="L3327" href="#L3327">3327</a><a id="L3328" href="#L3328">3328</a><a id="L3329" href="#L3329">3329</a><a id="L3330" href="#L3330">3330</a><a id="L3331" href="#L3331">3331</a><a id="L3332" href="#L3332">3332</a><a id="L3333" href="#L3333">3333</a><a id="L3334" href="#L3334">3334</a><a id="L3335" href="#L3335">3335</a><a id="L3336" href="#L3336">3336</a><a id="L3337" href="#L3337">3337</a><a id="L3338" href="#L3338">3338</a><a id="L3339" href="#L3339">3339</a><a id="L3340" href="#L3340">3340</a><a id="L3341" href="#L3341">3341</a><a id="L3342" href="#L3342">3342</a><a id="L3343" href="#L3343">3343</a><a id="L3344" href="#L3344">3344</a><a id="L3345" href="#L3345">3345</a><a id="L3346" href="#L3346">3346</a><a id="L3347" href="#L3347">3347</a><a id="L3348" href="#L3348">3348</a><a id="L3349" href="#L3349">3349</a><a id="L3350" href="#L3350">3350</a><a id="L3351" href="#L3351">3351</a><a id="L3352" href="#L3352">3352</a><a id="L3353" href="#L3353">3353</a><a id="L3354" href="#L3354">3354</a><a id="L3355" href="#L3355">3355</a><a id="L3356" href="#L3356">3356</a><a id="L3357" href="#L3357">3357</a><a id="L3358" href="#L3358">3358</a><a id="L3359" href="#L3359">3359</a><a id="L3360" href="#L3360">3360</a><a id="L3361" href="#L3361">3361</a><a id="L3362" href="#L3362">3362</a><a id="L3363" href="#L3363">3363</a><a id="L3364" href="#L3364">3364</a><a id="L3365" href="#L3365">3365</a><a id="L3366" href="#L3366">3366</a><a id="L3367" href="#L3367">3367</a><a id="L3368" href="#L3368">3368</a><a id="L3369" href="#L3369">3369</a><a id="L3370" href="#L3370">3370</a><a id="L3371" href="#L3371">3371</a><a id="L3372" href="#L3372">3372</a><a id="L3373" href="#L3373">3373</a><a id="L3374" href="#L3374">3374</a><a id="L3375" href="#L3375">3375</a><a id="L3376" href="#L3376">3376</a><a id="L3377" href="#L3377">3377</a><a id="L3378" href="#L3378">3378</a><a id="L3379" href="#L3379">3379</a><a id="L3380" href="#L3380">3380</a><a id="L3381" href="#L3381">3381</a><a id="L3382" href="#L3382">3382</a><a id="L3383" href="#L3383">3383</a><a id="L3384" href="#L3384">3384</a><a id="L3385" href="#L3385">3385</a><a id="L3386" href="#L3386">3386</a><a id="L3387" href="#L3387">3387</a><a id="L3388" href="#L3388">3388</a><a id="L3389" href="#L3389">3389</a><a id="L3390" href="#L3390">3390</a><a id="L3391" href="#L3391">3391</a><a id="L3392" href="#L3392">3392</a><a id="L3393" href="#L3393">3393</a><a id="L3394" href="#L3394">3394</a><a id="L3395" href="#L3395">3395</a><a id="L3396" href="#L3396">3396</a><a id="L3397" href="#L3397">3397</a><a id="L3398" href="#L3398">3398</a><a id="L3399" href="#L3399">3399</a><a id="L3400" href="#L3400">3400</a><a id="L3401" href="#L3401">3401</a><a id="L3402" href="#L3402">3402</a><a id="L3403" href="#L3403">3403</a><a id="L3404" href="#L3404">3404</a><a id="L3405" href="#L3405">3405</a><a id="L3406" href="#L3406">3406</a><a id="L3407" href="#L3407">3407</a><a id="L3408" href="#L3408">3408</a><a id="L3409" href="#L3409">3409</a><a id="L3410" href="#L3410">3410</a><a id="L3411" href="#L3411">3411</a><a id="L3412" href="#L3412">3412</a><a id="L3413" href="#L3413">3413</a><a id="L3414" href="#L3414">3414</a><a id="L3415" href="#L3415">3415</a><a id="L3416" href="#L3416">3416</a><a id="L3417" href="#L3417">3417</a><a id="L3418" href="#L3418">3418</a><a id="L3419" href="#L3419">3419</a><a id="L3420" href="#L3420">3420</a><a id="L3421" href="#L3421">3421</a><a id="L3422" href="#L3422">3422</a><a id="L3423" href="#L3423">3423</a><a id="L3424" href="#L3424">3424</a><a id="L3425" href="#L3425">3425</a><a id="L3426" href="#L3426">3426</a><a id="L3427" href="#L3427">3427</a><a id="L3428" href="#L3428">3428</a><a id="L3429" href="#L3429">3429</a><a id="L3430" href="#L3430">3430</a><a id="L3431" href="#L3431">3431</a><a id="L3432" href="#L3432">3432</a></td>
<td><td><pre class="sourcecode">
<span class="lc">// Written in the D programming language.</span>

<span class="bc">/**
Implements algorithms oriented mainly towards processing of
sequences. Some functions are semantic equivalents or supersets of
those found in the $(D algorithm) header in $(WEB sgi.com/tech/stl/,
Alexander Stepanov's Standard Template Library) for C++.

Author:
$(WEB erdani.org, Andrei Alexandrescu)

Note:

Many functions in this module are parameterized with a function or a
$(GLOSSARY predicate). The predicate may be passed either as a
function name, a delegate name, a $(GLOSSARY functor) name, or a
compile-time string. The string may consist of $(B any) legal D
expression that uses the symbol $(D a) (for unary functions) or the
symbols $(D a) and $(D b) (for binary functions). These names will NOT
interfere with other homonym symbols in user code because they are
evaluated in a different context. The default for all binary
comparison predicates is $(D "a == b") for unordered operations and
$(D "a &lt; b") for ordered operations.

Example:

----
int[] a = ...;
static bool greater(int a, int b)
{
    return a &gt; b;
}
sort!(greater)(a);  // predicate as alias
sort!("a &gt; b")(a);  // predicate as string
                    // (no ambiguity with array name)
sort(a);            // no predicate, "a &lt; b" is implicit
----

Some functions are additionally parameterized with primitives such as
$(D move) (defaulting to $(XREF _algorithm,move)) or $(D iterSwap)
primitive (defaulting to $(XREF _algorithm,iterSwap)). These
parameters distill the way in which data is manipulated, and the
algorithms guarantee they only use them to touch values. There is
sometimes a need to override that default behavior. Possible uses
include notifying observers, counting the number of operations, or
manipulating multiple collections in lockstep.

Macros:
WIKI = Phobos/StdAlgorithm
*/</span>

<span class="bc">/*
 *  Copyright (C) 2004-2006 by Digital Mars, www.digitalmars.com
 *  Written by Andrei Alexandrescu, www.erdani.org
 *
 *  This software is provided 'as-is', without any express or implied
 *  warranty. In no event will the authors be held liable for any damages
 *  arising from the use of this software.
 *
 *  Permission is granted to anyone to use this software for any purpose,
 *  including commercial applications, and to alter it and redistribute it
 *  freely, subject to the following restrictions:
 *
 *  o  The origin of this software must not be misrepresented; you must not
 *     claim that you wrote the original software. If you use this software
 *     in a product, an acknowledgment in the product documentation would be
 *     appreciated but is not required.
 *  o  Altered source versions must be plainly marked as such, and must not
 *     be misrepresented as being the original software.
 *  o  This notice may not be removed or altered from any source
 *     distribution.
 */</span>

<span class="d Compound"><span class="d Module"><span class="k">module</span> <span class="i">std</span>.<span class="i">algorithm</span>;</span>
<span class="d Protection"><span class="k">private</span> <span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">math</span>;</span></span>
<span class="d Protection"><span class="k">private</span> <span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">date</span>;</span></span>
<span class="d Protection"><span class="k">private</span> <span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">functional</span>;</span></span>
<span class="d Protection"><span class="k">private</span> <span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">iterator</span>;</span></span>
<span class="d Protection"><span class="k">private</span> <span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">conv</span>;</span></span>
<span class="d Protection"><span class="k">private</span> <span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">typecons</span>;</span></span>
<span class="d Protection"><span class="k">private</span> <span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">typetuple</span>;</span></span>
<span class="d Protection"><span class="k">private</span> <span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">metastrings</span>;</span></span>
<span class="d Protection"><span class="k">private</span> <span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">contracts</span>;</span></span>
<span class="d Protection"><span class="k">private</span> <span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">traits</span>;</span></span>
<span class="d Protection"><span class="k">private</span> <span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">c</span>.<span class="i">string</span>;</span></span>

<span class="d Version"><span class="k">version</span>(<span class="k">unittest</span>)
<span class="d Compound">{
    <span class="d Protection"><span class="k">private</span> <span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">stdio</span>;</span></span>
    <span class="d Protection"><span class="k">private</span> <span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">random</span>;</span></span>
    <span class="d Import"><span class="k">import</span> <span class="i">std</span>.<span class="i">string</span>;</span>
}</span></span>

<span class="bc">/**
Implements the homonym function (also known as $(D transform)) present
in many languages of functional flavor. The call $(D map!(fun)(range1,
range2, ..., rangeN)) returns a new range of which elements are
obtained by applying $(D fun(x)) left to right for all $(D x) in $(D
range1), then all $(D x) in $(D range2), ..., all $(D x) in $(D
rangeN). The original ranges are not changed.

Example:
----
int[] arr1 = [ 1, 2, 3, 4 ];
int[] arr2 = [ 5, 6 ];
auto squares = map!("a * a")(arr1, arr2);
assert(squares == [ 1, 4, 9, 16, 25, 36 ]);
----

In all cases, the type of the result is the same as of the type of the
first range passed in. If a different type of range is needed, just
supply an empty range of the needed type as the first argument.

Example:
----
short[] arr = [ 1, 2 ];
auto squares = map!("a * a")(cast(int[]) null, arr);
assert(is(typeof(squares) == int[]));
----
*/</span>
<span class="d Template"><span class="k">template</span> <span class="i">map</span><span class="o TemplateParameters">(<span class="o TemplateTupleParameter"><span class="i">fun</span>...</span>)</span>
<span class="d Compound">{
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Qualified"><span class="t TemplateInstance"><span class="i">mapImpl</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">fun</span></span></span>)</span>.<span class="t Identifier"><span class="i">map</span></span></span> <span class="i">map</span>;</span></span>
}</span></span>

<span class="d Template"><span class="k">template</span> <span class="i">mapImpl</span><span class="o TemplateParameters">(<span class="o TemplateTupleParameter"><span class="i">fun</span>...</span>)</span>
<span class="d Compound">{
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">unaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">fun</span></span><span class="t Array">[<span class="e Int"><span class="n">0</span></span>]</span></span>)</span> <span class="i">headFun</span>;</span></span>
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Typeof"><span class="k">typeof</span>(<span class="e Call"><span class="e Identifier"><span class="i">headFun</span></span>(*<span class="i">begin</span>(<span class="i">Ranges</span>[<span class="n">0</span>]))</span>)</span><span class="t Array">[]</span> <span class="i">map</span><span class="o TemplateParameters">(<span class="o TemplateTupleParameter"><span class="i">Ranges</span>...</span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Ranges</span></span> <span class="i">rs</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="lc">//static assert(fun.length == 1, "Multiple funs not yet supported");</span>
        <span class="s Declaration"><span class="d Variables"><span class="t Typeof"><span class="k">typeof</span>(<span class="k">return</span>)</span> <span class="i">result</span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">r</span></span>, <span class="o Parameter"><span class="i">R</span></span></span>; <span class="e Identifier"><span class="i">Ranges</span></span>)
        <span class="s Compound">{
            <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">rs</span>[<span class="i">r</span>])</span> .. <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">rs</span>[<span class="i">r</span>])</span>)
            <span class="s Compound">{
                <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">result</span></span> ~= <span class="e Call"><span class="e Identifier"><span class="i">headFun</span></span>(*<span class="i">i</span>)</span></span>;</span>
            }</span></span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
    }</span></span></span></span></span>
}</span></span>
    
<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">arr1</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span> ]</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">arr2</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span> ]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">squares</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">map</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a * a"</span></span></span>)</span>(<span class="i">arr1</span>, <span class="i">arr2</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">squares</span></span> == <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">9</span></span>, <span class="e Int"><span class="n">16</span></span>, <span class="e Int"><span class="n">25</span></span>, <span class="e Int"><span class="n">36</span></span> ]</span></span>)</span>;</span>

    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">short</span></span><span class="t Array">[]</span> <span class="i">arr</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span> ]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">squares2</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">map</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a * a"</span></span></span>)</span>(<span class="k">cast</span>(<span class="k">int</span>[])<span class="k">null</span>, <span class="i">arr</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Is"><span class="k">is</span>(<span class="t Typeof"><span class="k">typeof</span>(<span class="e Identifier"><span class="i">squares2</span></span>)</span> == <span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span>)</span>)</span>;</span>
}</span></span></span>

<span class="lc">// reduce</span>
<span class="bc">/*private*/</span> <span class="d Template"><span class="k">template</span> <span class="i">NxNHelper</span><span class="o TemplateParameters">(<span class="o TemplateTupleParameter"><span class="i">F</span>...</span>)</span>
<span class="d Compound">{
    <span class="bc">/*private*/</span> <span class="d Template"><span class="k">template</span> <span class="i">For</span><span class="o TemplateParameters">(<span class="o TemplateTupleParameter"><span class="i">Args</span>...</span>)</span>
    <span class="d Compound">{
        <span class="d StorageClass"><span class="k">enum</span> <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">fs</span> = <span class="e Dot"><span class="e TemplateInstance"><span class="i">TypeTuple</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">F</span></span></span>)</span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
        <span class="d StaticAssert"><span class="k">static</span> <span class="k">assert</span>(
            <span class="e Identifier"><span class="i">fs</span></span>,
            <span class="e String"><span class="sl">"reduce: too few arguments. You must pass at least a function"</span></span>);</span>
        <span class="d StaticAssert"><span class="k">static</span> <span class="k">assert</span>(
            <span class="e Rel"><span class="e Dot"><span class="e Identifier"><span class="i">Args</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> &gt; <span class="e Identifier"><span class="i">fs</span></span></span>,
            <span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"reduce: too few arguments. You must pass one seed for"</span>
            <span class="sl">" each function (total "</span></span>~<span class="e TemplateInstance"><span class="i">ToString</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">fs</span></span></span>)</span></span>~<span class="e String"><span class="sl">")"</span>
            <span class="sl">", followed by the ranges to operate on."</span></span></span>);</span>
        <span class="lc">// Result type</span>
        <span class="d StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Dot"><span class="e Identifier"><span class="i">F</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> &gt; <span class="e Int"><span class="n">1</span></span></span>)
            <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">Tuple</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Args</span></span><span class="t Array">[<span class="e Int"><span class="n">0</span></span> .. <span class="e Dot"><span class="e Identifier"><span class="i">F</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>]</span></span>)</span> <span class="i">Result</span>;</span></span>
        <span class="k">else</span>
            <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Identifier"><span class="i">Args</span></span><span class="t Array">[<span class="e Int"><span class="n">0</span></span>]</span> <span class="i">Result</span>;</span></span></span>

        <span class="lc">// Element type</span>
        <span class="d StorageClass"><span class="k">enum</span> <span class="d Variables"><span class="i">functions</span> = <span class="e Dot"><span class="e Identifier"><span class="i">F</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span></span>
        <span class="lc">//alias typeof(*Args[functions]) Element;</span>

        <span class="lc">// Apply predicate</span>
        <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">R</span></span> <span class="i">apply</span><span class="o TemplateParameters">(<span class="o TemplateValueParameter"><span class="t Integral"><span class="k">uint</span></span> <span class="i">n</span></span>, <span class="o TemplateTypeParameter"><span class="i">R</span></span>, <span class="o TemplateTypeParameter"><span class="i">E</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">R</span></span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">E</span></span> <span class="i">b</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Typeof"><span class="k">typeof</span>(<span class="e Index"><span class="e Identifier"><span class="i">F</span></span>[<span class="e Identifier"><span class="i">n</span></span>]</span>)</span> <span class="i">thisFun</span>;</span></span></span>
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Typeof"><span class="k">typeof</span>(<span class="e Cat"><span class="e Identifier"><span class="i">thisFun</span></span>~<span class="e String"><span class="sl">""</span></span></span>)</span>)</span>) <span class="lc">// (!is(typeof(F[n](a, b))))</span>
            <span class="s Compound">{
                <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="e Cat"><span class="e String"><span class="sl">""</span></span>~<span class="e Index"><span class="e Identifier"><span class="i">F</span></span>[<span class="e Identifier"><span class="i">n</span></span>]</span></span></span>)</span>(<span class="i">a</span>, <span class="i">b</span>)</span>;</span>
            }</span>
            <span class="k">else</span>
            <span class="s Compound">{
                <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Index"><span class="e Identifier"><span class="i">F</span></span>[<span class="e Identifier"><span class="i">n</span></span>]</span>(<span class="i">a</span>, <span class="i">b</span>)</span>;</span>
            }</span></span>
        }</span></span></span></span></span>
    }</span></span>
}</span></span>

<span class="bc">/**
Implements the homonym function (also known as $(D accumulate), $(D
compress), $(D inject), or $(D foldl)) present in various programming
languages of functional flavor. The call $(D reduce!(fun)(seed,
range)) first assigns $(D seed) to an internal variable $(D result),
also called the accumulator. Then, for each element $(D x) in $(D
range), $(D result = fun(result, x)) gets evaluated. Finally, $(D
result) is returned. Many aggregate range operations turn out to be
solved with $(D reduce) quickly and easily. The example below
illustrates $(D reduce)'s remarkable power and flexibility.

Example:
----
int[] arr = [ 1, 2, 3, 4, 5 ];
// Sum all elements
auto sum = reduce!("a + b")(0, arr);
assert(sum == 15);

// Compute the maximum of all elements
auto largest = reduce!(max)(arr[0], arr[1 .. $]);
assert(largest == 5);

// Compute the number of odd elements
auto odds = reduce!("a + (b &amp; 1)")(0, arr);
assert(odds == 3);

// Compute the sum of squares
auto ssquares = reduce!("a + b * b")(0, arr);
assert(ssquares == 55);
----

$(DDOC_SECTION_H Multiple ranges:) It is possible to pass any number
of ranges to $(D reduce), as in $(D reduce!(fun)(seed, range1, range2,
range3)). Then $(D reduce) will simply apply its algorithm in
succession to each range, from left to right.

Example:
----
int[] a = [ 3, 4 ];
int[] b = [ 100 ];
auto r = reduce!("a + b")(0, a, b);
assert(r == 107);

// Mixing convertible types is fair game, too
double[] c = [ 2.5, 3.0 ];
auto r1 = reduce!("a + b")(0.0, a, b, c);
assert(r1 == 112.5);
----

$(DDOC_SECTION_H Multiple functions:) Sometimes it is very useful to
compute multiple aggregates in one pass. One advantage is that the
computation is faster because the looping overhead is shared. That's
why $(D reduce) accepts multiple functions. If two or more functions
are passed, $(D reduce) returns a $(XREF typecons, Tuple) object with
one member per passed-in function. The number of seeds must be
correspondingly increased.

Example:
----
double[] a = [ 3.0, 4, 7, 11, 3, 2, 5 ];
// Compute minimum and maximum in one pass
auto r = reduce!(min, max)(double.max, -double.max, a);
// The type of r is Tuple!(double, double)
assert(r._0 == 2);  // minimum
assert(r._1 == 11); // maximum

// Compute sum and sum of squares in one pass
r = reduce!("a + b", "a + b * b")(0.0, 0.0, a);
assert(r._0 == 35);  // sum
assert(r._1 == 233); // sum of squares
// Compute average and standard deviation from the above
auto avg = r._0 / a.length;
auto stdev = sqrt(r._1 / a.length - avg * avg);
----

$(DDOC_SECTION_H Multiple ranges and functions:) The most general form
of $(D reduce) accepts multiple functions and multiple ranges
simultaneously. The call $(D reduce!(fun1, ..., funN)(seed1, ...,
seedN, range1, ..., rangeM)) applies the reduction algorithm for all
functions and all ranges.

Example:
----
int[] a = [ 3, 4, 7, 11, 3, 2, 5 ];
double[] b = [ 2.5, 4, -4.5, 2, 10.9 ];
// Compute minimum and maximum in one pass over a and b
auto r = reduce!(min, max)(double.max, -double.max, a, b);
assert(r._0 == -4.5);  // minimum
assert(r._1 == 11);    // maximum
----
*/</span>

<span class="d Template"><span class="k">template</span> <span class="i">reduce</span><span class="o TemplateParameters">(<span class="o TemplateTupleParameter"><span class="i">F</span>...</span>)</span>
<span class="d Compound">{
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Qualified"><span class="t Qualified"><span class="t TemplateInstance"><span class="i">NxNHelper</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">F</span></span></span>)</span>.<span class="t TemplateInstance"><span class="i">For</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Args</span></span></span>)</span></span>.<span class="t Identifier"><span class="i">Result</span></span></span> <span class="i">reduce</span><span class="o TemplateParameters">(<span class="o TemplateTupleParameter"><span class="i">Args</span>...</span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Args</span></span> <span class="i">args</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Qualified"><span class="t TemplateInstance"><span class="i">NxNHelper</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">F</span></span></span>)</span>.<span class="t TemplateInstance"><span class="i">For</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Args</span></span></span>)</span></span> <span class="i">Aux</span>;</span></span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Typeof"><span class="k">typeof</span>(<span class="k">return</span>)</span> <span class="i">result</span>;</span></span>
        <span class="lc">// Prime the result</span>
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Dot"><span class="e Identifier"><span class="i">F</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> &gt; <span class="e Int"><span class="n">1</span></span></span>)
        <span class="s Compound">{
            <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">j</span></span>, <span class="o Parameter"><span class="i">unused</span></span></span>; <span class="e Slice"><span class="e Identifier"><span class="i">args</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Dot"><span class="e Identifier"><span class="i">F</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>]</span>) <span class="lc">// for all functions</span>
            <span class="s Compound">{
                <span class="lc">// @@@BUG@@@</span>
                <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">p</span> = <span class="e Mixin"><span class="k">mixin</span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"&amp;result.field!("</span></span>~<span class="e TemplateInstance"><span class="i">ToString</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">j</span></span></span>)</span></span>~<span class="e String"><span class="sl">")"</span></span></span>)</span>;</span></span>
                <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">p</span></span></span> = <span class="e Index"><span class="e Identifier"><span class="i">args</span></span>[<span class="e Identifier"><span class="i">j</span></span>]</span></span>;</span>
            }</span></span>
        }</span>
        <span class="k">else</span>
        <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">result</span></span> = <span class="e Index"><span class="e Identifier"><span class="i">args</span></span>[<span class="e Int"><span class="n">0</span></span>]</span></span>;</span>
        }</span></span>
        <span class="lc">// Accumulate</span>
        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span>, <span class="o Parameter"><span class="i">range</span></span></span>; <span class="e Slice"><span class="e Identifier"><span class="i">args</span></span>[<span class="e Dot"><span class="e Identifier"><span class="i">F</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> .. <span class="e Dollar">$</span>]</span>) <span class="lc">// all inputs</span>
        <span class="s Compound">{
            <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">it</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">range</span>)</span> .. <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">range</span>)</span>) <span class="lc">// current input</span>
            <span class="s Compound">{
                <span class="lc">// @@@BUG@@@</span>
                <span class="lc">//foreach (j, f; F) // for all functions</span>
                <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">j</span></span>, <span class="o Parameter"><span class="i">unused</span></span></span>; <span class="e Slice"><span class="e Identifier"><span class="i">Args</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Dot"><span class="e Identifier"><span class="i">F</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>]</span>) <span class="lc">// for all functions</span>
                <span class="s Compound">{
                    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Dot"><span class="e Identifier"><span class="i">F</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> &gt; <span class="e Int"><span class="n">1</span></span></span>)
                    <span class="s Compound">{
                        <span class="lc">// @@@BUG@@@</span>
                        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">p</span> = <span class="e Mixin"><span class="k">mixin</span>(<span class="e Cat"><span class="e Cat"><span class="e String"><span class="sl">"&amp;result.field!("</span></span>~<span class="e TemplateInstance"><span class="i">ToString</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">j</span></span></span>)</span></span>~<span class="e String"><span class="sl">")"</span></span></span>)</span>;</span></span>
                    }</span>
                    <span class="k">else</span>
                    <span class="s Compound">{
                        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">p</span> = <span class="e Address">&amp;<span class="e Identifier"><span class="i">result</span></span></span>;</span></span>
                    }</span></span>
                    <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">p</span></span></span> = <span class="e Call"><span class="e Dot"><span class="e Identifier"><span class="i">Aux</span></span>.<span class="e TemplateInstance"><span class="i">apply</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">j</span></span>, <span class="t Typeof"><span class="k">typeof</span>(<span class="e Deref">*<span class="e Identifier"><span class="i">p</span></span></span>)</span>, <span class="t Typeof"><span class="k">typeof</span>(<span class="e Deref">*<span class="e Identifier"><span class="i">it</span></span></span>)</span></span>)</span></span>(*<span class="i">p</span>, *<span class="i">it</span>)</span></span>;</span>
                }</span></span>
            }</span></span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
    }</span></span></span></span></span>
}</span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span> ]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">r</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">reduce</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a + b"</span></span></span>)</span>(<span class="n">0</span>, <span class="i">a</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">r</span></span> == <span class="e Int"><span class="n">7</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">r</span></span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">reduce</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">min</span></span></span>)</span>(<span class="k">int</span>.<span class="i">max</span>, <span class="i">a</span>)</span></span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">r</span></span> == <span class="e Int"><span class="n">3</span></span></span>)</span>;</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">double</span></span><span class="t Array">[]</span> <span class="i">b</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">100</span></span> ]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">r1</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">reduce</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a + b"</span></span></span>)</span>(<span class="n">0.0</span>, <span class="i">a</span>, <span class="i">b</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">r1</span></span> == <span class="e Int"><span class="n">107</span></span></span>)</span>;</span>    

    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">a</span></span> = <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span> ]</span></span>;</span>
    <span class="lc">// Stringize with commas</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">string</span></span> <span class="i">rep</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">reduce</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a ~ `, ` ~ to!(string)(b)"</span></span></span>)</span>(<span class="k">cast</span>(<span class="i">string</span>) <span class="k">null</span>, <span class="i">a</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Slice"><span class="e Identifier"><span class="i">rep</span></span>[<span class="e Int"><span class="n">2</span></span> .. <span class="e Dollar">$</span>]</span> == <span class="e String"><span class="sl">"1, 2, 3, 4, 5"</span></span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// overlap</span>
<span class="bc">/**
Returns the overlapping range, if any, of two ranges. Unlike $(D
equal), $(D overlap) only compares the iterators in the ranges, not
the values referred by them. If $(D r1) and $(D r2) have an
overlapping range, returns that range. Otherwise, returns an empty
range. Performs $(BIGOH min(r1.length, r2.length)) iterator increment
operations and comparisons if the ranges are forward, and $(BIGOH 1)
operations if the ranges have random access.

Example:
----
int[] a = [ 10, 11, 12, 13, 14 ];
int[] b = a[1 .. 3];
assert(overlap(a, b) == [ 11, 12 ]);
b = b.dup;
// overlap disappears even though the content is the same
assert(isEmpty(overlap(a, b)));
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">overlap</span><span class="o TemplateParameters">(<span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r1</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r2</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">b</span> = <span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">begin</span>(<span class="i">r1</span>), <span class="i">begin</span>(<span class="i">r2</span>))</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">e</span> = <span class="e Call"><span class="e Identifier"><span class="i">min</span></span>(<span class="i">end</span>(<span class="i">r1</span>), <span class="i">end</span>(<span class="i">r2</span>))</span>;</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Cond"><span class="e Rel"><span class="e Identifier"><span class="i">b</span></span> &lt; <span class="e Identifier"><span class="i">e</span></span></span> ? <span class="e Call"><span class="e Identifier"><span class="i">range</span></span>(<span class="i">b</span>, <span class="i">e</span>)</span> : <span class="e Null"><span class="k">null</span></span></span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">10</span></span>, <span class="e Int"><span class="n">11</span></span>, <span class="e Int"><span class="n">12</span></span>, <span class="e Int"><span class="n">13</span></span>, <span class="e Int"><span class="n">14</span></span> ]</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">b</span> = <span class="e Slice"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Int"><span class="n">1</span></span> .. <span class="e Int"><span class="n">3</span></span>]</span>;</span></span>
    <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> = <span class="e Int"><span class="n">100</span></span></span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">overlap</span></span>(<span class="i">a</span>, <span class="i">b</span>)</span> == <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">100</span></span>, <span class="e Int"><span class="n">12</span></span> ]</span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// filter</span>
<span class="bc">/**
Implements the homonym function present in various programming
languages of functional flavor. The call $(D filter!(fun)(range))
returns a new range only containing elements $(D x) in $(D r) for
which $(D pred(x)) is $(D true).

Example:
----
int[] arr = [ 1, 2, 3, 4, 5 ];
// Sum all elements
auto small = filter!("a &lt; 3")(arr);
assert(small == [ 1, 2 ]);
----

$(DDOC_SECTION_H Multiple ranges:) It is possible to pass any number
of ranges to $(D filter), as in $(D filter!(fun)(range1, range2,
range3)). Then $(D filter) will simply apply its algorithm in
succession to each range, from left to right. The type returned is
that of the first range.

Example:
----
int[] a = [ 3, -2, 400 ];
int[] b = [ 100, -101, 102 ];
auto r = filter!("a &gt; 0")(a, b);
assert(r == [ 3, 400, 100, 102 ]);

// Mixing convertible types is fair game, too
double[] c = [ 2.5, 3.0 ];
auto r1 = filter!("cast(int) a != a")(c, a, b);
assert(r1 == [ 2.5 ]);
----
*/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">Ranges</span></span><span class="t Array">[<span class="e Int"><span class="n">0</span></span>]</span> <span class="i">filter</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span></span>, <span class="o TemplateTupleParameter"><span class="i">Ranges</span>...</span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Ranges</span></span> <span class="i">rs</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">unaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span> <span class="i">fun</span>;</span></span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Typeof"><span class="k">typeof</span>(<span class="k">return</span>)</span> <span class="i">result</span>;</span></span>
    <span class="lc">// Accumulate</span>
    <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span>, <span class="o Parameter"><span class="i">range</span></span></span>; <span class="e Slice"><span class="e Identifier"><span class="i">rs</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Dollar">$</span>]</span>) <span class="lc">// all inputs</span>
    <span class="s Compound">{
        <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">it</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">range</span>)</span> .. <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">range</span>)</span>) <span class="lc">// current input</span>
        <span class="s Compound">{
            <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">fun</span></span>(*<span class="i">it</span>)</span>) <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">result</span></span> ~= <span class="e Deref">*<span class="e Identifier"><span class="i">it</span></span></span></span>;</span></span>
        }</span></span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span> ]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">r</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">filter</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &gt; 3"</span></span></span>)</span>(<span class="i">a</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">r</span></span> == <span class="e ArrayLiteral">[ <span class="n">4</span> ]</span></span>)</span>;</span>

    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">a</span></span> = <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">22</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">42</span></span>, <span class="e Int"><span class="n">5</span></span> ]</span></span>;</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">under10</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">filter</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &lt; 10"</span></span></span>)</span>(<span class="i">a</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">under10</span></span> == <span class="e ArrayLiteral">[<span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">5</span></span>]</span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// inPlace</span>
<span class="bc">/**
Similar to $(D map), but it manipulates the passed-in ranges in place
and returns $(D void). The call $(D inPlace!(fun)(range1, range2, ...,
rangeN)) applies $(D fun(x)) left to right for all $(D ref x) in $(D
range1), then all $(D ref x) in $(D range2), ..., all $(D ref x) in
$(D rangeN).

Example:
----
int[] arr1 = [ 1, 2, 3 ];
inPlace!(writeln)(arr1); // print the array
double[] arr2 = [ 4.0, 8.5, 13 ];
inPlace!("++a")(arr1, arr2);
assert(arr1 == [ 2, 3, 4 ]);
assert(arr2 == [ 5.0, 9.5, 14 ]);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">inPlace</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">fun</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>, <span class="o TemplateTupleParameter"><span class="i">Ranges</span>...</span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Ranges</span></span> <span class="i">rs</span></span>)</span>
<span class="lc">// @@@BUG@@ This should work:</span>
<span class="lc">// void inPlace(alias fun, Ranges...)(Ranges rs)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">unaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">fun</span></span>, <span class="e Bool"><span class="k">true</span></span></span>)</span> <span class="i">todo</span>;</span></span></span>
    <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">j</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span> .. <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">todo</span></span>(*<span class="i">j</span>)</span>;</span></span>
    <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span>, <span class="o Parameter"><span class="i">x</span></span></span>; <span class="e Identifier"><span class="i">rs</span></span>)
    <span class="s Compound">{
        <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">j</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">x</span>)</span> .. <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">x</span>)</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">todo</span></span>(*<span class="i">j</span>)</span>;</span></span>
    }</span></span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="lc">// fill with 42</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span> ]</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">double</span></span><span class="t Array">[]</span> <span class="i">b</span> =  <span class="e ArrayInit">[ <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">4</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">inPlace</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a = 42"</span></span></span>)</span>(<span class="i">a</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e Int"><span class="n">42</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e Int"><span class="n">42</span></span></span></span>)</span>;</span>
    <span class="lc">//assert(b[0] == 42 &amp;&amp; b[1] == 42);</span>
    
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">arr1</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span> ]</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">double</span></span><span class="t Array">[]</span> <span class="i">arr2</span> = <span class="e ArrayInit">[ <span class="e Real"><span class="n">4.0</span></span>, <span class="e Real"><span class="n">8.5</span></span>, <span class="e Int"><span class="n">13</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">inPlace</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"++a"</span></span></span>)</span>(<span class="i">arr1</span>, <span class="i">arr2</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">arr1</span></span> == <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span> ]</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">arr2</span></span> == <span class="e ArrayLiteral">[ <span class="e Real"><span class="n">5.0</span></span>, <span class="e Real"><span class="n">9.5</span></span>, <span class="e Int"><span class="n">14</span></span> ]</span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// move</span>
<span class="bc">/**
Moves $(D source) into $(D target) via a destructive
copy. Specifically: $(UL $(LI If $(D hasAliasing!(T)) is true (see
$(XREF traits, hasAliasing)), then the representation of $(D source)
is bitwise copied into $(D target) and then $(D source = T.init) is
evaluated.)  $(LI Otherwise, $(D target = source) is evaluated.)) See
also $(XREF contracts, pointsTo).

Preconditions:
$(D !pointsTo(source, source))
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">move</span><span class="o TemplateParameters">(<span class="o TemplateTypeParameter"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">T</span></span> <span class="i">source</span></span>, <span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">T</span></span> <span class="i">target</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">pointsTo</span></span></span>(<span class="i">source</span>, <span class="i">source</span>)</span>)</span>;</span>
    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e TemplateInstance"><span class="i">hasAliasing</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T</span></span></span>)</span>)
    <span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Identifier"><span class="i">T</span></span> == <span class="k">class</span>)</span>)
        <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">target</span></span> = <span class="e Identifier"><span class="i">source</span></span></span>;</span>
        }</span>
        <span class="k">else</span>
        <span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">memcpy</span></span>(&amp;<span class="i">target</span>, &amp;<span class="i">source</span>, <span class="i">target</span>.<span class="i">sizeof</span>)</span>;</span>
        }</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">source</span></span> = <span class="e Dot"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">init</span></span></span></span>;</span>
    }</span>
    <span class="k">else</span>
    <span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">target</span></span> = <span class="e Identifier"><span class="i">source</span></span></span>;</span>
    }</span></span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Object</span></span> <span class="i">obj1</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">Object</span></span></span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Object</span></span> <span class="i">obj2</span> = <span class="e Identifier"><span class="i">obj1</span></span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">Object</span></span> <span class="i">obj3</span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">move</span></span>(<span class="i">obj2</span>, <span class="i">obj3</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Identity"><span class="e Identifier"><span class="i">obj2</span></span> <span class="k">is</span> <span class="e Null"><span class="k">null</span></span></span> &amp;&amp; <span class="e Identity"><span class="e Identifier"><span class="i">obj3</span></span> <span class="k">is</span> <span class="e Identifier"><span class="i">obj1</span></span></span></span>)</span>;</span>

    <span class="s Declaration"><span class="d Struct"><span class="k">struct</span> <span class="i">S1</span> <span class="d Compound">{ <span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">a</span> = <span class="e Int"><span class="n">1</span></span>, <span class="i">b</span> = <span class="e Int"><span class="n">2</span></span>;</span> }</span></span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">S1</span></span> <span class="i">s11</span> = <span class="e StructInit">{ <span class="e Int"><span class="n">10</span></span>, <span class="e Int"><span class="n">11</span></span> }</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">S1</span></span> <span class="i">s12</span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">move</span></span>(<span class="i">s11</span>, <span class="i">s12</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">s11</span></span>.<span class="e Identifier"><span class="i">a</span></span></span> == <span class="e Int"><span class="n">10</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">s11</span></span>.<span class="e Identifier"><span class="i">b</span></span></span> == <span class="e Int"><span class="n">11</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">s12</span></span>.<span class="e Identifier"><span class="i">a</span></span></span> == <span class="e Int"><span class="n">10</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">s12</span></span>.<span class="e Identifier"><span class="i">b</span></span></span> == <span class="e Int"><span class="n">11</span></span></span></span>)</span>;</span>

    <span class="s Declaration"><span class="d Struct"><span class="k">struct</span> <span class="i">S2</span> <span class="d Compound">{ <span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">a</span> = <span class="e Int"><span class="n">1</span></span>;</span> <span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="t Pointer">*</span> <span class="i">b</span>;</span> }</span></span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">S2</span></span> <span class="i">s21</span> = <span class="e StructInit">{ <span class="e Int"><span class="n">10</span></span>, <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">int</span></span></span> }</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">S2</span></span> <span class="i">s22</span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">move</span></span>(<span class="i">s21</span>, <span class="i">s22</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">s21</span></span>.<span class="e Identifier"><span class="i">a</span></span></span> == <span class="e Int"><span class="n">1</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">s21</span></span>.<span class="e Identifier"><span class="i">b</span></span></span> == <span class="e Null"><span class="k">null</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">s22</span></span>.<span class="e Identifier"><span class="i">a</span></span></span> == <span class="e Int"><span class="n">10</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">s22</span></span>.<span class="e Identifier"><span class="i">b</span></span></span> != <span class="e Null"><span class="k">null</span></span></span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// swap</span>
<span class="bc">/**
Swaps $(D lhs) and $(D rhs). See also $(XREF contracts, pointsTo).

Preconditions:

$(D !pointsTo(lhs, lhs) &amp;&amp; !pointsTo(lhs, rhs) &amp;&amp; !pointsTo(rhs, lhs)
&amp;&amp; !pointsTo(rhs, rhs))
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">swap</span><span class="o TemplateParameters">(<span class="o TemplateTypeParameter"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">T</span></span> <span class="i">lhs</span></span>, <span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">T</span></span> <span class="i">rhs</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">pointsTo</span></span></span>(<span class="i">lhs</span>, <span class="i">lhs</span>)</span> &amp;&amp; <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">pointsTo</span></span></span>(<span class="i">lhs</span>, <span class="i">rhs</span>)</span></span>
           &amp;&amp; <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">pointsTo</span></span></span>(<span class="i">rhs</span>, <span class="i">lhs</span>)</span></span> &amp;&amp; <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">pointsTo</span></span></span>(<span class="i">rhs</span>, <span class="i">rhs</span>)</span></span>)</span>;</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">t</span> = <span class="e Identifier"><span class="i">lhs</span></span>;</span></span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">lhs</span></span> = <span class="e Identifier"><span class="i">rhs</span></span></span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">rhs</span></span> = <span class="e Identifier"><span class="i">t</span></span></span>;</span>
}</span></span></span></span></span>

<span class="lc">// overwriteAdjacent</span>
<span class="bc">/**
Reduces $(D r) by shifting it to the left until no adjacent elements
$(D a), $(D b) remain in $(D r) such that $(D pred(a, b)). Shifting is
performed by evaluating $(D move(source, target)) as a primitive. The
algorithm is stable and runs in $(BIGOH r.length) time. Returns the
reduced range.

The default $(XREF _algorithm, move) performs a potentially
destructive assignment of $(D source) to $(D target), so the objects
beyond the returned range should be considered "empty". By default $(D
pred) compares for equality, in which case $(D overwriteAdjacent)
collapses adjacent duplicate elements to one (functionality akin to
the $(WEB wikipedia.org/wiki/Uniq, uniq) system utility).

Example:
----
int[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];
auto r = overwriteAdjacent(arr);
assert(r == [ 1, 2, 3, 4, 5 ]);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">overwriteAdjacent</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span></span>, <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">move</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">isEmpty</span></span>(<span class="i">r</span>)</span>) <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">r</span></span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">target</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span>, <span class="i">e</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span>;</span></span>
    <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">source</span></span></span>; <span class="e Plus"><span class="e Identifier"><span class="i">target</span></span> + <span class="e Int"><span class="n">1</span></span></span> .. <span class="e Identifier"><span class="i">e</span></span>)
    <span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">pred</span></span></span>(*<span class="i">target</span>, *<span class="i">source</span>)</span>)
        <span class="s Compound">{
            <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">target</span></span></span>;</span>
            <span class="s Continue"><span class="k">continue</span>;</span>
        }</span></span>
        <span class="lc">// found an equal *source and *target</span>
        <span class="s For"><span class="k">for</span> (;;)
        <span class="s Compound">{
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">move</span></span>(*<span class="i">source</span>, *<span class="i">target</span>)</span>;</span>
            <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">source</span></span></span>;</span>
            <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">source</span></span> == <span class="e Identifier"><span class="i">e</span></span></span>) <span class="s Break"><span class="k">break</span>;</span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">pred</span></span></span>(*<span class="i">target</span>, *<span class="i">source</span>)</span>) <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">target</span></span></span>;</span></span>
        }</span></span>
        <span class="s Break"><span class="k">break</span>;</span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">range</span></span>(<span class="i">begin</span>(<span class="i">r</span>), <span class="i">target</span> + <span class="n">1</span>)</span>;</span>
}</span></span></span></span></span>

<span class="lc">/// Ditto</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">overwriteAdjacent</span><span class="o TemplateParameters">(
    <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">string</span></span> <span class="i">fun</span> = <span class="e String"><span class="sl">"a == b"</span></span></span>,
    <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">move</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">move</span></span></span></span>,
    <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e ModuleScope">.<span class="e TemplateInstance"><span class="i">overwriteAdjacent</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">fun</span></span></span>)</span>, <span class="t Identifier"><span class="i">move</span></span>, <span class="t Identifier"><span class="i">Range</span></span></span>)</span></span>(<span class="i">r</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">arr</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span> ]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">r</span> = <span class="e Call"><span class="e Identifier"><span class="i">overwriteAdjacent</span></span>(<span class="i">arr</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">r</span></span> == <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span> ]</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">arr</span></span> == <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span> ]</span></span>)</span>;</span>
    
}</span></span></span>

<span class="lc">// find</span>
<span class="bc">/**
Finds the first occurrence of $(D needle) in $(D haystack) by linear
search and returns an iterator to it.  An optional binary predicate
$(D pred) instructs $(D find) on how to perform the comparison (with
the current collection element in the first position and $(D needle)
in the second position). By default, comparison is for
equality. Performs $(BIGOH haystack.length) evaluations of $(D
pred). See also $(WEB sgi.com/tech/stl/_find.html, STL's _find).

To find the last occurence of $(D needle) in $(D haystack), call $(D
find(retro(haystack), needle)) and compare the result against $(D
rEnd(haystack)). See also $(XREF iterator, retro).

Example:
----
auto a = [ 1, 2, 3 ];
assert(find(a, 5) == end(a));       // not found
assert(find(a, 2) == begin(a) + 1); // found

// Case-insensitive find of a string
string[] s = [ "Hello", "world", "!" ];
assert(find!("toupper(a) == toupper(b)")(s, "hello") == begin(s));
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range</span></span></span>)</span> <span class="i">find</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span> = <span class="sl">"a == b"</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>, <span class="o TemplateTypeParameter"><span class="i">E</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">haystack</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">E</span></span> <span class="i">needle</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span> <span class="i">test</span>;</span></span></span>
    <span class="lc">// @@@BUG@@@</span>
    <span class="lc">//foreach (i; begin(haystack) .. end(haystack))</span>
    <span class="s For"><span class="k">for</span> (<span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">i</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">haystack</span>)</span>;</span></span> <span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> != <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">haystack</span>)</span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>)
    <span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">test</span></span>(*<span class="i">i</span>, <span class="i">needle</span>)</span>) <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">i</span></span>;</span></span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">haystack</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">find</span></span>(<span class="i">a</span>, <span class="n">5</span>)</span> == <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">a</span>)</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">find</span></span>(<span class="i">a</span>, <span class="n">2</span>)</span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">a</span>)</span> + <span class="e Int"><span class="n">1</span></span></span></span>)</span>;</span>

    <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">T</span></span></span>; <span class="e TemplateInstance"><span class="i">TypeTuple</span>!(<span class="o TemplateArguments"><span class="t Integral"><span class="k">int</span></span>, <span class="t Integral"><span class="k">double</span></span></span>)</span>)
    <span class="s Compound">{
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">b</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">rndstuff</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T</span></span></span>)</span>()</span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Dot"><span class="e Not">!<span class="e Identifier"><span class="i">b</span></span></span>.<span class="e Identifier"><span class="i">length</span></span></span>) <span class="s Continue"><span class="k">continue</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">b</span></span>[<span class="e Div"><span class="e Dollar">$</span> / <span class="e Int"><span class="n">2</span></span></span>]</span> = <span class="e Int"><span class="n">200</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">b</span></span>[<span class="e Div"><span class="e Dollar">$</span> / <span class="e Int"><span class="n">4</span></span></span>]</span> = <span class="e Int"><span class="n">200</span></span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">find</span></span>(<span class="i">b</span>, <span class="n">200</span>)</span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">b</span>)</span> + <span class="e Div"><span class="e Dot"><span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> / <span class="e Int"><span class="n">4</span></span></span></span></span>)</span>;</span>
    }</span></span>

<span class="lc">// Case-insensitive find of a string</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">string</span></span><span class="t Array">[]</span> <span class="i">s</span> = <span class="e ArrayInit">[ <span class="e String"><span class="sl">"Hello"</span></span>, <span class="e String"><span class="sl">"world"</span></span>, <span class="e String"><span class="sl">"!"</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">find</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"toupper(a) == toupper(b)"</span></span></span>)</span>(<span class="i">s</span>, <span class="sl">"hello"</span>)</span> == <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">s</span>)</span></span>)</span>;</span>

    <span class="d StorageClass"><span class="k">static</span> <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">f</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">string</span></span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">string</span></span> <span class="i">b</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">toupper</span></span>(<span class="i">a</span>)</span> == <span class="e Call"><span class="e Identifier"><span class="i">toupper</span></span>(<span class="i">b</span>)</span></span>;</span> }</span></span></span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">find</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">f</span></span></span>)</span>(<span class="i">s</span>, <span class="sl">"hello"</span>)</span> == <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">s</span>)</span></span>)</span>;</span>
}</span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">6</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">find</span></span>(<span class="i">retro</span>(<span class="i">a</span>), <span class="n">5</span>)</span> == <span class="e Call"><span class="e Identifier"><span class="i">rEnd</span></span>(<span class="i">a</span>)</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">find</span></span>(<span class="i">retro</span>(<span class="i">a</span>), <span class="n">2</span>)</span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">rBegin</span></span>(<span class="i">a</span>)</span> + <span class="e Int"><span class="n">1</span></span></span></span>)</span>;</span>

    <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">T</span></span></span>; <span class="e TemplateInstance"><span class="i">TypeTuple</span>!(<span class="o TemplateArguments"><span class="t Integral"><span class="k">int</span></span>, <span class="t Integral"><span class="k">double</span></span></span>)</span>)
    <span class="s Compound">{
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">b</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">rndstuff</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T</span></span></span>)</span>()</span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Dot"><span class="e Not">!<span class="e Identifier"><span class="i">b</span></span></span>.<span class="e Identifier"><span class="i">length</span></span></span>) <span class="s Continue"><span class="k">continue</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">b</span></span>[<span class="e Div"><span class="e Dollar">$</span> / <span class="e Int"><span class="n">2</span></span></span>]</span> = <span class="e Int"><span class="n">200</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">b</span></span>[<span class="e Div"><span class="e Dollar">$</span> / <span class="e Int"><span class="n">4</span></span></span>]</span> = <span class="e Int"><span class="n">200</span></span></span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">find</span></span>(<span class="i">retro</span>(<span class="i">b</span>), <span class="n">200</span>)</span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">rBegin</span></span>(<span class="i">b</span>)</span> + <span class="e Div"><span class="e Paren">(<span class="e Minus"><span class="e Dot"><span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> - <span class="e Int"><span class="n">1</span></span></span>)</span> / <span class="e Int"><span class="n">2</span></span></span></span></span>)</span>;</span>
    }</span></span>
}</span></span></span>

<span class="bc">/**
Finds the first element in a range satisfying the unary predicate $(D
pred). Performs $(BIGOH haystack.length) evaluations of $(D pred). See
also $(WEB sgi.com/tech/stl/find_if.html, STL's find_if).

To find the last element of $(D haystack) satisfying $(D pred), call
$(D find!(pred)(retro(haystack))) and compare the result against $(D
rEnd(haystack)). See also $(XREF iterator, retro).

Example:
----
auto arr = [ 1, 2, 3 ];
assert(find!("a &gt; 2")(arr) == end(arr) - 1);

// with predicate alias
bool pred(int x) { return x + 1 &gt; 1.5; }
assert(find!(pred)(arr) == begin(arr));
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range</span></span></span>)</span> <span class="i">find</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">haystack</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">unaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span> <span class="i">predFun</span>;</span></span></span>
    <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">haystack</span>)</span> .. <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">haystack</span>)</span>)
    <span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">predFun</span></span>(*<span class="i">i</span>)</span>) <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">i</span></span>;</span></span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">haystack</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">find</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &gt; 2"</span></span></span>)</span>(<span class="i">a</span>)</span> == <span class="e Minus"><span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">a</span>)</span> - <span class="e Int"><span class="n">1</span></span></span></span>)</span>;</span>
    <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">pred</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">int</span></span> <span class="i">x</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Rel"><span class="e Plus"><span class="e Identifier"><span class="i">x</span></span> + <span class="e Int"><span class="n">1</span></span></span> &gt; <span class="e Real"><span class="n">1.5</span></span></span>;</span> }</span></span></span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">find</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span>(<span class="i">a</span>)</span> == <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">a</span>)</span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// findRange</span>
<span class="bc">/**
Finds the first occurrence of $(D subseq) in $(D seq) by repeated
linear searches.  Performs $(BIGOH seq.length * subseq.length)
evaluations of $(D pred), which makes it unrecommended for very large
ranges, for which $(XREF algorithm, findBoyerMoore) may be more
appropriate. See also $(WEB sgi.com/tech/stl/search.html, STL's
search).

Example:
----
int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
int[] b = [ 1, 2, 3 ];
assert(findRange(a, b) == begin(a) + 2);
assert(findRange(b, a) == end(b));
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range1</span></span></span>)</span> <span class="i">findRange</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span> = <span class="sl">"a == b"</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range1</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range2</span></span>)</span>
    <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range1</span></span> <span class="i">seq</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">subseq</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">e1</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">seq</span>)</span>;</span></span>
    <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Dot"><span class="e Identifier"><span class="i">seq</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> &lt; <span class="e Dot"><span class="e Identifier"><span class="i">subseq</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span>) <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">e1</span></span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">e11</span> = <span class="e Plus"><span class="e Minus"><span class="e Identifier"><span class="i">e1</span></span> - <span class="e Dot"><span class="e Identifier"><span class="i">subseq</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span> + <span class="e Int"><span class="n">1</span></span></span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">e2</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">subseq</span>)</span>;</span></span>
    <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">seq</span>)</span> .. <span class="e Identifier"><span class="i">e11</span></span>)
    <span class="s Compound">{
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">m</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">mismatch</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span>(<span class="i">range</span>(<span class="i">i</span>, <span class="i">e1</span>), <span class="i">subseq</span>)</span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">_1</span></span></span> == <span class="e Identifier"><span class="i">e2</span></span></span>) <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">i</span></span>;</span></span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">e1</span></span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Sign">-<span class="e Int"><span class="n">1</span></span></span>, <span class="e Int"><span class="n">0</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span> ]</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">b</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">findRange</span></span>(<span class="i">a</span>, <span class="i">b</span>)</span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">a</span>)</span> + <span class="e Int"><span class="n">2</span></span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">findRange</span></span>(<span class="i">b</span>, <span class="i">a</span>)</span> == <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">b</span>)</span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// findBoyerMoore</span>
<span class="d Protection"><span class="k">private</span> <span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">BoyerMooreFinder</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span>
<span class="d Compound">{
<span class="d Protection"><span class="k">private</span>:
    <span class="d Compound"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">skip</span><span class="t Array">[]</span>;</span>
    <span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[<span class="t Typeof"><span class="k">typeof</span>(<span class="e Index"><span class="e Identifier"><span class="i">Range</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>)</span>]</span> <span class="i">occ</span>;</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">needle</span>;</span>
  
    <span class="d Function"><span class="t Integral"><span class="k">int</span></span> <span class="i">occurrence</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">char</span></span> <span class="i">c</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">p</span> = <span class="e In"><span class="e Identifier"><span class="i">c</span></span> <span class="k">in</span> <span class="e Identifier"><span class="i">occ</span></span></span>;</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Cond"><span class="e Identifier"><span class="i">p</span></span> ? <span class="e Deref">*<span class="e Identifier"><span class="i">p</span></span></span> : <span class="e Sign">-<span class="e Int"><span class="n">1</span></span></span></span>;</span>
    }</span></span></span>

<span class="bc">/* This helper function checks, whether the last "portion" bytes
 * of "needle" (which is "nlen" bytes long) exist within the "needle"
 * at offset "offset" (counted from the end of the string),
 * and whether the character preceding "offset" is not a match.
 * Notice that the range being checked may reach beyond the
 * beginning of the string. Such range is ignored.
 */</span>
    <span class="d StorageClass"><span class="k">static</span> <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">needlematch</span><span class="o TemplateParameters">(<span class="o TemplateTypeParameter"><span class="i">R</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">R</span></span> <span class="i">needle</span></span>,
                              <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">portion</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">offset</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">virtual_begin</span> = <span class="e Minus"><span class="e Minus"><span class="e Dot"><span class="e Identifier"><span class="i">needle</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> - <span class="e Identifier"><span class="i">offset</span></span></span> - <span class="e Identifier"><span class="i">portion</span></span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">ignore</span> = <span class="e Int"><span class="n">0</span></span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">virtual_begin</span></span> &lt; <span class="e Int"><span class="n">0</span></span></span>) <span class="s Compound">{ 
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">ignore</span></span> = <span class="e Sign">-<span class="e Identifier"><span class="i">virtual_begin</span></span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">virtual_begin</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span> 
        }</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">virtual_begin</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span> 
            &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">needle</span></span>[<span class="e Minus"><span class="e Identifier"><span class="i">virtual_begin</span></span> - <span class="e Int"><span class="n">1</span></span></span>]</span> == <span class="e Index"><span class="e Identifier"><span class="i">needle</span></span>[<span class="e Minus"><span class="e Minus"><span class="e Dollar">$</span> - <span class="e Identifier"><span class="i">portion</span></span></span> - <span class="e Int"><span class="n">1</span></span></span>]</span></span></span>)
            <span class="s Return"><span class="k">return</span> <span class="e Int"><span class="n">0</span></span>;</span></span>
        
        <span class="d StorageClass"><span class="k">invariant</span> <span class="d Variables"><span class="i">delta</span> = <span class="e Minus"><span class="e Identifier"><span class="i">portion</span></span> - <span class="e Identifier"><span class="i">ignore</span></span></span>;</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">equal</span></span>(<span class="i">range</span>(<span class="i">end</span>(<span class="i">needle</span>) - <span class="i">delta</span>, <span class="i">end</span>(<span class="i">needle</span>)),
                     <span class="i">range</span>(<span class="i">begin</span>(<span class="i">needle</span>) + <span class="i">virtual_begin</span>,
                           <span class="i">begin</span>(<span class="i">needle</span>) + <span class="i">virtual_begin</span> + <span class="i">delta</span>))</span>;</span>
    }</span></span></span></span></span></span>

<span class="d Protection"><span class="k">public</span>:
    <span class="d Compound"><span class="d StorageClass"><span class="k">static</span> <span class="d Function"><span class="t Identifier"><span class="i">BoyerMooreFinder</span></span> <span class="i">opCall</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">needle</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">BoyerMooreFinder</span></span> <span class="i">result</span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Dot"><span class="e Not">!<span class="e Identifier"><span class="i">needle</span></span></span>.<span class="e Identifier"><span class="i">length</span></span></span>) <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Dot"><span class="e Identifier"><span class="i">result</span></span>.<span class="e Identifier"><span class="i">needle</span></span></span> = <span class="e Identifier"><span class="i">needle</span></span></span>;</span>
        <span class="bc">/* Populate table with the analysis of the needle */</span>
        <span class="bc">/* But ignoring the last letter */</span>
        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span>, <span class="o Parameter"><span class="i">n</span></span></span> ; <span class="e Slice"><span class="e Identifier"><span class="i">needle</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Minus"><span class="e Dollar">$</span> - <span class="e Int"><span class="n">1</span></span></span>]</span>)
        <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Dot"><span class="e Identifier"><span class="i">result</span></span>.<span class="e Identifier"><span class="i">occ</span></span></span>[<span class="e Identifier"><span class="i">n</span></span>]</span> = <span class="e Identifier"><span class="i">i</span></span></span>;</span>
        }</span></span>
        <span class="bc">/* Preprocess #2: init skip[] */</span>  
        <span class="bc">/* Note: This step could be made a lot faster.
         * A simple implementation is shown here. */</span>
        <span class="s Expression"><span class="e Assign"><span class="e Dot"><span class="e Identifier"><span class="i">result</span></span>.<span class="e Identifier"><span class="i">skip</span></span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">size_t</span></span><span class="t Array">[<span class="t Qualified"><span class="t Identifier"><span class="i">needle</span></span>.<span class="t Identifier"><span class="i">length</span></span></span>]</span></span></span>;</span>
        <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">a</span></span></span>; <span class="e Int"><span class="n">0</span></span> .. <span class="e Dot"><span class="e Identifier"><span class="i">needle</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
        <span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">value</span> = <span class="e Int"><span class="n">0</span></span>;</span></span>
            <span class="s While"><span class="k">while</span> (<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">value</span></span> &lt; <span class="e Dot"><span class="e Identifier"><span class="i">needle</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span> 
                   &amp;&amp; <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">needlematch</span></span></span>(<span class="i">needle</span>, <span class="i">a</span>, <span class="i">value</span>)</span></span>)
            <span class="s Compound">{
                <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">value</span></span></span>;</span>
            }</span></span>
            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Dot"><span class="e Identifier"><span class="i">result</span></span>.<span class="e Identifier"><span class="i">skip</span></span></span>[<span class="e Minus"><span class="e Minus"><span class="e Dot"><span class="e Identifier"><span class="i">needle</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> - <span class="e Identifier"><span class="i">a</span></span></span> - <span class="e Int"><span class="n">1</span></span></span>]</span> = <span class="e Identifier"><span class="i">value</span></span></span>;</span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
    }</span></span></span></span>

    <span class="d Function"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range</span></span></span>)</span> <span class="i">inspect</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">haystack</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Dot"><span class="e Not">!<span class="e Identifier"><span class="i">needle</span></span></span>.<span class="e Identifier"><span class="i">length</span></span></span>) <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">haystack</span>)</span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Dot"><span class="e Identifier"><span class="i">needle</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> &gt; <span class="e Dot"><span class="e Identifier"><span class="i">haystack</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span>) <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">haystack</span>)</span>;</span></span>
        <span class="bc">/* Search: */</span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">limit</span> = <span class="e Minus"><span class="e Dot"><span class="e Identifier"><span class="i">haystack</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> - <span class="e Dot"><span class="e Identifier"><span class="i">needle</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span>;</span></span>
        <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">hpos</span> = <span class="e Int"><span class="n">0</span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">hpos</span></span> &lt;= <span class="e Identifier"><span class="i">limit</span></span></span>; )
        <span class="s Compound">{
            <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">npos</span> = <span class="e Minus"><span class="e Dot"><span class="e Identifier"><span class="i">needle</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> - <span class="e Int"><span class="n">1</span></span></span>;</span></span>
            <span class="s While"><span class="k">while</span> (<span class="e Call"><span class="e Identifier"><span class="i">pred</span></span>(<span class="i">needle</span>[<span class="i">npos</span>], <span class="i">haystack</span>[<span class="i">npos</span>+<span class="i">hpos</span>])</span>)
            <span class="s Compound">{
                <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">npos</span></span> == <span class="e Int"><span class="n">0</span></span></span>) <span class="s Return"><span class="k">return</span> <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">haystack</span>)</span> + <span class="e Identifier"><span class="i">hpos</span></span></span>;</span></span>
                <span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">npos</span></span></span>;</span>
            }</span></span>
            <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">hpos</span></span> += <span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">skip</span>[<span class="i">npos</span>], <span class="i">npos</span> - <span class="i">occurrence</span>(<span class="i">haystack</span>[<span class="i">npos</span>+<span class="i">hpos</span>]))</span></span>;</span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">haystack</span>)</span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">length</span><span class="o Parameters">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Dot"><span class="e Identifier"><span class="i">needle</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>;</span>
    }</span></span></span></span></span></span></span>
}</span></span></span></span></span>

<span class="bc">/**
Finds the first occurrence of $(D subseq) in $(D seq) by using the
$(WEB www-igm.univ-mlv.fr/~lecroq/string/node14.html, Boyer-Moore
algorithm).  The algorithm has an upfront cost but scales sublinearly,
so it is most suitable for large sequences. Performs $(BIGOH
seq.length) evaluations of $(D pred) in the worst case and $(BIGOH
seq.length / subseq.length) evaluations in the best case.

Example:
----
int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
int[] b = [ 1, 2, 3 ];
assert(findBoyerMoore(a, b) == begin(a) + 2);
assert(findBoyerMoore(b, a) == end(b));
----

BUGS:

Should cache the scaffolding built for the last $(D subseq) in
thread-safe storage so it is not rebuilt repeatedly.
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range</span></span></span>)</span> <span class="i">findBoyerMoore</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span> = <span class="sl">"a == b"</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span>
    <span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">seq</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">subseq</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Dot"><span class="e Call"><span class="e TemplateInstance"><span class="i">BoyerMooreFinder</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span>, <span class="t Identifier"><span class="i">Range</span></span></span>)</span>(<span class="i">subseq</span>)</span>.<span class="e Identifier"><span class="i">inspect</span></span></span>(<span class="i">seq</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">string</span></span> <span class="i">h</span> = <span class="e String"><span class="sl">"/homes/aalexand/d/dmd/bin/../lib/libphobos.a(dmain2.o)"</span>
        <span class="sl">"(.gnu.linkonce.tmain+0x74): In function `main' undefined reference"</span>
        <span class="sl">" to `_Dmain':"</span></span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">string</span></span><span class="t Array">[]</span> <span class="i">ns</span> = <span class="e ArrayInit">[<span class="e String"><span class="sl">"libphobos"</span></span>, <span class="e String"><span class="sl">"function"</span></span>, <span class="e String"><span class="sl">" undefined"</span></span>, <span class="e String"><span class="sl">"`"</span></span>, <span class="e String"><span class="sl">":"</span></span>]</span>;</span></span>
    <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">n</span></span></span> ; <span class="e Identifier"><span class="i">ns</span></span>) <span class="s Compound">{
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">p</span> = <span class="e Call"><span class="e Identifier"><span class="i">findBoyerMoore</span></span>(<span class="i">h</span>, <span class="i">n</span>)</span>;</span></span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">p</span></span> != <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">h</span>)</span></span> &amp;&amp; <span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">range</span></span>(<span class="i">p</span>, <span class="i">p</span> + <span class="i">n</span>.<span class="i">length</span>)</span> == <span class="e Identifier"><span class="i">n</span></span></span></span>)</span>;</span>
    }</span></span>

    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Sign">-<span class="e Int"><span class="n">1</span></span></span>, <span class="e Int"><span class="n">0</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span> ]</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">b</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">findBoyerMoore</span></span>(<span class="i">a</span>, <span class="i">b</span>)</span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">a</span>)</span> + <span class="e Int"><span class="n">2</span></span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">findBoyerMoore</span></span>(<span class="i">b</span>, <span class="i">a</span>)</span> == <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">b</span>)</span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// findAdjacent</span>
<span class="bc">/**
Finds the first two adjacent elements $(D a), $(D b) in the range $(D
r) that satisfy $(D pred(a, b)). Performs $(BIGOH r.length)
evaluations of $(D pred). See also $(WEB
sgi.com/tech/stl/adjacent_find.html, STL's adjacent_find).

Example:
----
int[] a = [ 11, 10, 10, 9, 8, 8, 7, 8, 9 ];
auto p = findAdjacent(a);
assert(p == begin(a) + 1);
p = findAdjacent!("a &lt; b")(a);
assert(p == begin(a) + 6);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range</span></span></span>)</span> <span class="i">findAdjacent</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span> = <span class="sl">"a == b"</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">first</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span>, <span class="i">last</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">next</span> = <span class="e Identifier"><span class="i">first</span></span>;</span></span>
    <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">first</span></span> != <span class="e Identifier"><span class="i">last</span></span></span>)
    <span class="s Compound">{
        <span class="s For"><span class="k">for</span> (<span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">next</span></span></span>;</span> <span class="e Equal"><span class="e Identifier"><span class="i">next</span></span> != <span class="e Identifier"><span class="i">last</span></span></span>; <span class="e Comma"><span class="e PreIncr">++<span class="e Identifier"><span class="i">first</span></span></span>, <span class="e PreIncr">++<span class="e Identifier"><span class="i">next</span></span></span></span>)
            <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span>(*<span class="i">first</span>, *<span class="i">next</span>)</span>) <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">first</span></span>;</span></span></span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">last</span></span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">11</span></span>, <span class="e Int"><span class="n">10</span></span>, <span class="e Int"><span class="n">10</span></span>, <span class="e Int"><span class="n">9</span></span>, <span class="e Int"><span class="n">8</span></span>, <span class="e Int"><span class="n">8</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">8</span></span>, <span class="e Int"><span class="n">9</span></span> ]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">p</span> = <span class="e Call"><span class="e Identifier"><span class="i">findAdjacent</span></span>(<span class="i">a</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">p</span></span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">a</span>)</span> + <span class="e Int"><span class="n">1</span></span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">p</span></span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">findAdjacent</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &lt; b"</span></span></span>)</span>(<span class="i">a</span>)</span></span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">p</span></span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">a</span>)</span> + <span class="e Int"><span class="n">6</span></span></span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// findAmong</span>
<span class="bc">/**
Finds the first element in $(D seq) that compares equal (according to
$(D pred)) with some element in $(D choices). Choices are sought by
linear search. Performs $(BIGOH seq.length * choices.length)
evaluations of $(D pred). See also $(WEB
sgi.com/tech/stl/find_first_of.html, STL's find_first_of).

Example:
----
int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
int[] b = [ 3, 1, 2 ];
assert(findAmong(a, b) == begin(a) + 2);
assert(findAmong(b, a) == begin(b));
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range1</span></span></span>)</span> <span class="i">findAmong</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span> = <span class="sl">"a == b"</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range1</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range2</span></span>)</span><span class="o Parameters">(
    <span class="o Parameter"><span class="t Identifier"><span class="i">Range1</span></span> <span class="i">seq</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">choices</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span>, <span class="o Parameter"><span class="i">e</span></span></span>; <span class="e Identifier"><span class="i">seq</span></span>)
    <span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">find</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span>(<span class="i">choices</span>, <span class="i">e</span>)</span> != <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">choices</span>)</span></span>) <span class="s Return"><span class="k">return</span> <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">seq</span>)</span> + <span class="e Identifier"><span class="i">i</span></span></span>;</span></span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">seq</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Sign">-<span class="e Int"><span class="n">1</span></span></span>, <span class="e Int"><span class="n">0</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span> ]</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">b</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">findAmong</span></span>(<span class="i">a</span>, <span class="i">b</span>)</span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">a</span>)</span> + <span class="e Int"><span class="n">2</span></span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">findAmong</span></span>(<span class="i">b</span>, [ <span class="n">4</span>, <span class="n">6</span>, <span class="n">7</span> ])</span> == <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">b</span>)</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">findAmong</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a==b"</span></span></span>)</span>(<span class="i">a</span>, <span class="i">b</span>)</span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">a</span>)</span> + <span class="e Int"><span class="n">2</span></span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">findAmong</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a==b"</span></span></span>)</span>(<span class="i">b</span>, [ <span class="n">4</span>, <span class="n">6</span>, <span class="n">7</span> ])</span> == <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">b</span>)</span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// findAmongSorted</span>
<span class="bc">/**
Finds the first element $(D x) in $(D seq) that compares equal with
some element $(D y) in $(D choices) (meaning $(D !less(x, y) &amp;&amp;
!less(y, x))). The $(D choices) range is sought by binary
search. Consequently $(D choices) is assumed to be sorted according to
$(D pred), which by default is $(D "a &lt; b"). Performs $(BIGOH
seq.length * log(choices.length)) evaluations of $(D less).

To find the last element of $(D seq) instead of the first, call $(D
findAmongSorted(retro(seq), choices)) and compare the result against
$(D rEnd(seq)). See also $(XREF iterator, retro).

Example:
----
int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
int[] b = [ 1, 2, 3 ];
assert(findAmongSorted(a, b) == begin(a) + 2);
assert(findAmongSorted(b, a) == end(b));
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range1</span></span></span>)</span> <span class="i">findAmongSorted</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span> = <span class="sl">"a &lt; b"</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range1</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range2</span></span>)</span><span class="o Parameters">(
    <span class="o Parameter"><span class="t Identifier"><span class="i">Range1</span></span> <span class="i">seq</span></span>, <span class="o Parameter"><span class="k">in</span> <span class="t Identifier"><span class="i">Range2</span></span> <span class="i">choices</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span> <span class="i">lessFun</span>;</span></span></span> <span class="lc">// pun not intended</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isSorted</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">lessFun</span></span></span>)</span>(<span class="i">choices</span>)</span>)</span>;</span>
    <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span>, <span class="o Parameter"><span class="i">e</span></span></span>; <span class="e Identifier"><span class="i">seq</span></span>)
    <span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e TemplateInstance"><span class="i">canFindSorted</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">lessFun</span></span></span>)</span>(<span class="i">choices</span>, <span class="i">e</span>)</span>) <span class="s Return"><span class="k">return</span> <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">seq</span>)</span> + <span class="e Identifier"><span class="i">i</span></span></span>;</span></span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">seq</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Sign">-<span class="e Int"><span class="n">1</span></span></span>, <span class="e Int"><span class="n">0</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span> ]</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">b</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">findAmongSorted</span></span>(<span class="i">a</span>, <span class="i">b</span>)</span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">a</span>)</span> + <span class="e Int"><span class="n">2</span></span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">findAmongSorted</span></span>(<span class="i">b</span>, [ <span class="n">4</span>, <span class="n">6</span>, <span class="n">7</span> ])</span> == <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">b</span>)</span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// canFind</span>
<span class="bc">/**
Convenience functions returning $(D true) if and only if the
corresponding $(D find*) functions return an iterator different from
$(D end(r)). They are handy in the numerous situations when the
success of the $(D find*) functions is queried but the actual position
found is unimportant.

Example:
----
int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
assert(canFind(a, 4));
assert(!canFind(a, 10));
assert(canFind!("a - 1 &lt; b")(a, 4));
assert(!canFind!("a &gt; 5")(a));
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">canFind</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span> = <span class="sl">"a == b"</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>, <span class="o TemplateTypeParameter"><span class="i">E</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">haystack</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">E</span></span> <span class="i">needle</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Return"><span class="k">return</span> <span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">find</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span>(<span class="i">haystack</span>, <span class="i">needle</span>)</span> != <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">haystack</span>)</span></span>;</span>
}</span></span></span></span></span>

<span class="lc">/// Ditto</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">canFind</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">haystack</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Return"><span class="k">return</span> <span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">find</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span>(<span class="i">haystack</span>)</span> != <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">haystack</span>)</span></span>;</span>
}</span></span></span></span></span>

<span class="lc">/// Ditto</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">canFindAmong</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range1</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range2</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range1</span></span> <span class="i">seq</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">choices</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Return"><span class="k">return</span> <span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">findAmong</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span>(<span class="i">seq</span>, <span class="i">choices</span>)</span> != <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">seq</span>)</span></span>;</span>
}</span></span></span></span></span>

<span class="lc">/// Ditto</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">canFindAmongSorted</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range1</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range2</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range1</span></span> <span class="i">seq</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">choices</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Return"><span class="k">return</span> <span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">findAmongSorted</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span>(<span class="i">seq</span>, <span class="i">choices</span>)</span> != <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">seq</span>)</span></span>;</span>
}</span></span></span></span></span>

<span class="lc">// count</span>
<span class="bc">/**
Counts the number of elements $(D x) in $(D r) for which $(D pred(x,
value)) is $(D true). $(D pred) defaults to equality. Performs $(BIGOH
r.length) evaluations of $(D pred).

Example:
----
int[] a = [ 1, 2, 4, 3, 2, 5, 3, 2, 4 ];
assert(count(a, 2) == 3);
assert(count!("a &gt; b")(a, 2) == 5);
----
*/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">count</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span> = <span class="sl">"a == b"</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>, <span class="o TemplateTypeParameter"><span class="i">E</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">E</span></span> <span class="i">value</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">pred2</span><span class="o Parameters">(<span class="o Parameter"><span class="t Typeof"><span class="k">typeof</span>(<span class="e Call"><span class="e Deref">*<span class="e Identifier"><span class="i">begin</span></span></span>(<span class="i">r</span>)</span>)</span> <span class="i">a</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span>(<span class="i">a</span>, <span class="i">value</span>)</span>;</span> }</span></span></span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TemplateInstance"><span class="i">count</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred2</span></span></span>)</span>(<span class="i">r</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">4</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">count</span></span>(<span class="i">a</span>, <span class="n">2</span>)</span> == <span class="e Int"><span class="n">3</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">count</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &gt; b"</span></span></span>)</span>(<span class="i">a</span>, <span class="n">2</span>)</span> == <span class="e Int"><span class="n">5</span></span></span>)</span>;</span>
}</span></span></span>

<span class="bc">/**
Counts the number of elements $(D x) in $(D r) for which $(D pred(x))
is $(D true). Performs $(BIGOH r.length) evaluations of $(D pred).

Example:
----
int[] a = [ 1, 2, 4, 3, 2, 5, 3, 2, 4 ];
assert(count!("a &gt; 1")(a) == 8);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">count</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">result</span>;</span></span>
    <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span> .. <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span>)
    <span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e TemplateInstance"><span class="i">unaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span>(*<span class="i">i</span>)</span>) <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">result</span></span></span>;</span></span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">4</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">count</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a == 3"</span></span></span>)</span>(<span class="i">a</span>)</span> == <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// equal</span>
<span class="bc">/**
Returns $(D true) if and only if the two ranges compare equal element
for element, according to binary predicate $(D pred). The ranges may
have different element types, as long as $(D pred(a, b)) evaluates to
$(D bool) for $(D a) in $(D r1) and $(D b) in $(D r2). Performs
$(BIGOH min(r1.length, r2.length)) evaluations of $(D pred). See also
$(WEB sgi.com/tech/stl/_equal.html, STL's equal).

Example:
----
int[] a = [ 1, 2, 4, 3 ];
assert(!equal(a, a[1..$]));
assert(equal(a, a));

// different types
double[] b = [ 1., 2, 4, 3];
assert(!equal(a, b[1..$]));
assert(equal(a, b));

// predicated: ensure that two vectors are approximately equal
double[] c = [ 1.005, 2, 4, 3];
assert(equal!(approxEqual)(b, c));
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">equal</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span> = <span class="sl">"a == b"</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range1</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range2</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range1</span></span> <span class="i">r1</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">r2</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">r1</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> != <span class="e Dot"><span class="e Identifier"><span class="i">r2</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span>) <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">result</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">mismatch</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span>(<span class="i">r1</span>, <span class="i">r2</span>)</span>;</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e AndAnd"><span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">result</span></span>.<span class="e Identifier"><span class="i">_0</span></span></span> == <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r1</span>)</span></span> &amp;&amp; <span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">result</span></span>.<span class="e Identifier"><span class="i">_1</span></span></span> == <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r2</span>)</span></span></span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">3</span></span>]</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">equal</span></span></span>(<span class="i">a</span>, <span class="i">a</span>[<span class="n">1</span>..$])</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">equal</span></span>(<span class="i">a</span>, <span class="i">a</span>)</span>)</span>;</span>
    <span class="lc">// test with different types</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">double</span></span><span class="t Array">[]</span> <span class="i">b</span> = <span class="e ArrayInit">[ <span class="e Real"><span class="n">1.</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">3</span></span>]</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">equal</span></span></span>(<span class="i">a</span>, <span class="i">b</span>[<span class="n">1</span>..$])</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">equal</span></span>(<span class="i">a</span>, <span class="i">b</span>)</span>)</span>;</span>

    <span class="lc">// predicated</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">double</span></span><span class="t Array">[]</span> <span class="i">c</span> = <span class="e ArrayInit">[ <span class="e Real"><span class="n">1.005</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">3</span></span>]</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">equal</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">approxEqual</span></span></span>)</span>(<span class="i">b</span>, <span class="i">c</span>)</span>)</span>;</span>
}</span></span></span>

<span class="lc">// MinType</span>
<span class="d Template"><span class="k">template</span> <span class="i">MinType</span><span class="o TemplateParameters">(<span class="o TemplateTupleParameter"><span class="i">T</span>...</span>)</span>
<span class="d Compound">{
    <span class="d StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Rel"><span class="e Dot"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> &gt;= <span class="e Int"><span class="n">2</span></span></span>);</span>
    <span class="d StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> == <span class="e Int"><span class="n">2</span></span></span>)
    <span class="d Compound">{
        <span class="d StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Not">!<span class="e Is"><span class="k">is</span>(<span class="t Typeof"><span class="k">typeof</span>(<span class="e Dot"><span class="e Index"><span class="e Identifier"><span class="i">T</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>.<span class="e Identifier"><span class="i">min</span></span></span>)</span>)</span></span>)
            <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CommonType</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">0</span></span> .. <span class="e Int"><span class="n">2</span></span>]</span></span>)</span> <span class="i">MinType</span>;</span></span>
        <span class="k">else</span> <span class="d StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e TemplateInstance"><span class="i">mostNegative</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">1</span></span>]</span></span>)</span> &lt; <span class="e TemplateInstance"><span class="i">mostNegative</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">0</span></span>]</span></span>)</span></span>)
            <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">1</span></span>]</span> <span class="i">MinType</span>;</span></span>
        <span class="k">else</span> <span class="d StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e TemplateInstance"><span class="i">mostNegative</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">1</span></span>]</span></span>)</span> &gt; <span class="e TemplateInstance"><span class="i">mostNegative</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">0</span></span>]</span></span>)</span></span>)
            <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">0</span></span>]</span> <span class="i">MinType</span>;</span></span>
        <span class="k">else</span> <span class="d StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Dot"><span class="e Index"><span class="e Identifier"><span class="i">T</span></span>[<span class="e Int"><span class="n">1</span></span>]</span>.<span class="e Identifier"><span class="i">max</span></span></span> &lt; <span class="e Dot"><span class="e Index"><span class="e Identifier"><span class="i">T</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>.<span class="e Identifier"><span class="i">max</span></span></span></span>)
            <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">1</span></span>]</span> <span class="i">MinType</span>;</span></span>
        <span class="k">else</span>
            <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">0</span></span>]</span> <span class="i">MinType</span>;</span></span></span></span></span></span>
    }</span>
    <span class="k">else</span>
    <span class="d Compound">{
        <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">MinType</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">MinType</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">0</span></span> .. <span class="e Int"><span class="n">2</span></span>]</span></span>)</span>, <span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">2</span></span> .. <span class="e Dollar">$</span>]</span></span>)</span> <span class="i">MinType</span>;</span></span>
    }</span></span>
}</span></span>

<span class="lc">// min</span>
<span class="bc">/**
Returns the minimum of the passed-in values. The type of the result is
computed by using $(XREF traits, CommonType).
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">MinType</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T1</span></span>, <span class="t Identifier"><span class="i">T2</span></span>, <span class="t Identifier"><span class="i">T</span></span></span>)</span> <span class="i">min</span><span class="o TemplateParameters">(<span class="o TemplateTypeParameter"><span class="i">T1</span></span>, <span class="o TemplateTypeParameter"><span class="i">T2</span></span>, <span class="o TemplateTupleParameter"><span class="i">T</span>...</span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T1</span></span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">T2</span></span> <span class="i">b</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">xs</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> == <span class="e Int"><span class="n">0</span></span></span>)
    <span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e AndAnd"><span class="e AndAnd"><span class="e TemplateInstance"><span class="i">isIntegral</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T1</span></span></span>)</span> &amp;&amp; <span class="e TemplateInstance"><span class="i">isIntegral</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T2</span></span></span>)</span></span>
                   &amp;&amp; <span class="e Equal"><span class="e Paren">(<span class="e Rel"><span class="e TemplateInstance"><span class="i">mostNegative</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T1</span></span></span>)</span> &lt; <span class="e Int"><span class="n">0</span></span></span>)</span> != <span class="e Paren">(<span class="e Rel"><span class="e TemplateInstance"><span class="i">mostNegative</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T2</span></span></span>)</span> &lt; <span class="e Int"><span class="n">0</span></span></span>)</span></span></span>)
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e TemplateInstance"><span class="i">mostNegative</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T1</span></span></span>)</span> &lt; <span class="e Int"><span class="n">0</span></span></span>)
                <span class="d StorageClass"><span class="k">invariant</span> <span class="d Variables"><span class="i">chooseB</span> = <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">b</span></span> &lt; <span class="e Identifier"><span class="i">a</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">a</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span></span>;</span></span>
            <span class="k">else</span>
                <span class="d StorageClass"><span class="k">invariant</span> <span class="d Variables"><span class="i">chooseB</span> = <span class="e OrOr"><span class="e Rel"><span class="e Identifier"><span class="i">b</span></span> &lt; <span class="e Identifier"><span class="i">a</span></span></span> || <span class="e Rel"><span class="e Identifier"><span class="i">b</span></span> &lt; <span class="e Int"><span class="n">0</span></span></span></span>;</span></span></span>
        <span class="k">else</span>
                <span class="d StorageClass"><span class="k">invariant</span> <span class="d Variables"><span class="i">chooseB</span> = <span class="e Rel"><span class="e Identifier"><span class="i">b</span></span> &lt; <span class="e Identifier"><span class="i">a</span></span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Typeof"><span class="k">typeof</span>(<span class="k">return</span>)</span>) <span class="e Paren">(<span class="e Cond"><span class="e Identifier"><span class="i">chooseB</span></span> ? <span class="e Identifier"><span class="i">b</span></span> : <span class="e Identifier"><span class="i">a</span></span></span>)</span></span>;</span>
    }</span>
    <span class="k">else</span>
    <span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">min</span></span>(<span class="i">min</span>(<span class="i">a</span>, <span class="i">b</span>), <span class="i">xs</span>)</span>;</span>
    }</span></span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">a</span> = <span class="e Int"><span class="n">5</span></span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">short</span></span> <span class="i">b</span> = <span class="e Int"><span class="n">6</span></span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">double</span></span> <span class="i">c</span> = <span class="e Int"><span class="n">2</span></span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">d</span> = <span class="e Call"><span class="e Identifier"><span class="i">min</span></span>(<span class="i">a</span>, <span class="i">b</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Is"><span class="k">is</span>(<span class="t Typeof"><span class="k">typeof</span>(<span class="e Identifier"><span class="i">d</span></span>)</span> == <span class="t Integral"><span class="k">int</span></span>)</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">d</span></span> == <span class="e Int"><span class="n">5</span></span></span>)</span>;</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">e</span> = <span class="e Call"><span class="e Identifier"><span class="i">min</span></span>(<span class="i">a</span>, <span class="i">b</span>, <span class="i">c</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Is"><span class="k">is</span>(<span class="t Typeof"><span class="k">typeof</span>(<span class="e Identifier"><span class="i">e</span></span>)</span> == <span class="t Integral"><span class="k">double</span></span>)</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">e</span></span> == <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
    <span class="lc">// mixed signedness test</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">a</span></span> = <span class="e Sign">-<span class="e Int"><span class="n">10</span></span></span></span>;</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">f</span> = <span class="e Int"><span class="n">10</span></span>;</span></span>
    <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Is"><span class="k">is</span>(<span class="t Typeof"><span class="k">typeof</span>(<span class="e Call"><span class="e Identifier"><span class="i">min</span></span>(<span class="i">a</span>, <span class="i">f</span>)</span>)</span> == <span class="t Integral"><span class="k">int</span></span>)</span>);</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">min</span></span>(<span class="i">a</span>, <span class="i">f</span>)</span> == <span class="e Sign">-<span class="e Int"><span class="n">10</span></span></span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// MaxType</span>
<span class="d Template"><span class="k">template</span> <span class="i">MaxType</span><span class="o TemplateParameters">(<span class="o TemplateTupleParameter"><span class="i">T</span>...</span>)</span>
<span class="d Compound">{
    <span class="d StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Rel"><span class="e Dot"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> &gt;= <span class="e Int"><span class="n">2</span></span></span>);</span>
    <span class="d StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> == <span class="e Int"><span class="n">2</span></span></span>)
    <span class="d Compound">{
        <span class="d StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Not">!<span class="e Is"><span class="k">is</span>(<span class="t Typeof"><span class="k">typeof</span>(<span class="e Dot"><span class="e Index"><span class="e Identifier"><span class="i">T</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>.<span class="e Identifier"><span class="i">min</span></span></span>)</span>)</span></span>)
            <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">CommonType</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">0</span></span> .. <span class="e Int"><span class="n">2</span></span>]</span></span>)</span> <span class="i">MaxType</span>;</span></span>
        <span class="k">else</span> <span class="d StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Dot"><span class="e Index"><span class="e Identifier"><span class="i">T</span></span>[<span class="e Int"><span class="n">1</span></span>]</span>.<span class="e Identifier"><span class="i">max</span></span></span> &gt; <span class="e Dot"><span class="e Index"><span class="e Identifier"><span class="i">T</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>.<span class="e Identifier"><span class="i">max</span></span></span></span>)
            <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">1</span></span>]</span> <span class="i">MaxType</span>;</span></span>
        <span class="k">else</span> 
            <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">0</span></span>]</span> <span class="i">MaxType</span>;</span></span></span></span>
    }</span>
    <span class="k">else</span>
    <span class="d Compound">{
        <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">MaxType</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">MaxType</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">0</span></span>]</span>, <span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">1</span></span>]</span></span>)</span>, <span class="t Identifier"><span class="i">T</span></span><span class="t Array">[<span class="e Int"><span class="n">2</span></span> .. <span class="e Dollar">$</span>]</span></span>)</span> <span class="i">MaxType</span>;</span></span>
    }</span></span>
}</span></span>

<span class="lc">// max</span>
<span class="bc">/**
Returns the maximum of the passed-in values. The type of the result is
computed by using $(XREF traits, CommonType).

Example:
----
int a = 5;
short b = 6;
double c = 2;
auto d = max(a, b);
assert(is(typeof(d) == int));
assert(d == 6);
auto e = min(a, b, c);
assert(is(typeof(e) == double));
assert(e == 2);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">MaxType</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T1</span></span>, <span class="t Identifier"><span class="i">T2</span></span>, <span class="t Identifier"><span class="i">T</span></span></span>)</span> <span class="i">max</span><span class="o TemplateParameters">(<span class="o TemplateTypeParameter"><span class="i">T1</span></span>, <span class="o TemplateTypeParameter"><span class="i">T2</span></span>, <span class="o TemplateTupleParameter"><span class="i">T</span>...</span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T1</span></span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">T2</span></span> <span class="i">b</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">xs</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">T</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> == <span class="e Int"><span class="n">0</span></span></span>)
    <span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e AndAnd"><span class="e AndAnd"><span class="e TemplateInstance"><span class="i">isIntegral</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T1</span></span></span>)</span> &amp;&amp; <span class="e TemplateInstance"><span class="i">isIntegral</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T2</span></span></span>)</span></span>
                   &amp;&amp; <span class="e Equal"><span class="e Paren">(<span class="e Rel"><span class="e TemplateInstance"><span class="i">mostNegative</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T1</span></span></span>)</span> &lt; <span class="e Int"><span class="n">0</span></span></span>)</span> != <span class="e Paren">(<span class="e Rel"><span class="e TemplateInstance"><span class="i">mostNegative</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T2</span></span></span>)</span> &lt; <span class="e Int"><span class="n">0</span></span></span>)</span></span></span>)
            <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e TemplateInstance"><span class="i">mostNegative</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">T1</span></span></span>)</span> &lt; <span class="e Int"><span class="n">0</span></span></span>)
                <span class="d StorageClass"><span class="k">invariant</span> <span class="d Variables"><span class="i">chooseB</span> = <span class="e OrOr"><span class="e Rel"><span class="e Identifier"><span class="i">b</span></span> &gt; <span class="e Identifier"><span class="i">a</span></span></span> || <span class="e Rel"><span class="e Identifier"><span class="i">a</span></span> &lt; <span class="e Int"><span class="n">0</span></span></span></span>;</span></span>
            <span class="k">else</span>
                <span class="d StorageClass"><span class="k">invariant</span> <span class="d Variables"><span class="i">chooseB</span> = <span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">b</span></span> &gt; <span class="e Identifier"><span class="i">a</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">b</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span></span>;</span></span></span>
        <span class="k">else</span>
            <span class="d StorageClass"><span class="k">invariant</span> <span class="d Variables"><span class="i">chooseB</span> = <span class="e Rel"><span class="e Identifier"><span class="i">b</span></span> &gt; <span class="e Identifier"><span class="i">a</span></span></span>;</span></span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Cast"><span class="k">cast</span>(<span class="t Typeof"><span class="k">typeof</span>(<span class="k">return</span>)</span>) <span class="e Paren">(<span class="e Cond"><span class="e Identifier"><span class="i">chooseB</span></span> ? <span class="e Identifier"><span class="i">b</span></span> : <span class="e Identifier"><span class="i">a</span></span></span>)</span></span>;</span>
    }</span>
    <span class="k">else</span>
    <span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">max</span>(<span class="i">a</span>, <span class="i">b</span>), <span class="i">xs</span>)</span>;</span>
    }</span></span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">a</span> = <span class="e Int"><span class="n">5</span></span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">short</span></span> <span class="i">b</span> = <span class="e Int"><span class="n">6</span></span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">double</span></span> <span class="i">c</span> = <span class="e Int"><span class="n">2</span></span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">d</span> = <span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">a</span>, <span class="i">b</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Is"><span class="k">is</span>(<span class="t Typeof"><span class="k">typeof</span>(<span class="e Identifier"><span class="i">d</span></span>)</span> == <span class="t Integral"><span class="k">int</span></span>)</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">d</span></span> == <span class="e Int"><span class="n">6</span></span></span>)</span>;</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">e</span> = <span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">a</span>, <span class="i">b</span>, <span class="i">c</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Is"><span class="k">is</span>(<span class="t Typeof"><span class="k">typeof</span>(<span class="e Identifier"><span class="i">e</span></span>)</span> == <span class="t Integral"><span class="k">double</span></span>)</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">e</span></span> == <span class="e Int"><span class="n">6</span></span></span>)</span>;</span>
    <span class="lc">// mixed sign</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">a</span></span> = <span class="e Sign">-<span class="e Int"><span class="n">5</span></span></span></span>;</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">f</span> = <span class="e Int"><span class="n">5</span></span>;</span></span>
    <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Is"><span class="k">is</span>(<span class="t Typeof"><span class="k">typeof</span>(<span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">a</span>, <span class="i">f</span>)</span>)</span> == <span class="t Integral"><span class="k">uint</span></span>)</span>);</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">max</span></span>(<span class="i">a</span>, <span class="i">f</span>)</span> == <span class="e Int"><span class="n">5</span></span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// mismatch</span>
<span class="bc">/**
Sequentially compares elements in $(D r1) and $(D r2) in lockstep, and
stops at the first mismatch (according to $(D pred), by default
equality). Returns a tuple with the iterators that refer to the two
mismatched values. Performs $(BIGOH min(r1.length, r2.length))
evaluations of $(D pred). See also $(WEB
sgi.com/tech/stl/_mismatch.html, STL's mismatch).

Example:
----
int[]    x = [ 1,  5, 2, 7,   4, 3 ];
double[] y = [ 1., 5, 2, 7.3, 4, 8 ];
auto m = mismatch(x, y);
assert(m._0 == begin(x) + 3);
assert(m._1 == begin(y) + 3);
----
*/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">Tuple</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range1</span></span></span>)</span>, <span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range2</span></span></span>)</span></span>)</span>
<span class="i">mismatch</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span> = <span class="sl">"a == b"</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range1</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range2</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range1</span></span> <span class="i">r1</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">r2</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">i1</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r1</span>)</span>, <span class="i">i2</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r2</span>)</span>, <span class="i">e1</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r1</span>)</span>, <span class="i">e2</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r2</span>)</span>;</span></span>
    <span class="s For"><span class="k">for</span> (; <span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">i1</span></span> != <span class="e Identifier"><span class="i">e1</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">i2</span></span> != <span class="e Identifier"><span class="i">e2</span></span></span></span>; <span class="e Comma"><span class="e PreIncr">++<span class="e Identifier"><span class="i">i1</span></span></span>, <span class="e PreIncr">++<span class="e Identifier"><span class="i">i2</span></span></span></span>)
    <span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Not">!<span class="e TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span></span>(*<span class="i">i1</span>, *<span class="i">i2</span>)</span>) <span class="s Break"><span class="k">break</span>;</span></span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">tuple</span></span>(<span class="i">i1</span>, <span class="i">i2</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="lc">// doc example</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span>    <span class="i">x</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>,  <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">7</span></span>,   <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">3</span></span> ]</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">double</span></span><span class="t Array">[]</span> <span class="i">y</span> = <span class="e ArrayInit">[ <span class="e Real"><span class="n">1.</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Real"><span class="n">7.3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">8</span></span> ]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">m</span> = <span class="e Call"><span class="e Identifier"><span class="i">mismatch</span></span>(<span class="i">x</span>, <span class="i">y</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">_0</span></span></span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">x</span>)</span> + <span class="e Int"><span class="n">3</span></span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">m</span></span>.<span class="e Identifier"><span class="i">_1</span></span></span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">y</span>)</span> + <span class="e Int"><span class="n">3</span></span></span></span>)</span>;</span>

    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span> ]</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">b</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span> ]</span>;</span></span>    
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">mm</span> = <span class="e Call"><span class="e Identifier"><span class="i">mismatch</span></span>(<span class="i">a</span>, <span class="i">b</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">mm</span></span>.<span class="e Identifier"><span class="i">_0</span></span></span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">a</span>)</span> + <span class="e Int"><span class="n">2</span></span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">mm</span></span>.<span class="e Identifier"><span class="i">_1</span></span></span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">b</span>)</span> + <span class="e Int"><span class="n">2</span></span></span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// levenshteinDistance</span>
<span class="bc">/**
Encodes $(WEB realityinteractive.com/rgrzywinski/archives/000249.html,
edit operations) necessary to transform one sequence into
another. Given sequences $(D s) (source) and $(D t) (target), a
sequence of $(D EditOp) encodes the steps that need to be taken to
convert $(D s) into $(D t). For example, if $(D s = "cat") and $(D
"cars"), the minimal sequence that transforms $(D s) into $(D t) is:
skip two characters, replace 't' with 'r', and insert an 's'. Working
with edit operations is useful in applications such as spell-checkers
(to find the closest word to a given misspelled word), approximate
searches, diff-style programs that compute the difference between
files, efficient encoding of patches, DNA sequence analysis, and
plagiarism detection.
*/</span>

<span class="d Enum"><span class="k">enum</span> <span class="i">EditOp</span> : <span class="t Integral"><span class="k">char</span></span>
{
    <span class="bc">/** Current items are equal; no editing is necessary. */</span>
    <span class="d EnumMember"><span class="i">none</span> = <span class="e Char"><span class="cl">'n'</span></span></span>,
    <span class="bc">/** Substitute current item in target with current item in source. */</span>
    <span class="d EnumMember"><span class="i">substitute</span> = <span class="e Char"><span class="cl">'s'</span></span></span>,
    <span class="bc">/** Insert current item from the source into the target. */</span>
    <span class="d EnumMember"><span class="i">insert</span> = <span class="e Char"><span class="cl">'i'</span></span></span>,
    <span class="bc">/** Remove current item from the target. */</span>
    <span class="d EnumMember"><span class="i">remove</span> = <span class="e Char"><span class="cl">'r'</span></span></span>
}</span>

<span class="d Template"><span class="d Compound"><span class="d Struct"><span class="k">struct</span> <span class="i">Levenshtein</span><span class="o TemplateParameters">(<span class="o TemplateTypeParameter"><span class="i">Range</span></span>, <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">equals</span></span>, <span class="o TemplateTypeParameter"><span class="i">CostType</span> = <span class="t Identifier"><span class="i">size_t</span></span></span>)</span>
<span class="d Compound">{
    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">deletionIncrement</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">CostType</span></span> <span class="i">n</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">_deletionIncrement</span></span> = <span class="e Identifier"><span class="i">n</span></span></span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">InitMatrix</span></span>()</span>;</span>
    }</span></span></span>
    
    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">insertionIncrement</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">CostType</span></span> <span class="i">n</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">_insertionIncrement</span></span> = <span class="e Identifier"><span class="i">n</span></span></span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">InitMatrix</span></span>()</span>;</span>
    }</span></span></span>
    
    <span class="d Function"><span class="t Identifier"><span class="i">CostType</span></span> <span class="i">distance</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">s</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">t</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">AllocMatrix</span></span>(<span class="i">s</span>.<span class="i">length</span> + <span class="n">1</span>, <span class="i">t</span>.<span class="i">length</span> + <span class="n">1</span>)</span>;</span>
        <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span></span>; <span class="e Int"><span class="n">1</span></span> .. <span class="e Identifier"><span class="i">rows</span></span>)
        <span class="s Compound">{
            <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">j</span></span></span>; <span class="e Int"><span class="n">1</span></span> .. <span class="e Identifier"><span class="i">cols</span></span>)
            <span class="s Compound">{
                <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">cSub</span> = <span class="e Plus"><span class="e Index"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Minus"><span class="e Identifier"><span class="i">i</span></span> - <span class="e Int"><span class="n">1</span></span></span>]</span>[<span class="e Minus"><span class="e Identifier"><span class="i">j</span></span> - <span class="e Int"><span class="n">1</span></span></span>]</span> 
                    + <span class="e Paren">(<span class="e Cond"><span class="e Call"><span class="e Identifier"><span class="i">equals</span></span>(<span class="i">s</span>[<span class="i">i</span> - <span class="n">1</span>], <span class="i">t</span>[<span class="i">j</span> - <span class="n">1</span>])</span> ? <span class="e Int"><span class="n">0</span></span> : <span class="e Identifier"><span class="i">_substitutionIncrement</span></span></span>)</span></span>;</span></span>
                <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">cIns</span> = <span class="e Plus"><span class="e Index"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>[<span class="e Minus"><span class="e Identifier"><span class="i">j</span></span> - <span class="e Int"><span class="n">1</span></span></span>]</span> + <span class="e Identifier"><span class="i">_insertionIncrement</span></span></span>;</span></span>
                <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">cDel</span> = <span class="e Plus"><span class="e Index"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Minus"><span class="e Identifier"><span class="i">i</span></span> - <span class="e Int"><span class="n">1</span></span></span>]</span>[<span class="e Identifier"><span class="i">j</span></span>]</span> + <span class="e Identifier"><span class="i">_deletionIncrement</span></span></span>;</span></span>
                <span class="s Switch"><span class="k">switch</span> (<span class="e Call"><span class="e Identifier"><span class="i">min_index</span></span>(<span class="i">cSub</span>, <span class="i">cIns</span>, <span class="i">cDel</span>)</span>) <span class="s Compound">{
                <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">0</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>[<span class="e Identifier"><span class="i">j</span></span>]</span> = <span class="e Identifier"><span class="i">cSub</span></span></span>;</span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">1</span></span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>[<span class="e Identifier"><span class="i">j</span></span>]</span> = <span class="e Identifier"><span class="i">cIns</span></span></span>;</span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                <span class="s Default"><span class="k">default</span>:
                    <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>[<span class="e Identifier"><span class="i">j</span></span>]</span> = <span class="e Identifier"><span class="i">cDel</span></span></span>;</span>
                    <span class="s Break"><span class="k">break</span>;</span></span></span></span>
                }</span></span>
            }</span></span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Index"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Dot"><span class="e Identifier"><span class="i">s</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>]</span>[<span class="e Dot"><span class="e Identifier"><span class="i">t</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>]</span>;</span>
    }</span></span></span>
  
    <span class="d Function"><span class="t Identifier"><span class="i">EditOp</span></span><span class="t Array">[]</span> <span class="i">path</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">s</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">t</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">distance</span></span>(<span class="i">s</span>, <span class="i">t</span>)</span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">path</span></span>()</span>;</span>
    }</span></span></span>

    <span class="d Function"><span class="t Identifier"><span class="i">EditOp</span></span><span class="t Array">[]</span> <span class="i">path</span><span class="o Parameters">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">EditOp</span></span><span class="t Array">[]</span> <span class="i">result</span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">i</span> = <span class="e Minus"><span class="e Identifier"><span class="i">rows</span></span> - <span class="e Int"><span class="n">1</span></span></span>, <span class="i">j</span> = <span class="e Minus"><span class="e Identifier"><span class="i">cols</span></span> - <span class="e Int"><span class="n">1</span></span></span>;</span></span>
        <span class="lc">// restore the path</span>
        <span class="s While"><span class="k">while</span> (<span class="e OrOr"><span class="e Identifier"><span class="i">i</span></span> || <span class="e Identifier"><span class="i">j</span></span></span>) <span class="s Compound">{
            <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">cIns</span> = <span class="e Cond"><span class="e Equal"><span class="e Identifier"><span class="i">j</span></span> == <span class="e Int"><span class="n">0</span></span></span> ? <span class="e Dot"><span class="e Identifier"><span class="i">CostType</span></span>.<span class="e Identifier"><span class="i">max</span></span></span> : <span class="e Index"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>[<span class="e Minus"><span class="e Identifier"><span class="i">j</span></span> - <span class="e Int"><span class="n">1</span></span></span>]</span></span>;</span></span>
            <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">cDel</span> = <span class="e Cond"><span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> == <span class="e Int"><span class="n">0</span></span></span> ? <span class="e Dot"><span class="e Identifier"><span class="i">CostType</span></span>.<span class="e Identifier"><span class="i">max</span></span></span> : <span class="e Index"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Minus"><span class="e Identifier"><span class="i">i</span></span> - <span class="e Int"><span class="n">1</span></span></span>]</span>[<span class="e Identifier"><span class="i">j</span></span>]</span></span>;</span></span>
            <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">cSub</span> = <span class="e Cond"><span class="e OrOr"><span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> == <span class="e Int"><span class="n">0</span></span></span> || <span class="e Equal"><span class="e Identifier"><span class="i">j</span></span> == <span class="e Int"><span class="n">0</span></span></span></span> 
                ? <span class="e Dot"><span class="e Identifier"><span class="i">CostType</span></span>.<span class="e Identifier"><span class="i">max</span></span></span> 
                : <span class="e Index"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Minus"><span class="e Identifier"><span class="i">i</span></span> - <span class="e Int"><span class="n">1</span></span></span>]</span>[<span class="e Minus"><span class="e Identifier"><span class="i">j</span></span> - <span class="e Int"><span class="n">1</span></span></span>]</span></span>;</span></span>
            <span class="s Switch"><span class="k">switch</span> (<span class="e Call"><span class="e Identifier"><span class="i">min_index</span></span>(<span class="i">cSub</span>, <span class="i">cIns</span>, <span class="i">cDel</span>)</span>) <span class="s Compound">{
            <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">0</span></span>:
                <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">result</span></span> ~= <span class="e Cond"><span class="e Equal"><span class="e Index"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Minus"><span class="e Identifier"><span class="i">i</span></span> - <span class="e Int"><span class="n">1</span></span></span>]</span>[<span class="e Minus"><span class="e Identifier"><span class="i">j</span></span> - <span class="e Int"><span class="n">1</span></span></span>]</span> == <span class="e Index"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span>[<span class="e Identifier"><span class="i">j</span></span>]</span></span>
                    ? <span class="e Dot"><span class="e Identifier"><span class="i">EditOp</span></span>.<span class="e Identifier"><span class="i">none</span></span></span>
                    : <span class="e Dot"><span class="e Identifier"><span class="i">EditOp</span></span>.<span class="e Identifier"><span class="i">substitute</span></span></span></span></span>;</span>
                <span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">i</span></span></span>;</span>
                <span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">j</span></span></span>;</span>
                <span class="s Break"><span class="k">break</span>;</span></span></span></span>
            <span class="s Case"><span class="k">case</span> <span class="e Int"><span class="n">1</span></span>:
                <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">result</span></span> ~= <span class="e Dot"><span class="e Identifier"><span class="i">EditOp</span></span>.<span class="e Identifier"><span class="i">insert</span></span></span></span>;</span>
                <span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">j</span></span></span>;</span>
                <span class="s Break"><span class="k">break</span>;</span></span></span></span>
            <span class="s Default"><span class="k">default</span>:
                <span class="s Scope"><span class="s Compound"><span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">result</span></span> ~= <span class="e Dot"><span class="e Identifier"><span class="i">EditOp</span></span>.<span class="e Identifier"><span class="i">remove</span></span></span></span>;</span>
                <span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">i</span></span></span>;</span>
                <span class="s Break"><span class="k">break</span>;</span></span></span></span>
            }</span></span>
        }</span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">reverse</span></span>(<span class="i">result</span>)</span>;</span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
    }</span></span></span>
    
<span class="d Protection"><span class="k">private</span>:
    <span class="d Compound"><span class="d Variables"><span class="t Identifier"><span class="i">CostType</span></span> <span class="i">_deletionIncrement</span> = <span class="e Int"><span class="n">1</span></span>,
        <span class="i">_insertionIncrement</span> = <span class="e Int"><span class="n">1</span></span>,
        <span class="i">_substitutionIncrement</span> = <span class="e Int"><span class="n">1</span></span>;</span>
    <span class="d Variables"><span class="t Identifier"><span class="i">CostType</span></span><span class="t Array">[]</span><span class="t Array">[]</span> <span class="i">_matrix</span>;</span>
    <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">rows</span>, <span class="i">cols</span>;</span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">AllocMatrix</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">uint</span></span> <span class="i">r</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">uint</span></span> <span class="i">c</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">rows</span></span> = <span class="e Identifier"><span class="i">r</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">cols</span></span> = <span class="e Identifier"><span class="i">c</span></span></span>;</span>
        <span class="s If"><span class="k">if</span> (<span class="e OrOr"><span class="e OrOr"><span class="e Not">!<span class="e Identifier"><span class="i">_matrix</span></span></span> || <span class="e Rel"><span class="e Dot"><span class="e Identifier"><span class="i">_matrix</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> &lt; <span class="e Identifier"><span class="i">r</span></span></span></span> || <span class="e Rel"><span class="e Dot"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>.<span class="e Identifier"><span class="i">length</span></span></span> &lt; <span class="e Identifier"><span class="i">c</span></span></span></span>) <span class="s Compound">{
            <span class="s Expression"><span class="e Delete"><span class="k">delete</span> <span class="e Identifier"><span class="i">_matrix</span></span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">_matrix</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">CostType</span></span><span class="t Array">[]</span><span class="t Array">[]</span>(<span class="e Identifier"><span class="i">r</span></span>, <span class="e Identifier"><span class="i">c</span></span>)</span></span>;</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">InitMatrix</span></span>()</span>;</span>
        }</span></span>
    }</span></span></span>

    <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">InitMatrix</span><span class="o Parameters">()</span> <span class="s FuncBody"><span class="s Compound">{
        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span>, <span class="o Parameter"><span class="i">row</span></span></span>; <span class="e Identifier"><span class="i">_matrix</span></span>) <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">row</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> = <span class="e Mul"><span class="e Identifier"><span class="i">i</span></span> * <span class="e Identifier"><span class="i">_deletionIncrement</span></span></span></span>;</span>
        }</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Not">!<span class="e Identifier"><span class="i">_matrix</span></span></span>) <span class="s Return"><span class="k">return</span>;</span></span>
        <span class="s For"><span class="k">for</span> (<span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">i</span> = <span class="e Int"><span class="n">0u</span></span>;</span></span> <span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> != <span class="e Dot"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>.<span class="e Identifier"><span class="i">length</span></span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>) <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Index"><span class="e Identifier"><span class="i">_matrix</span></span>[<span class="e Int"><span class="n">0</span></span>]</span>[<span class="e Identifier"><span class="i">i</span></span>]</span> = <span class="e Mul"><span class="e Identifier"><span class="i">i</span></span> * <span class="e Identifier"><span class="i">_insertionIncrement</span></span></span></span>;</span>
        }</span></span>
    }</span></span></span>

    <span class="d StorageClass"><span class="k">static</span> <span class="d Function"><span class="t Integral"><span class="k">uint</span></span> <span class="i">min_index</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">CostType</span></span> <span class="i">i0</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">CostType</span></span> <span class="i">i1</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">CostType</span></span> <span class="i">i2</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">i0</span></span> &lt;= <span class="e Identifier"><span class="i">i1</span></span></span>)
        <span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Cond"><span class="e Rel"><span class="e Identifier"><span class="i">i0</span></span> &lt;= <span class="e Identifier"><span class="i">i2</span></span></span> ? <span class="e Int"><span class="n">0</span></span> : <span class="e Int"><span class="n">2</span></span></span>;</span>
        }</span>
        <span class="k">else</span>
        <span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Cond"><span class="e Rel"><span class="e Identifier"><span class="i">i1</span></span> &lt;= <span class="e Identifier"><span class="i">i2</span></span></span> ? <span class="e Int"><span class="n">1</span></span> : <span class="e Int"><span class="n">2</span></span></span>;</span>
        }</span></span>
    }</span></span></span></span></span></span>
}</span></span></span></span>

<span class="bc">/**
Returns the $(WEB wikipedia.org/wiki/Levenshtein_distance, Levenshtein
distance) between $(D s) and $(D t). The Levenshtein distance computes
the minimal amount of edit operations necessary to transform $(D s)
into $(D t).  Performs $(BIGOH s.length * t.length) evaluations of $(D
equals) and occupies $(BIGOH s.length * t.length) storage.

Example:
----
assert(levenshteinDistance("cat", "rat") == 1);
assert(levenshteinDistance("parks", "spark") == 2);
assert(levenshteinDistance("kitten", "sitting") == 3);
// ignore case
assert(levenshteinDistance!("toupper(a) == toupper(b)")
    ("parks", "SPARK") == 2);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">levenshteinDistance</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">equals</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range1</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range2</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range1</span></span> <span class="i">s</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">t</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">Levenshtein</span>!(<span class="o TemplateArguments"><span class="t Typeof"><span class="k">typeof</span>(<span class="e Call"><span class="e Identifier"><span class="i">range</span></span>(<span class="i">begin</span>(<span class="i">s</span>), <span class="i">end</span>(<span class="i">s</span>))</span>)</span>, <span class="t Identifier"><span class="i">equals</span></span>, <span class="t Integral"><span class="k">uint</span></span></span>)</span> <span class="i">lev</span>;</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Dot"><span class="e Identifier"><span class="i">lev</span></span>.<span class="e Identifier"><span class="i">distance</span></span></span>(<span class="i">s</span>, <span class="i">t</span>)</span>;</span>
}</span></span></span></span></span>

<span class="lc">/// Ditto</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">levenshteinDistance</span><span class="o TemplateParameters">(<span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">string</span></span> <span class="i">equals</span> = <span class="e String"><span class="sl">"a == b"</span></span></span>, <span class="o TemplateTypeParameter"><span class="i">Range1</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range2</span></span>)</span><span class="o Parameters">(
    <span class="o Parameter"><span class="t Identifier"><span class="i">Range1</span></span> <span class="i">s</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">t</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TemplateInstance"><span class="i">levenshteinDistance</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">equals</span></span></span>)</span>, <span class="t Identifier"><span class="i">Range1</span></span>, <span class="t Identifier"><span class="i">Range2</span></span></span>)</span>(<span class="i">s</span>, <span class="i">t</span>)</span>;</span>
}</span></span></span></span></span>

<span class="bc">/**
Returns the Levenshtein distance and the edit path between $(D s) and
$(D t).

Example:
---
string a = "Saturday", b = "Sunday";
auto p = levenshteinDistanceAndPath(a, b);
assert(p._0, 3);
assert(equals(p._1, "nrrnsnnn"));
---
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">Tuple</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">size_t</span></span>, <span class="t Identifier"><span class="i">EditOp</span></span><span class="t Array">[]</span></span>)</span>
<span class="i">levenshteinDistanceAndPath</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">equals</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range1</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range2</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range1</span></span> <span class="i">s</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">t</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t TemplateInstance"><span class="i">Levenshtein</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range</span></span>, <span class="t Identifier"><span class="i">equals</span></span></span>)</span> <span class="i">lev</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">d</span> = <span class="e Call"><span class="e Dot"><span class="e Identifier"><span class="i">lev</span></span>.<span class="e Identifier"><span class="i">distance</span></span></span>(<span class="i">s</span>, <span class="i">t</span>)</span>;</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">tuple</span></span>(<span class="i">d</span>, <span class="i">lev</span>.<span class="i">path</span>)</span>;</span>
}</span></span></span></span></span>

<span class="lc">/// Ditto</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">Tuple</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">size_t</span></span>, <span class="t Identifier"><span class="i">EditOp</span></span><span class="t Array">[]</span></span>)</span>
<span class="i">levenshteinDistanceAndPath</span><span class="o TemplateParameters">(<span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">string</span></span> <span class="i">equals</span> = <span class="e String"><span class="sl">"a == b"</span></span></span>,
                           <span class="o TemplateTypeParameter"><span class="i">Range1</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range2</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range1</span></span> <span class="i">s</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">t</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TemplateInstance"><span class="i">levenshteinDistanceAndPath</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">equals</span></span></span>)</span>, <span class="t Identifier"><span class="i">Range1</span></span>, <span class="t Identifier"><span class="i">Range2</span></span></span>)</span>(
        <span class="i">s</span>, <span class="i">t</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">levenshteinDistance</span></span>(<span class="sl">"a"</span>, <span class="sl">"a"</span>)</span> == <span class="e Int"><span class="n">0</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">levenshteinDistance</span></span>(<span class="sl">"a"</span>, <span class="sl">"b"</span>)</span> == <span class="e Int"><span class="n">1</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">levenshteinDistance</span></span>(<span class="sl">"aa"</span>, <span class="sl">"ab"</span>)</span> == <span class="e Int"><span class="n">1</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">levenshteinDistance</span></span>(<span class="sl">"aa"</span>, <span class="sl">"abc"</span>)</span> == <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">levenshteinDistance</span></span>(<span class="sl">"Saturday"</span>, <span class="sl">"Sunday"</span>)</span> == <span class="e Int"><span class="n">3</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e Identifier"><span class="i">levenshteinDistance</span></span>(<span class="sl">"kitten"</span>, <span class="sl">"sitting"</span>)</span> == <span class="e Int"><span class="n">3</span></span></span>)</span>;</span>
    <span class="lc">//lev.deletionIncrement = 2;</span>
    <span class="lc">//lev.insertionIncrement = 100;</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">string</span></span> <span class="i">a</span> = <span class="e String"><span class="sl">"Saturday"</span></span>, <span class="i">b</span> = <span class="e String"><span class="sl">"Sunday"</span></span>;</span></span>
    <span class="lc">// @@@BUG@@@</span>
    <span class="lc">//auto p = levenshteinDistanceAndPath(a, b);</span>
    <span class="lc">//writefln(p);</span>
    <span class="lc">//assert(cast(string) p._1 == "nrrnsnnn", cast(string) p);</span>
}</span></span></span>

<span class="lc">// copy</span>
<span class="bc">/**
Copies the content of $(D source) into $(D target) and returns the
remaining (unfilled) part of $(D target). See also $(WEB
sgi.com/tech/stl/_copy.html, STL's copy). If a behavior similar to
$(WEB sgi.com/tech/stl/copy_backward.html, STL's copy_backward) is
needed, use $(D copy(retro(source), retro(target))). See also $(XREF
iterator, retro).

Example:
----
int[] a = [ 1, 5 ];
int[] b = [ 9, 8 ];
int[] c = new int[a.length + b.length + 10];
auto d = copy(b, copy(a, c));
assert(c[0 .. a.length + b.length] == a ~ b);
assert(d.length == 10);
----

As long as the target range elements support assignment from source
range elements, different types of ranges are accepted.

Example:
----
float[] a = [ 1.0f, 5 ];
double[] b = new double[a.length];
auto d = copy(a, b);
----
*/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">copy</span><span class="o TemplateParameters">(<span class="o TemplateTypeParameter"><span class="i">Range1</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range2</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range1</span></span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">target</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">t</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">target</span>)</span>, <span class="i">te</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">target</span>)</span>;</span></span>
    <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">s</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">source</span>)</span> .. <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">source</span>)</span>)
    <span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">t</span></span> == <span class="e Identifier"><span class="i">te</span></span></span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">enforce</span></span>(<span class="k">false</span>,
                             <span class="sl">"copy: insufficient space in target range"</span>)</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">t</span></span></span> = <span class="e Deref">*<span class="e Identifier"><span class="i">s</span></span></span></span>;</span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">t</span></span></span>;</span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">range</span></span>(<span class="i">t</span>, <span class="i">te</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">5</span></span> ]</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">b</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">9</span></span>, <span class="e Int"><span class="n">8</span></span> ]</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">c</span> = <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">int</span></span><span class="t Array">[<span class="e Plus"><span class="e Plus"><span class="e Dot"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> + <span class="e Dot"><span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span> + <span class="e Int"><span class="n">10</span></span></span>]</span></span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">d</span> = <span class="e Call"><span class="e Identifier"><span class="i">copy</span></span>(<span class="i">b</span>, <span class="i">copy</span>(<span class="i">a</span>, <span class="i">c</span>))</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Slice"><span class="e Identifier"><span class="i">c</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Plus"><span class="e Dot"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> + <span class="e Dot"><span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span>]</span> == <span class="e Cat"><span class="e Identifier"><span class="i">a</span></span> ~ <span class="e Identifier"><span class="i">b</span></span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">d</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> == <span class="e Int"><span class="n">10</span></span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// copyIf</span>
<span class="bc">/**
Copies in increasing order the elements $(D x) of $(D source)
satisfying $(D pred(x)) into $(D target) and returns the remaining
(unfilled) part of $(D target). See also $(WEB
sgi.com/tech/stl/copy_if.html, STL's copy_if).

Example:
----
int[] a = [ 1, 5, 8, 9, 10, 1, 2, 0 ];
auto b = new int[a.length];
auto c = copyIf!("(a &amp; 1) == 1")(a, b);
assert(b[0 .. $ - c.length] == [ 1, 5, 9, 1 ]);
----

As long as the target range elements support assignment from source
range elements, different types of ranges are accepted.

Example:
----
float[] a = [ 1.0f, 5, -3, -5, 0, 4, -3 ];
double[] b = new double[a.length];
auto d = copyIf!("a &gt; 0")(a, b);
assert(a == [ 1.0f, 5, 0, 4 ]);
----
*/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">copyIf</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range1</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range2</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range1</span></span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">target</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="lc">//static assert(false, "Not yet implemented due to bugs in the compiler");</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">t</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">target</span>)</span>, <span class="i">te</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">target</span>)</span>;</span></span>
    <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">s</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">source</span>)</span> .. <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">source</span>)</span>)
    <span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Not">!<span class="e TemplateInstance"><span class="i">unaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span></span>(*<span class="i">s</span>)</span>) <span class="s Continue"><span class="k">continue</span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">t</span></span> == <span class="e Identifier"><span class="i">te</span></span></span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">enforce</span></span>(<span class="k">false</span>,
                             <span class="sl">"copyIf: insufficient space in target range"</span>)</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">t</span></span></span> = <span class="e Deref">*<span class="e Identifier"><span class="i">s</span></span></span></span>;</span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">t</span></span></span>;</span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">range</span></span>(<span class="i">t</span>, <span class="i">te</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">5</span></span> ]</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">b</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">9</span></span>, <span class="e Int"><span class="n">8</span></span> ]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">e</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">copyIf</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &gt; 1"</span></span></span>)</span>(<span class="i">a</span>, <span class="i">b</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">b</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e Int"><span class="n">5</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Dot"><span class="e Identifier"><span class="i">e</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> == <span class="e Int"><span class="n">1</span></span></span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// iterSwap</span>
<span class="bc">/**
Swaps $(D *lhs) and $(D *rhs).

Preconditions:
Same as for $(D swap(*lhs, *rhs)).
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">iterSwap</span><span class="o TemplateParameters">(<span class="o TemplateTypeParameter"><span class="i">It</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">It</span></span> <span class="i">lhs</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">It</span></span> <span class="i">rhs</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">pointsTo</span></span></span>(*<span class="i">lhs</span>, *<span class="i">lhs</span>)</span>, <span class="e Dot"><span class="e Identifier"><span class="i">It</span></span>.<span class="e Identifier"><span class="i">stringof</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">swap</span></span>(*<span class="i">lhs</span>, *<span class="i">rhs</span>)</span>;</span>
}</span></span></span></span></span>

<span class="lc">// swapRanges</span>
<span class="bc">/**
Swaps all elements of $(D r1) with successive elements in $(D r2)
using $(D iterSwap) as a primitive. $(D r1) must contain less or the
same number of elements as $(D r2); an exception will be thrown
otherwise. Returns the tail portion of $(D r2) that was not swapped.

Example:
----
int[] a = [ 100, 101, 102, 103 ];
int[] b = [ 0, 1, 2, 3 ];
auto c = swapRanges(a[1 .. 2], b[2 .. 3]);
assert(!c.length);
assert(a == [ 100, 2, 3, 103 ]);
assert(b == [ 0, 1, 101, 102 ]);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">Range2</span></span> <span class="i">swapRanges</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>, <span class="o TemplateTypeParameter"><span class="i">Range1</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range2</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">r1</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">r2</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">enforce</span></span>(<span class="i">r1</span>.<span class="i">length</span> &lt;= <span class="i">r2</span>.<span class="i">length</span>,
        <span class="sl">"swapRanges: too short range in the second position"</span>)</span>;</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">t</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r2</span>)</span>;</span></span>
    <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">s</span></span></span>; <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r1</span>)</span> .. <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r1</span>)</span>)
    <span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">t</span>, <span class="i">s</span>)</span>;</span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">t</span></span></span>;</span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">range</span></span>(<span class="i">t</span>, <span class="i">end</span>(<span class="i">r2</span>))</span>;</span>
}</span></span></span></span></span>

<span class="lc">// reverse</span>
<span class="bc">/**
Reverses $(D r) in-place.  Performs $(D r.length) evaluations of $(D
iterSwap). See also $(WEB sgi.com/tech/stl/_reverse.html, STL's
reverse).

Example:
----
int[] arr = [ 1, 2, 3 ];
reverse(arr);
assert(arr == [ 3, 2, 1 ]);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">reverse</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">b</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span>, <span class="i">e</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">b</span></span> &lt;= <span class="e Identifier"><span class="i">e</span></span></span>)</span>;</span>
    <span class="s For"><span class="k">for</span> (; <span class="e Equal"><span class="e Identifier"><span class="i">b</span></span> != <span class="e Identifier"><span class="i">e</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">b</span></span></span>)
    <span class="s Compound">{
        <span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">e</span></span></span>;</span>
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">b</span></span> == <span class="e Identifier"><span class="i">e</span></span></span>) <span class="s Break"><span class="k">break</span>;</span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">b</span>, <span class="i">e</span>)</span>;</span>
    }</span></span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">range</span> = <span class="e Null"><span class="k">null</span></span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">reverse</span></span>(<span class="i">range</span>)</span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">range</span></span> = <span class="e ArrayLiteral">[ <span class="n">1</span> ]</span></span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">reverse</span></span>(<span class="i">range</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">range</span></span> == <span class="e ArrayLiteral">[<span class="n">1</span>]</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">range</span></span> = <span class="e ArrayLiteral">[<span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>]</span></span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">reverse</span></span>(<span class="i">range</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">range</span></span> == <span class="e ArrayLiteral">[<span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">1</span></span>]</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">range</span></span> = <span class="e ArrayLiteral">[<span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>]</span></span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">reverse</span></span>(<span class="i">range</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">range</span></span> == <span class="e ArrayLiteral">[<span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">1</span></span>]</span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// rotate</span>
<span class="bc">/**
Rotates the range $(D r = [first, last$(RPAREN)) such that the slice
$(D [middle, last$(RPAREN)) gets moved in front of the slice $(D
[first, middle$(RPAREN)). Performs $(BIGOH r.length) evaluations of
$(D iterSwap). See also $(WEB sgi.com/tech/stl/_rotate.html, STL's
rotate).

Preconditions:

$(D first &lt;= middle &amp;&amp; middle &lt;= last);

Returns:

The position in which $(D first) has been rotated.

Example:

----
auto arr = [4, 5, 6, 7, 1, 2, 3];
auto p = rotate(arr, begin(arr) + 4);
assert(p - begin(arr) == 3);
assert(arr == [ 1, 2, 3, 4, 5, 6, 7 ]);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">It</span></span> <span class="i">rotate</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>, <span class="o TemplateTypeParameter"><span class="i">It</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">It</span></span> <span class="i">middle</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">first</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span>, <span class="i">last</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span>;</span></span>
    <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">first</span></span> == <span class="e Identifier"><span class="i">middle</span></span></span>) <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">last</span></span>;</span></span>
    <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">last</span></span> == <span class="e Identifier"><span class="i">middle</span></span></span>) <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">first</span></span>;</span></span>

    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">first2</span> = <span class="e Identifier"><span class="i">middle</span></span>;</span></span>
    <span class="s DoWhile"><span class="k">do</span>
    <span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">first</span>, <span class="i">first2</span>)</span>;</span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">first</span></span></span>;</span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">first2</span></span></span>;</span>
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">first</span></span> == <span class="e Identifier"><span class="i">middle</span></span></span>)
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">middle</span></span> = <span class="e Identifier"><span class="i">first2</span></span></span>;</span></span>
    }</span>
    <span class="k">while</span> (<span class="e Equal"><span class="e Identifier"><span class="i">first2</span></span> != <span class="e Identifier"><span class="i">last</span></span></span>)</span><span class="s Empty">;</span>

    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">newMiddle</span> = <span class="e Identifier"><span class="i">first</span></span>;</span></span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first2</span></span> = <span class="e Identifier"><span class="i">middle</span></span></span>;</span>

    <span class="s While"><span class="k">while</span> (<span class="e Equal"><span class="e Identifier"><span class="i">first2</span></span> != <span class="e Identifier"><span class="i">last</span></span></span>) <span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">first</span>, <span class="i">first2</span>)</span>;</span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">first</span></span></span>;</span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">first2</span></span></span>;</span>
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">first</span></span> == <span class="e Identifier"><span class="i">middle</span></span></span>)
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">middle</span></span> = <span class="e Identifier"><span class="i">first2</span></span></span>;</span>
        <span class="k">else</span> <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">first2</span></span> == <span class="e Identifier"><span class="i">last</span></span></span>)
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first2</span></span> = <span class="e Identifier"><span class="i">middle</span></span></span>;</span></span></span>
    }</span></span>

    <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">newMiddle</span></span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="lc">// doc example</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">arr</span> = <span class="e ArrayInit">[<span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">p</span> = <span class="e Call"><span class="e Identifier"><span class="i">rotate</span></span>(<span class="i">arr</span>, <span class="i">arr</span>.<span class="i">ptr</span> + <span class="n">4</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Minus"><span class="e Identifier"><span class="i">p</span></span> - <span class="e Dot"><span class="e Identifier"><span class="i">arr</span></span>.<span class="e Identifier"><span class="i">ptr</span></span></span></span> == <span class="e Int"><span class="n">3</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">arr</span></span> == <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">7</span></span> ]</span></span>)</span>;</span>

    <span class="lc">// The signature taking range and mid</span>
    <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">arr</span></span>[]</span> = <span class="e ArrayLiteral">[<span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>]</span></span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">p</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">rotate</span></span>(<span class="i">arr</span>, <span class="i">arr</span>.<span class="i">ptr</span> + <span class="n">4</span>)</span></span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Minus"><span class="e Identifier"><span class="i">p</span></span> - <span class="e Dot"><span class="e Identifier"><span class="i">arr</span></span>.<span class="e Identifier"><span class="i">ptr</span></span></span></span> == <span class="e Int"><span class="n">3</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">arr</span></span> == <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">7</span></span> ]</span></span>)</span>;</span>

    <span class="lc">// a more elaborate test</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">rnd</span> = <span class="e Call"><span class="e Identifier"><span class="i">Random</span></span>(<span class="i">unpredictableSeed</span>)</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">int</span></span><span class="t Array">[<span class="e Call"><span class="e TemplateInstance"><span class="i">uniform</span>!(<span class="o TemplateArguments"><span class="t Integral"><span class="k">int</span></span></span>)</span>(<span class="i">rnd</span>, <span class="n">100</span>, <span class="n">200</span>)</span>]</span></span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">b</span> = <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">int</span></span><span class="t Array">[<span class="e Call"><span class="e TemplateInstance"><span class="i">uniform</span>!(<span class="o TemplateArguments"><span class="t Integral"><span class="k">int</span></span></span>)</span>(<span class="i">rnd</span>, <span class="n">100</span>, <span class="n">200</span>)</span>]</span></span>;</span></span>
    <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="k">ref</span> <span class="i">e</span></span></span>; <span class="e Identifier"><span class="i">a</span></span>) <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">e</span></span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">uniform</span>!(<span class="o TemplateArguments"><span class="t Integral"><span class="k">int</span></span></span>)</span>(<span class="i">rnd</span>, -<span class="n">100</span>, <span class="n">100</span>)</span></span>;</span></span>
    <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="k">ref</span> <span class="i">e</span></span></span>; <span class="e Identifier"><span class="i">b</span></span>) <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">e</span></span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">uniform</span>!(<span class="o TemplateArguments"><span class="t Integral"><span class="k">int</span></span></span>)</span>(<span class="i">rnd</span>, -<span class="n">100</span>, <span class="n">100</span>)</span></span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">c</span> = <span class="e Cat"><span class="e Identifier"><span class="i">a</span></span> ~ <span class="e Identifier"><span class="i">b</span></span></span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">n</span> = <span class="e Call"><span class="e Identifier"><span class="i">rotate</span></span>(<span class="i">c</span>, <span class="i">c</span>.<span class="i">ptr</span> + <span class="i">a</span>.<span class="i">length</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">n</span></span> == <span class="e Plus"><span class="e Dot"><span class="e Identifier"><span class="i">c</span></span>.<span class="e Identifier"><span class="i">ptr</span></span></span> + <span class="e Dot"><span class="e Identifier"><span class="i">b</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">c</span></span> == <span class="e Cat"><span class="e Identifier"><span class="i">b</span></span> ~ <span class="e Identifier"><span class="i">a</span></span></span></span>)</span>;</span>

    <span class="lc">// test with custom iterSwap</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">called</span>;</span></span>
    <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">mySwap</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">int</span></span><span class="t Pointer">*</span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">int</span></span><span class="t Pointer">*</span> <span class="i">b</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">a</span>, <span class="i">b</span>)</span>;</span> <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">called</span></span> = <span class="e Bool"><span class="k">true</span></span></span>;</span> }</span></span></span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">rotate</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">mySwap</span></span></span>)</span>(<span class="i">c</span>, <span class="i">c</span>.<span class="i">ptr</span> + <span class="i">a</span>.<span class="i">length</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Identifier"><span class="i">called</span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// SwapStrategy</span>
<span class="bc">/**
Defines the swapping strategy for algorithms that need to swap
elements in a range (such as partition and sort). The strategy
concerns the swapping of elements that are not the core concern of the
algorithm. For example, consider an algorithm that sorts $(D [ "abc",
"b", "aBc" ]) according to $(D toupper(a) &lt; toupper(b)). That
algorithm might choose to swap the two equivalent strings $(D "abc")
and $(D "aBc"). That does not affect the sorting since both $(D [
"abc", "aBc", "b" ]) and $(D [ "aBc", "abc", "b" ]) are valid
outcomes.

Some situations require that the algorithm must NOT ever change the
relative ordering of equivalent elements (in the example above, only
$(D [ "abc", "aBc", "b" ]) would be the correct result). Such
algorithms are called $(B stable). If the ordering algorithm may swap
equivalent elements discretionarily, the ordering is called $(B
unstable).

Yet another class of algorithms may choose an intermediate tradeoff by
being stable only on a well-defined subrange of the range. There is no
established terminology for such behavior; this library calls it $(B
semistable).

Generally, the $(D stable) ordering strategy may be more costly in
time and/or space than the other two because it imposes additional
constraints. Similarly, $(D semistable) may be costlier than $(D
unstable). As (semi-)stability is not needed very often, the ordering
algorithms in this module parameterized by $(D SwapStrategy) all
choose $(D SwapStrategy.unstable) as the default.
*/</span>

<span class="d Enum"><span class="k">enum</span> <span class="i">SwapStrategy</span>
{
    <span class="bc">/**
       Allows freely swapping of elements as long as the output
       satisfies the algorithm's requirements.
    */</span>
    <span class="d EnumMember"><span class="i">unstable</span></span>,
    <span class="bc">/**
       In algorithms partitioning ranges in two, preserve relative
       ordering of elements only to the left of the partition point.
    */</span>
    <span class="d EnumMember"><span class="i">semistable</span></span>,
    <span class="bc">/**
       Preserve the relative ordering of elements to the largest
       extent allowed by the algorithm's requirements.
    */</span>
    <span class="d EnumMember"><span class="i">stable</span></span>,     
}</span>

<span class="lc">// eliminate</span>
<span class="bc">/**
Reduces $(D r) by overwriting all elements $(D x) that satisfy $(D
pred(x)). Returns the reduced range.

Example:
----
int[] arr = [ 1, 2, 3, 4, 5 ];
// eliminate even elements
auto r = eliminate!("(a &amp; 1) == 0")(arr);
assert(r == [ 1, 3, 5 ]);
assert(arr == [ 1, 3, 5, 4, 5 ]);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">eliminate</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span></span>,
                <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">SwapStrategy</span></span> <span class="i">ss</span> = <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">unstable</span></span></span></span>,
                <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">move</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">move</span></span></span></span>,
                <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range</span></span></span>)</span> <span class="i">It</span>;</span></span></span>
    <span class="d StorageClass"><span class="k">static</span> <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">assignIter</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">It</span></span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">It</span></span> <span class="i">b</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">move</span></span>(*<span class="i">b</span>, *<span class="i">a</span>)</span>;</span> }</span></span></span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">range</span></span>(<span class="i">begin</span>(<span class="i">r</span>), <span class="i">partition</span>!(<span class="i">not</span>!(<span class="i">pred</span>), <span class="i">ss</span>, <span class="i">assignIter</span>, <span class="i">Range</span>)(<span class="i">r</span>))</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">arr</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span> ]</span>;</span></span>
<span class="lc">// eliminate even elements</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">r</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">eliminate</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"(a &amp; 1) == 0"</span></span></span>)</span>(<span class="i">arr</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">find</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"(a &amp; 1) == 0"</span></span></span>)</span>(<span class="i">r</span>)</span> == <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span></span>)</span>;</span>
}</span></span></span>

<span class="bc">/**
Reduces $(D r) by overwriting all elements $(D x) that satisfy $(D
pred(x, v)). Returns the reduced range.

Example:
----
int[] arr = [ 1, 2, 3, 2, 4, 5, 2 ];
// keep elements different from 2
auto r = eliminate(arr, 2);
assert(r == [ 1, 3, 4, 5 ]);
assert(arr == [ 1, 3, 4, 5, 4, 5, 2  ]);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">eliminate</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span> = <span class="sl">"a == b"</span></span>,
                <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">SwapStrategy</span></span> <span class="i">ss</span> = <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">semistable</span></span></span></span>,
                <span class="o TemplateTypeParameter"><span class="i">Range</span></span>, <span class="o TemplateTypeParameter"><span class="i">Value</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Value</span></span> <span class="i">v</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range</span></span></span>)</span> <span class="i">It</span>;</span></span></span>
    <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">comp</span><span class="o Parameters">(<span class="o Parameter"><span class="t Typeof"><span class="k">typeof</span>(<span class="e Deref">*<span class="e Identifier"><span class="i">It</span></span></span>)</span> <span class="i">a</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Not">!<span class="e TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span></span>(<span class="i">a</span>, <span class="i">v</span>)</span>;</span> }</span></span></span></span>
    <span class="d StorageClass"><span class="k">static</span> <span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">assignIterB</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">It</span></span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">It</span></span> <span class="i">b</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">a</span></span></span> = <span class="e Deref">*<span class="e Identifier"><span class="i">b</span></span></span></span>;</span> }</span></span></span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">range</span></span>(<span class="i">begin</span>(<span class="i">r</span>), 
            <span class="i">partition</span>!(<span class="i">comp</span>,
                    <span class="i">ss</span>, <span class="i">assignIterB</span>, <span class="i">Range</span>)(<span class="i">r</span>))</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">arr</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">2</span></span> ]</span>;</span></span>
<span class="lc">// keep elements different from 2</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">r</span> = <span class="e Call"><span class="e Identifier"><span class="i">eliminate</span></span>(<span class="i">arr</span>, <span class="n">2</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">r</span></span> == <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span> ]</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">arr</span></span> == <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">2</span></span>  ]</span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// partition</span>
<span class="bc">/**
Partitions a range in two using $(D pred) as a predicate and $(D
iterSwap) as a primitive to swap two elements. Specifically, reorders
the range $(D r = [left, right$(RPAREN)) using $(D iterSwap) such that
all elements $(D i) for which $(D pred(i)) is $(D true) come before
all elements $(D j) for which $(D pred(j)) returns $(D false).

Performs $(BIGOH r.length) (if unstable or semistable) or $(BIGOH
r.length * log(r.length)) (if stable) evaluations of $(D less) and $(D
iterSwap). The unstable version computes the minimum possible
evaluations of $(D iterSwap) (roughly half of those performed by the
semistable version).

$(D partition) always calls $(D iterSwap(i, j)) for iterators
satisfying $(D i &lt; j &amp;&amp; !pred(*i) &amp;&amp; pred(*j)). After the call to $(D
iterSwap(i, j)), $(D partition) makes no assumption on the values of
$(D *i) and $(D *j). Therefore, $(D partition) can be used to actually
copy partitioned data to a different container or overwrite part of
the array (in fact $(D eliminate) uses $(D partition) with a custom
$(D iterSwap)).

See also STL's $(WEB sgi.com/tech/stl/_partition.html, partition) and
$(WEB sgi.com/tech/stl/stable_partition.html, stable_partition).

Returns:

An iterator $(D p) such that the following conditions are
simultaneously true:
$(OL
$(LI $(D pred(*p1)) for all $(D p1) in [$(D left),
$(D p)$(RPAREN), if any)
$(LI $(D !pred(*p2)) for all $(D p2) in [$(D p),
$(D right)$(RPAREN), if any))
If $(D ss == SwapStrategy.stable), $(D partition) preserves the
relative ordering of all elements $(D a), $(D b) in $(D r) for which
$(D pred(a) == pred(b)). If $(D ss == SwapStrategy.semistable), $(D
partition) preserves the relative ordering of all elements $(D a), $(D
b) in $(D begin(r) .. p) for which $(D pred(a) == pred(b)).

Example:

----
auto Arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
auto arr = Arr.dup;
static bool even(int a) { return (a &amp; 1) == 0; }
// Partition a such that even numbers come first
auto p = partition!(even)(arr);
// Now arr is separated in evens and odds.
// Numbers may have become shuffled due to instability
assert(p == arr.ptr + 5);
assert(count!(even)(range(begin(arr), p)) == p - begin(arr));
assert(find!(even)(range(p, end(arr))) == end(arr));

// Can also specify the predicate as a string.
// Use 'a' as the predicate argument name
arr[] = Arr[];
p = partition!(q{(a &amp; 1) == 0})(arr);
assert(p == arr.ptr + 5);

// Now for a stable partition:
arr[] = Arr[];
p = partition!(q{(a &amp; 1) == 0}, SwapStrategy.stable)(arr);
// Now arr is [2 4 6 8 10 1 3 5 7 9], and p points to 1
assert(arr == [2, 4, 6, 8, 10, 1, 3, 5, 7, 9] &amp;&amp; p == arr.ptr + 5);

// In case the predicate needs to hold its own state, use a delegate:
arr[] = Arr[];
int x = 3;
// Put stuff greater than 3 on the left
bool fun(int a) { return a &gt; x; }
p = partition!(fun, SwapStrategy.semistable)(arr);
// Now arr is [4 5 6 7 8 9 10 2 3 1] and p points to 2
assert(arr == [4, 5, 6, 7, 8, 9, 10, 2, 3, 1] &amp;&amp; p == arr.ptr + 7);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range</span></span></span>)</span> <span class="i">partition</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">predOrStr</span></span>,
                           <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">SwapStrategy</span></span> <span class="i">ss</span> = <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">unstable</span></span></span></span>,
                           <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">unaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">predOrStr</span></span></span>)</span> <span class="i">pred</span>;</span></span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Typeof"><span class="k">typeof</span>(<span class="k">return</span>)</span> <span class="i">result</span> = <span class="e VoidInit"><span class="k">void</span></span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">left</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span>, <span class="i">right</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span>;</span></span>
    <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">left</span></span> == <span class="e Identifier"><span class="i">right</span></span></span>) <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">left</span></span>;</span></span>
    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">ss</span></span> == <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">stable</span></span></span></span>)
    <span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Minus"><span class="e Identifier"><span class="i">right</span></span> - <span class="e Identifier"><span class="i">left</span></span></span> == <span class="e Int"><span class="n">1</span></span></span>)
        <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">result</span></span> = <span class="e Cond"><span class="e Call"><span class="e Identifier"><span class="i">pred</span></span>(*<span class="i">left</span>)</span> ? <span class="e Identifier"><span class="i">right</span></span> : <span class="e Identifier"><span class="i">left</span></span></span></span>;</span>
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
        }</span></span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">middle</span> = <span class="e Plus"><span class="e Identifier"><span class="i">left</span></span> + <span class="e Div"><span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">right</span></span> - <span class="e Identifier"><span class="i">left</span></span></span>)</span> / <span class="e Int"><span class="n">2</span></span></span></span>;</span></span>
        <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Qualified"><span class="t ModuleScope">.</span><span class="t TemplateInstance"><span class="i">partition</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span>, <span class="t Identifier"><span class="i">ss</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span>, <span class="t Identifier"><span class="i">Range</span></span></span>)</span></span> <span class="i">recurse</span>;</span></span></span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">lower</span> = <span class="e Call"><span class="e Identifier"><span class="i">recurse</span></span>(<span class="i">range</span>(<span class="i">left</span>, <span class="i">middle</span>))</span>;</span></span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">upper</span> = <span class="e Call"><span class="e Identifier"><span class="i">recurse</span></span>(<span class="i">range</span>(<span class="i">middle</span>, <span class="i">right</span>))</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">result</span></span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">rotate</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">iterSwap</span></span>, <span class="t Identifier"><span class="i">Range</span></span>, <span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range</span></span></span>)</span></span>)</span>(
            <span class="i">range</span>(<span class="i">lower</span>, <span class="i">upper</span>), <span class="i">middle</span>)</span></span>;</span>
    }</span>
    <span class="k">else</span> <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">ss</span></span> == <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">semistable</span></span></span></span>)
    <span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">result</span></span> = <span class="e Identifier"><span class="i">right</span></span></span>;</span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">i</span> = <span class="e Identifier"><span class="i">left</span></span>;</span></span>
        <span class="s For"><span class="k">for</span> (; <span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> != <span class="e Identifier"><span class="i">right</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>)
        <span class="s Compound">{
            <span class="lc">// skip the initial portion of "correct" elements</span>
            <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">pred</span></span>(*<span class="i">i</span>)</span>) <span class="s Continue"><span class="k">continue</span>;</span></span>
            <span class="lc">// hit the first "bad" element</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">result</span></span> = <span class="e Identifier"><span class="i">i</span></span></span>;</span>
            <span class="s For"><span class="k">for</span> (<span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>;</span> <span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> != <span class="e Identifier"><span class="i">right</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>)
            <span class="s Compound">{
                <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">pred</span></span></span>(*<span class="i">i</span>)</span>) <span class="s Continue"><span class="k">continue</span>;</span></span>
                <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">result</span>, <span class="i">i</span>)</span>;</span>
                <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">result</span></span></span>;</span>
            }</span></span>
            <span class="s Break"><span class="k">break</span>;</span>
        }</span></span>
    }</span>
    <span class="k">else</span> <span class="lc">// ss == SwapStrategy.unstable</span>
    <span class="s Compound">{
        <span class="lc">// Inspired from www.stepanovpapers.com/PAM3-partition_notes.pdf,</span>
        <span class="lc">// section "Bidirectional Partition Algorithm (Hoare)"</span>
        <span class="s For"><span class="k">for</span> (;;)
        <span class="s Compound">{
            <span class="s For"><span class="k">for</span> (;;)
            <span class="s Compound">{
                <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">left</span></span> == <span class="e Identifier"><span class="i">right</span></span></span>) <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">left</span></span>;</span></span>
                <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">pred</span></span></span>(*<span class="i">left</span>)</span>) <span class="s Break"><span class="k">break</span>;</span></span>
                <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">left</span></span></span>;</span>
            }</span></span>
            <span class="lc">// found the left bound</span>
            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">left</span></span> != <span class="e Identifier"><span class="i">right</span></span></span>)</span>;</span>
            <span class="s For"><span class="k">for</span> (;;)
            <span class="s Compound">{
                <span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">right</span></span></span>;</span>
                <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">left</span></span> == <span class="e Identifier"><span class="i">right</span></span></span>) <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">left</span></span>;</span></span>
                <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">pred</span></span>(*<span class="i">right</span>)</span>) <span class="s Break"><span class="k">break</span>;</span></span>
            }</span></span>
            <span class="lc">// found the right bound, swap &amp; make progress</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">left</span>, <span class="i">right</span>)</span>;</span>
            <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">left</span></span></span>;</span>
        }</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">result</span></span> = <span class="e Identifier"><span class="i">left</span></span></span>;</span>
    }</span></span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span> <span class="lc">// partition</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">Arr</span> = <span class="e ArrayInit">[<span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">8</span></span>, <span class="e Int"><span class="n">9</span></span>, <span class="e Int"><span class="n">10</span></span>]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">arr</span> = <span class="e Dot"><span class="e Identifier"><span class="i">Arr</span></span>.<span class="e Identifier"><span class="i">dup</span></span></span>;</span></span>
    <span class="d StorageClass"><span class="k">static</span> <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">even</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">int</span></span> <span class="i">a</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Equal"><span class="e Paren">(<span class="e And"><span class="e Identifier"><span class="i">a</span></span> &amp; <span class="e Int"><span class="n">1</span></span></span>)</span> == <span class="e Int"><span class="n">0</span></span></span>;</span> }</span></span></span></span>
<span class="lc">// Partition a such that even numbers come first</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">p</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">partition</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">even</span></span></span>)</span>(<span class="i">arr</span>)</span>;</span></span>
<span class="lc">// Now arr is separated in evens and odds.</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">p</span></span> == <span class="e Plus"><span class="e Dot"><span class="e Identifier"><span class="i">arr</span></span>.<span class="e Identifier"><span class="i">ptr</span></span></span> + <span class="e Int"><span class="n">5</span></span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">count</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">even</span></span></span>)</span>(<span class="i">range</span>(<span class="i">begin</span>(<span class="i">arr</span>), <span class="i">p</span>))</span> == <span class="e Minus"><span class="e Identifier"><span class="i">p</span></span> - <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">arr</span>)</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">find</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">even</span></span></span>)</span>(<span class="i">range</span>(<span class="i">p</span>, <span class="i">end</span>(<span class="i">arr</span>)))</span> == <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">arr</span>)</span></span>)</span>;</span>
<span class="lc">// Notice that numbers have become shuffled due to instability</span>
    <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">arr</span></span>[]</span> = <span class="e Slice"><span class="e Identifier"><span class="i">Arr</span></span>[]</span></span>;</span>
<span class="lc">// Can also specify the predicate as a string.</span>
<span class="lc">// Use 'a' as the predicate argument name</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">p</span></span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">partition</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">q{(a &amp; 1) == 0}</span></span></span>)</span>(<span class="i">arr</span>)</span></span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">p</span></span> == <span class="e Plus"><span class="e Dot"><span class="e Identifier"><span class="i">arr</span></span>.<span class="e Identifier"><span class="i">ptr</span></span></span> + <span class="e Int"><span class="n">5</span></span></span></span>)</span>;</span>
<span class="lc">// Same result as above. Now for a stable partition:</span>
    <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">arr</span></span>[]</span> = <span class="e Slice"><span class="e Identifier"><span class="i">Arr</span></span>[]</span></span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">p</span></span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">partition</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">q{(a &amp; 1) == 0}</span></span>, <span class="t Qualified"><span class="t Identifier"><span class="i">SwapStrategy</span></span>.<span class="t Identifier"><span class="i">stable</span></span></span></span>)</span>(<span class="i">arr</span>)</span></span>;</span>
<span class="lc">// Now arr is [2 4 6 8 10 1 3 5 7 9], and p points to 1</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">arr</span></span> == <span class="e ArrayLiteral">[<span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">8</span></span>, <span class="e Int"><span class="n">10</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">9</span></span>]</span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">p</span></span> == <span class="e Plus"><span class="e Dot"><span class="e Identifier"><span class="i">arr</span></span>.<span class="e Identifier"><span class="i">ptr</span></span></span> + <span class="e Int"><span class="n">5</span></span></span></span></span>)</span>;</span>
<span class="lc">// In case the predicate needs to hold its own state, use a delegate:</span>
    <span class="s Expression"><span class="e Assign"><span class="e Slice"><span class="e Identifier"><span class="i">arr</span></span>[]</span> = <span class="e Slice"><span class="e Identifier"><span class="i">Arr</span></span>[]</span></span>;</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">x</span> = <span class="e Int"><span class="n">3</span></span>;</span></span>
<span class="lc">// Put stuff greater than 3 on the left</span>
    <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">fun</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">int</span></span> <span class="i">a</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Rel"><span class="e Identifier"><span class="i">a</span></span> &gt; <span class="e Identifier"><span class="i">x</span></span></span>;</span> }</span></span></span></span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">p</span></span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">partition</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">fun</span></span>, <span class="t Qualified"><span class="t Identifier"><span class="i">SwapStrategy</span></span>.<span class="t Identifier"><span class="i">semistable</span></span></span></span>)</span>(<span class="i">arr</span>)</span></span>;</span>
<span class="lc">// Now arr is [4 5 6 7 8 9 10 2 3 1] and p points to 2</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">arr</span></span> == <span class="e ArrayLiteral">[<span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">8</span></span>, <span class="e Int"><span class="n">9</span></span>, <span class="e Int"><span class="n">10</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">1</span></span>]</span></span> &amp;&amp; <span class="e Equal"><span class="e Identifier"><span class="i">p</span></span> == <span class="e Plus"><span class="e Dot"><span class="e Identifier"><span class="i">arr</span></span>.<span class="e Identifier"><span class="i">ptr</span></span></span> + <span class="e Int"><span class="n">7</span></span></span></span></span>)</span>;</span>

    <span class="lc">// test with random data</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">a</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">rndstuff</span>!(<span class="o TemplateArguments"><span class="t Integral"><span class="k">int</span></span></span>)</span>()</span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">partition</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">even</span></span></span>)</span>(<span class="i">a</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isPartitioned</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">even</span></span></span>)</span>(<span class="i">a</span>)</span>)</span>;</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">b</span> = <span class="e TemplateInstance"><span class="i">rndstuff</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">string</span></span></span>)</span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">partition</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">`a.length &lt; 5`</span></span></span>)</span>(<span class="i">b</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isPartitioned</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">`a.length &lt; 5`</span></span></span>)</span>(<span class="i">b</span>)</span>)</span>;</span>
}</span></span></span>

<span class="lc">// // partitionPivot</span>
<span class="lc">// /**</span>
<span class="lc">// Partitions $(D r) algorithm around a pivot</span>
<span class="lc">// $(D m). Specifically, reorders the range $(D r = left ..  right) such</span>
<span class="lc">// that elements less than $(D *m) are on the left and elements greater</span>
<span class="lc">// than or equal to $(D *m) are on the right, then returns an iterator</span>
<span class="lc">// pointing to the first element in the second partition. Performs</span>
<span class="lc">// $(BIGOH r.length) (if unstable or semistable) or $(BIGOH r.length *</span>
<span class="lc">// log(r.length)) (if stable) evaluations of $(D less) and $(D iterSwap).</span>

<span class="lc">// Precondition:</span>

<span class="lc">// $(D left &lt;= pivot &amp;&amp; pivot &lt; right).</span>

<span class="lc">// Returns:</span>

<span class="lc">// Let $(D pivotVal) be $(D *pivot) before the</span>
<span class="lc">// call. The result of $(D partitionPivot) is a value $(D</span>
<span class="lc">// mid) such that:</span>
<span class="lc">// $(OL</span>
<span class="lc">// $(LI $(D less(*p1, pivotVal)) for all $(D p1) in</span>
<span class="lc">// [$(D left), $(D mid)$(RPAREN))</span>
<span class="lc">// $(LI $(D !less(*p2, pivotVal)) for all $(D p2) in [$(D mid), $(D right)$(RPAREN)))</span>
<span class="lc">// For the unstable and semistable partitions, the following condition</span>
<span class="lc">// also holds: $(D *mid == pivotVal).</span>
<span class="lc">// */</span>
<span class="lc">// It partitionPivot(alias less,</span>
<span class="lc">//                  SwapStrategy ss = SwapStrategy.unstable,</span>
<span class="lc">//                  alias iterSwap = .iterSwap, Range, It)(Range r, It m)</span>
<span class="lc">// {</span>
<span class="lc">//     auto b = begin(r), e = end(r);</span>
<span class="lc">//     if (b == e) return b;</span>
<span class="lc">//     assert(b &lt;= m &amp;&amp; m &lt; e);</span>
<span class="lc">//     alias typeof(*b) E;</span>
<span class="lc">//     static if (ss == SwapStrategy.unstable)</span>
<span class="lc">//     {</span>
<span class="lc">//         --e;</span>
<span class="lc">//         // swap the pivot to end</span>
<span class="lc">//         iterSwap(m, e);</span>
<span class="lc">//         // partition on predicate</span>
<span class="lc">//         auto pivotCached = *e;</span>
<span class="lc">//         bool pred(E a) { return less(a, pivotCached); }</span>
<span class="lc">//         auto result = partition!(pred, ss, iterSwap)(range(b, e));</span>
<span class="lc">//         // swap back</span>
<span class="lc">//         iterSwap(result, e);</span>
<span class="lc">//     }</span>
<span class="lc">//     else</span>
<span class="lc">//     {</span>
<span class="lc">//         // copy the pivot so it's not messed up</span>
<span class="lc">//         auto pivot = *m;</span>
<span class="lc">//         bool pred(E a) { return less(a, pivot); }</span>
<span class="lc">//         auto result = partition!(pred, ss, iterSwap)(r);</span>
<span class="lc">//     }</span>
<span class="lc">//     return result;</span>
<span class="lc">// }</span>

<span class="lc">// /// Ditto</span>
<span class="lc">// It partitionPivot(string less = q{a &lt; b},</span>
<span class="lc">//                  SwapStrategy ss = SwapStrategy.unstable,</span>
<span class="lc">//                  alias iterSwap = .iterSwap, Range, It)(Range r, It m)</span>
<span class="lc">// {</span>
<span class="lc">//     return .partitionPivot!(binaryFun!(less), ss, iterSwap, Range, It)(r, m);</span>
<span class="lc">// }</span>

<span class="lc">// version (wyda) unittest</span>
<span class="lc">// {</span>
<span class="lc">//     auto a = [3, 3, 2];</span>
<span class="lc">//     bool less(int a, int b) { return a &lt; b; }</span>
<span class="lc">//     auto p = partitionPivot!(less)(a, a.ptr);</span>
<span class="lc">//     assert(p == a.ptr + 1 &amp;&amp; a == [2, 3, 3]);</span>
<span class="lc">//     // Use default less</span>
<span class="lc">//     a[] = [3, 3, 2];</span>
<span class="lc">//     p = partitionPivot(a, a.ptr);</span>
<span class="lc">//     assert(p == a.ptr + 1 &amp;&amp; a == [2, 3, 3]);</span>

<span class="lc">//     // test with random data</span>
<span class="lc">//     // @@@BUG@@@ The whole type tuple should work</span>
<span class="lc">//     foreach (T; TypeTuple!(int/*, double, string*/))</span>
<span class="lc">//     {{</span>
<span class="lc">//         auto i = rndstuff!(T)();</span>
<span class="lc">//         if (!i.length) continue;</span>
<span class="lc">//         auto pivot = i[0];</span>
<span class="lc">//         partitionPivot!(`a &gt; b`)(i, begin(i));</span>
<span class="lc">//         bool pred2(int a) { return a &gt; pivot; }</span>
<span class="lc">//         assert(isPartitioned!(pred2)(i));</span>
<span class="lc">//     }}</span>
<span class="lc">// }</span>

<span class="d Template"><span class="k">template</span> <span class="i">isPartitioned</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">pred</span></span>)</span>
<span class="d Compound">{
    <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">isPartitioned</span><span class="o TemplateParameters">(<span class="o TemplateTypeParameter"><span class="i">T</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">range</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">left</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">range</span>)</span>, <span class="i">right</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">range</span>)</span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">left</span></span> == <span class="e Identifier"><span class="i">right</span></span></span>) <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span></span>
        <span class="s For"><span class="k">for</span> (; <span class="e Equal"><span class="e Identifier"><span class="i">left</span></span> != <span class="e Identifier"><span class="i">right</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">left</span></span></span>)
        <span class="s Compound">{
            <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">pred</span></span></span>(*<span class="i">left</span>)</span>) <span class="s Break"><span class="k">break</span>;</span></span>
        }</span></span>
        <span class="s For"><span class="k">for</span> (; <span class="e Equal"><span class="e Identifier"><span class="i">left</span></span> != <span class="e Identifier"><span class="i">right</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">left</span></span></span>)
        <span class="s Compound">{
            <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">pred</span></span>(*<span class="i">left</span>)</span>) <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span>
    }</span></span></span></span></span>
}</span></span>

<span class="d Template"><span class="k">template</span> <span class="i">isPartitioned</span><span class="o TemplateParameters">(<span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">string</span></span> <span class="i">pred</span></span>)</span>
<span class="d Compound">{
    <span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Qualified"><span class="t ModuleScope">.</span><span class="t TemplateInstance"><span class="i">isPartitioned</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">unaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span></span>)</span></span> <span class="i">isPartitioned</span>;</span></span>
}</span></span>

<span class="lc">// topN</span>
<span class="bc">/**
Reorders the range $(D r = [first, last$(RPAREN)) using $(D iterSwap)
as a swapping primitive such that $(D nth) points to the element that
would fall there if the range were fully sorted. Effectively, it finds
the nth smallest (according to $(D less)) element in $(D r). In
addition, it also partitions $(D r) such that all elements $(D p1) in
$(D [first, nth$(RPAREN)) satisfy $(D less(*p1, *nth)), and all
elements $(D p2) in $(D [nth, last$(RPAREN)) satisfy $(D !less(*p2,
nth)). Performs $(BIGOH r.length) (if unstable) or $(BIGOH r.length *
log(r.length)) (if stable) evaluations of $(D less) and $(D
iterSwap). See also $(WEB sgi.com/tech/stl/nth_element.html, STL's
nth_element).

Example:

----
int[] v = [ 25, 7, 9, 2, 0, 5, 21 ];
auto n = 4;
topN!(less)(v, begin(v) + n);
assert(v[n] == 9);
// Equivalent form:
topN!("a &lt; b")(v, begin(v) + n);
assert(v[n] == 9);
----

BUGS:

Stable topN has not been implemented yet.
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">topN</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span> = <span class="sl">"a &lt; b"</span></span>,
                <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">SwapStrategy</span></span> <span class="i">ss</span> = <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">unstable</span></span></span></span>,
                <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>, <span class="o TemplateTypeParameter"><span class="i">It</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">It</span></span> <span class="i">nth</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">ss</span></span> == <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">unstable</span></span></span></span>,
                  <span class="e String"><span class="sl">"stable topN not yet implemented"</span></span>);</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">b</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span>, <span class="i">e</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">b</span></span> &lt; <span class="e Identifier"><span class="i">e</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">b</span></span> &lt;= <span class="e Identifier"><span class="i">nth</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">nth</span></span> &lt; <span class="e Identifier"><span class="i">e</span></span></span></span>)</span>;</span>
    <span class="s For"><span class="k">for</span> (;;)
    <span class="s Compound">{
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">pivot</span> = <span class="e Plus"><span class="e Identifier"><span class="i">b</span></span> + <span class="e Div"><span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">e</span></span> - <span class="e Identifier"><span class="i">b</span></span></span>)</span> / <span class="e Int"><span class="n">2</span></span></span></span>;</span></span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">pivotVal</span> = <span class="e Deref">*<span class="e Identifier"><span class="i">pivot</span></span></span>;</span></span>
        <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">pred</span><span class="o Parameters">(<span class="o Parameter"><span class="t TemplateInstance"><span class="i">ElementType</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range</span></span></span>)</span> <span class="i">a</span></span>)</span>
        <span class="s FuncBody"><span class="s Compound">{
            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span>(<span class="i">a</span>, <span class="i">pivotVal</span>)</span>;</span>
        }</span></span></span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">pivot</span>, <span class="i">e</span> - <span class="n">1</span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">pivot</span></span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">partition</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span>, <span class="t Identifier"><span class="i">ss</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">range</span>(<span class="i">b</span>, <span class="i">e</span>))</span></span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">pivot</span>, <span class="i">e</span> - <span class="n">1</span>)</span>;</span>
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">pivot</span></span> == <span class="e Identifier"><span class="i">nth</span></span></span>) <span class="s Return"><span class="k">return</span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">pivot</span></span> &lt; <span class="e Identifier"><span class="i">nth</span></span></span>) <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">b</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">pivot</span></span> + <span class="e Int"><span class="n">1</span></span></span></span>;</span>
        <span class="k">else</span> <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">e</span></span> = <span class="e Identifier"><span class="i">pivot</span></span></span>;</span></span>
    }</span></span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s ScopeGuard"><span class="k">scope</span>(<span class="i">failure</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">writeln</span></span>(<span class="i">stderr</span>, <span class="sl">"Failure testing algorithm"</span>)</span>;</span></span>
    <span class="lc">//auto v = ([ 25, 7, 9, 2, 0, 5, 21 ]).dup;</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">v</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">0</span></span> ]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">n</span> = <span class="e Int"><span class="n">3</span></span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">topN</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &lt; b"</span></span></span>)</span>(<span class="i">v</span>, <span class="i">v</span>.<span class="i">ptr</span> + <span class="i">n</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">v</span></span>[<span class="e Identifier"><span class="i">n</span></span>]</span> == <span class="e Identifier"><span class="i">n</span></span></span>)</span>;</span>
    <span class="lc">//</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">v</span></span> = <span class="e Dot"><span class="e Paren">(<span class="e ArrayLiteral">[<span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>]</span>)</span>.<span class="e Identifier"><span class="i">dup</span></span></span></span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">n</span></span> = <span class="e Int"><span class="n">3</span></span></span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">topN</span></span>(<span class="i">v</span>, <span class="i">v</span>.<span class="i">ptr</span> + <span class="i">n</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">v</span></span>[<span class="e Identifier"><span class="i">n</span></span>]</span> == <span class="e Int"><span class="n">3</span></span></span>)</span>;</span>
    <span class="lc">//</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">v</span></span> = <span class="e Dot"><span class="e Paren">(<span class="e ArrayLiteral">[<span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>]</span>)</span>.<span class="e Identifier"><span class="i">dup</span></span></span></span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">n</span></span> = <span class="e Int"><span class="n">1</span></span></span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">topN</span></span>(<span class="i">v</span>, <span class="i">v</span>.<span class="i">ptr</span> + <span class="i">n</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">v</span></span>[<span class="e Identifier"><span class="i">n</span></span>]</span> == <span class="e Int"><span class="n">2</span></span></span>)</span>;</span>
    <span class="lc">//</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">v</span></span> = <span class="e Dot"><span class="e Paren">(<span class="e ArrayLiteral">[<span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>]</span>)</span>.<span class="e Identifier"><span class="i">dup</span></span></span></span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">n</span></span> = <span class="e Minus"><span class="e Dot"><span class="e Identifier"><span class="i">v</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> - <span class="e Int"><span class="n">1</span></span></span></span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">topN</span></span>(<span class="i">v</span>, <span class="i">v</span>.<span class="i">ptr</span> + <span class="i">n</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">v</span></span>[<span class="e Identifier"><span class="i">n</span></span>]</span> == <span class="e Int"><span class="n">7</span></span></span>)</span>;</span>
    <span class="lc">//</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">v</span></span> = <span class="e Dot"><span class="e Paren">(<span class="e ArrayLiteral">[<span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>]</span>)</span>.<span class="e Identifier"><span class="i">dup</span></span></span></span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">n</span></span> = <span class="e Int"><span class="n">0</span></span></span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">topN</span></span>(<span class="i">v</span>, <span class="i">v</span>.<span class="i">ptr</span> + <span class="i">n</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">v</span></span>[<span class="e Identifier"><span class="i">n</span></span>]</span> == <span class="e Int"><span class="n">1</span></span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// sort</span>
<span class="bc">/**
Sorts a random-access range according to predicate $(D less). Performs
$(BIGOH r.length * log(r.length)) (if unstable) or $(BIGOH r.length *
log(r.length) * log(r.length)) (if stable) evaluations of $(D less)
and $(D iterSwap). See also STL's $(WEB sgi.com/tech/stl/_sort.html,
sort) and $(WEB sgi.com/tech/stl/stable_sort.html, stable_sort).

Example:

----
int[] array = [ 1, 2, 3, 4 ];
// sort in descending order
sort!("a &gt; b")(array);
assert(array == [ 4, 3, 2, 1 ]);
// sort in ascending order
sort(array);
assert(array == [ 1, 2, 3, 4 ]);
// sort with a delegate 
bool myComp(int x, int y) { return x &gt; y; }
sort!(myComp)(array);
assert(array == [ 4, 3, 2, 1 ]);
// Showcase stable sorting
string[] words = [ "aBc", "a", "abc", "b", "ABC", "c" ];
sort!("toupper(a) &lt; toupper(b)", SwapStrategy.stable)(words);
assert(words == [ "a", "aBc", "abc", "ABC", "b", "c" ]);
----
*/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">sort</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span> = <span class="sl">"a &lt; b"</span></span>, <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">SwapStrategy</span></span> <span class="i">ss</span> = <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">unstable</span></span></span></span>,
          <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span> <span class="i">lessFun</span>;</span></span></span>
    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Is"><span class="k">is</span>(<span class="t Typeof"><span class="k">typeof</span>(<span class="e Call"><span class="e Identifier"><span class="i">lessFun</span></span>(*<span class="i">begin</span>(<span class="i">r</span>), *<span class="i">end</span>(<span class="i">r</span>))</span>)</span> == <span class="t Integral"><span class="k">bool</span></span>)</span>)
    <span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">sortImpl</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">lessFun</span></span>, <span class="t Identifier"><span class="i">ss</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">r</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isSorted</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">lessFun</span></span></span>)</span>(<span class="i">r</span>)</span>)</span>;</span>
    }</span>
    <span class="k">else</span>
    <span class="s Compound">{
        <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Bool"><span class="k">false</span></span>, <span class="e String"><span class="sl">"Invalid predicate passed to sort"</span></span>);</span>
    }</span></span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="lc">// sort using delegate</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">a</span><span class="t Array">[]</span> = <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">int</span></span><span class="t Array">[<span class="e Int"><span class="n">100</span></span>]</span></span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">rnd</span> = <span class="e Call"><span class="e Identifier"><span class="i">Random</span></span>(<span class="i">unpredictableSeed</span>)</span>;</span></span>
    <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="k">ref</span> <span class="i">e</span></span></span>; <span class="e Identifier"><span class="i">a</span></span>) <span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">e</span></span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">uniform</span>!(<span class="o TemplateArguments"><span class="t Integral"><span class="k">int</span></span></span>)</span>(<span class="i">rnd</span>, -<span class="n">100</span>, <span class="n">100</span>)</span></span>;</span>
    }</span></span>
    
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span> <span class="i">i</span> = <span class="e Int"><span class="n">0</span></span>;</span></span>
    <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">greater2</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">int</span></span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">int</span></span> <span class="i">b</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Rel"><span class="e Plus"><span class="e Identifier"><span class="i">a</span></span> + <span class="e Identifier"><span class="i">i</span></span></span> &gt; <span class="e Plus"><span class="e Identifier"><span class="i">b</span></span> + <span class="e Identifier"><span class="i">i</span></span></span></span>;</span> }</span></span></span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="t Delegate"><span class="k">delegate</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">int</span></span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">int</span></span></span>)</span></span> <span class="i">greater</span> = <span class="e Address">&amp;<span class="e Identifier"><span class="i">greater2</span></span></span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">sort</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">greater</span></span></span>)</span>(<span class="i">a</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isSorted</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">greater</span></span></span>)</span>(<span class="i">a</span>)</span>)</span>;</span>

    <span class="lc">// sort using string</span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">sort</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &lt; b"</span></span></span>)</span>(<span class="i">a</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isSorted</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &lt; b"</span></span></span>)</span>(<span class="i">a</span>)</span>)</span>;</span>

    <span class="lc">// sort using function; all elements equal</span>
    <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="k">ref</span> <span class="i">e</span></span></span>; <span class="e Identifier"><span class="i">a</span></span>) <span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">e</span></span> = <span class="e Int"><span class="n">5</span></span></span>;</span>
    }</span></span>
    <span class="d StorageClass"><span class="k">static</span> <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">less</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">int</span></span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">int</span></span> <span class="i">b</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Rel"><span class="e Identifier"><span class="i">a</span></span> &lt; <span class="e Identifier"><span class="i">b</span></span></span>;</span> }</span></span></span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">sort</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span>(<span class="i">a</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isSorted</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span>(<span class="i">a</span>)</span>)</span>;</span>

    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">string</span></span><span class="t Array">[]</span> <span class="i">words</span> = <span class="e ArrayInit">[ <span class="e String"><span class="sl">"aBc"</span></span>, <span class="e String"><span class="sl">"a"</span></span>, <span class="e String"><span class="sl">"abc"</span></span>, <span class="e String"><span class="sl">"b"</span></span>, <span class="e String"><span class="sl">"ABC"</span></span>, <span class="e String"><span class="sl">"c"</span></span> ]</span>;</span></span>
    <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">lessi</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">string</span></span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">string</span></span> <span class="i">b</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Rel"><span class="e Call"><span class="e Identifier"><span class="i">toupper</span></span>(<span class="i">a</span>)</span> &lt; <span class="e Call"><span class="e Identifier"><span class="i">toupper</span></span>(<span class="i">b</span>)</span></span>;</span> }</span></span></span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">sort</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">lessi</span></span>, <span class="t Qualified"><span class="t Identifier"><span class="i">SwapStrategy</span></span>.<span class="t Identifier"><span class="i">stable</span></span></span></span>)</span>(<span class="i">words</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">words</span></span> == <span class="e ArrayLiteral">[ <span class="e String"><span class="sl">"a"</span></span>, <span class="e String"><span class="sl">"aBc"</span></span>, <span class="e String"><span class="sl">"abc"</span></span>, <span class="e String"><span class="sl">"ABC"</span></span>, <span class="e String"><span class="sl">"b"</span></span>, <span class="e String"><span class="sl">"c"</span></span> ]</span></span>)</span>;</span>

    <span class="lc">// sort using ternary predicate</span>
    <span class="lc">//sort!("b - a")(a);</span>
    <span class="lc">//assert(isSorted!(less)(a));</span>

    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">a</span></span> = <span class="e TemplateInstance"><span class="i">rndstuff</span>!(<span class="o TemplateArguments"><span class="t Integral"><span class="k">int</span></span></span>)</span></span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">sort</span></span>(<span class="i">a</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">isSorted</span></span>(<span class="i">a</span>)</span>)</span>;</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">b</span> = <span class="e TemplateInstance"><span class="i">rndstuff</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">string</span></span></span>)</span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">sort</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"tolower(a) &lt; tolower(b)"</span></span></span>)</span>(<span class="i">b</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isSorted</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"toupper(a) &lt; toupper(b)"</span></span></span>)</span>(<span class="i">b</span>)</span>)</span>;</span>
}</span></span></span>

<span class="lc">// @@@BUG1904</span>
<span class="bc">/*private*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">Iter</span></span> <span class="i">getPivot</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span></span>, <span class="o TemplateTypeParameter"><span class="i">Iter</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Iter</span></span> <span class="i">b</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">Iter</span></span> <span class="i">e</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">r</span> = <span class="e Plus"><span class="e Identifier"><span class="i">b</span></span> + <span class="e Div"><span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">e</span></span> - <span class="e Identifier"><span class="i">b</span></span></span>)</span> / <span class="e Int"><span class="n">2</span></span></span></span>;</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">r</span></span>;</span>
}</span></span></span></span></span>

<span class="lc">// @@@BUG1904</span>
<span class="bc">/*private*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">optimisticInsertionSort</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span></span>, <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">b</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span>, <span class="i">e</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span>;</span></span>
    <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Minus"><span class="e Identifier"><span class="i">e</span></span> - <span class="e Identifier"><span class="i">b</span></span></span> &lt;= <span class="e Int"><span class="n">1</span></span></span>) <span class="s Return"><span class="k">return</span>;</span></span>
    <span class="s For"><span class="k">for</span> (<span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">i</span> = <span class="e Plus"><span class="e Int"><span class="n">1</span></span> + <span class="e Identifier"><span class="i">b</span></span></span>;</span></span> <span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> != <span class="e Identifier"><span class="i">e</span></span></span>; )
    <span class="s Compound">{
        <span class="lc">// move down to find the insertion point</span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">p</span> = <span class="e Minus"><span class="e Identifier"><span class="i">i</span></span> - <span class="e Int"><span class="n">1</span></span></span>;</span></span>
        <span class="s For"><span class="k">for</span> (;;)
        <span class="s Compound">{
            <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">less</span></span></span>(*<span class="i">i</span>, *<span class="i">p</span>)</span>)
            <span class="s Compound">{
                <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">p</span></span></span>;</span>
                <span class="s Break"><span class="k">break</span>;</span>
            }</span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">p</span></span> == <span class="e Identifier"><span class="i">b</span></span></span>) <span class="s Break"><span class="k">break</span>;</span></span>
            <span class="s Expression"><span class="e PreDecr">--<span class="e Identifier"><span class="i">p</span></span></span>;</span>
        }</span></span>
        <span class="lc">// move up to see how many we can insert</span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">iOld</span> = <span class="e Identifier"><span class="i">i</span></span>, <span class="i">iPrev</span> = <span class="e Identifier"><span class="i">i</span></span>;</span></span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>;</span>
        <span class="s While"><span class="k">while</span> (<span class="e AndAnd"><span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> != <span class="e Identifier"><span class="i">e</span></span></span> &amp;&amp; <span class="e Call"><span class="e Identifier"><span class="i">less</span></span>(*<span class="i">i</span>, *<span class="i">p</span>)</span></span> &amp;&amp; <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">less</span></span></span>(*<span class="i">i</span>, *<span class="i">iPrev</span>)</span></span>) <span class="s Expression"><span class="e Comma"><span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>, <span class="e PreIncr">++<span class="e Identifier"><span class="i">iPrev</span></span></span></span>;</span></span>
        <span class="lc">// do the insertion</span>
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">rotate</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">range</span>(<span class="i">p</span>, <span class="i">i</span>), <span class="i">iOld</span>)</span>;</span>
    }</span></span>
}</span></span></span></span></span>

<span class="lc">// @@@BUG1904</span>
<span class="bc">/*private*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">sortImpl</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span></span>, <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">SwapStrategy</span></span> <span class="i">ss</span></span>, <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">ElementType</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range</span></span></span>)</span> <span class="i">Elem</span>;</span></span></span>
    <span class="d StorageClass"><span class="k">enum</span> <span class="d Variables"><span class="t Integral"><span class="k">uint</span></span> <span class="i">optimisticInsertionSortGetsBetter</span> = <span class="e Int"><span class="n">1</span></span>;</span></span>
    <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Rel"><span class="e Identifier"><span class="i">optimisticInsertionSortGetsBetter</span></span> &gt;= <span class="e Int"><span class="n">1</span></span></span>);</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">b</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span>, <span class="i">e</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span>;</span></span>
    <span class="s While"><span class="k">while</span> (<span class="e Rel"><span class="e Minus"><span class="e Identifier"><span class="i">e</span></span> - <span class="e Identifier"><span class="i">b</span></span></span> &gt; <span class="e Identifier"><span class="i">optimisticInsertionSortGetsBetter</span></span></span>)
    <span class="s Compound">{
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">pivotPtr</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">getPivot</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span>(<span class="i">b</span>, <span class="i">e</span>)</span>;</span></span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">pivot</span> = <span class="e Deref">*<span class="e Identifier"><span class="i">pivotPtr</span></span></span>;</span></span>
        <span class="lc">// partition</span>
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">ss</span></span> == <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">unstable</span></span></span></span>)
        <span class="s Compound">{
            <span class="lc">// partition</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">pivotPtr</span>, <span class="i">e</span> - <span class="n">1</span>)</span>;</span>
            <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">pred</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Elem</span></span> <span class="i">a</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">less</span></span>(<span class="i">a</span>, <span class="i">pivot</span>)</span>;</span> }</span></span></span></span>
            <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">mid</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">partition</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span>, <span class="t Identifier"><span class="i">ss</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">range</span>(<span class="i">b</span>, <span class="i">e</span>))</span>;</span></span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">mid</span>, <span class="i">e</span> - <span class="n">1</span>)</span>;</span>
            <span class="lc">// done with partitioning</span>
            <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">less</span></span></span>(<span class="i">pivot</span>, *<span class="i">mid</span>)</span> &amp;&amp; <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">less</span></span></span>(*<span class="i">mid</span>, <span class="i">pivot</span>)</span></span>)</span>;</span>
            <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">b</span></span> == <span class="e Identifier"><span class="i">mid</span></span></span>)
            <span class="s Compound">{
                <span class="lc">// worst case: *b &lt;= everything (also pivot &lt;= everything)</span>
                <span class="lc">// avoid quadratic behavior</span>
                <span class="s DoWhile"><span class="k">do</span> <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">b</span></span></span>;</span> <span class="k">while</span> (<span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">b</span></span> != <span class="e Identifier"><span class="i">e</span></span></span> &amp;&amp; <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">less</span></span></span>(<span class="i">pivot</span>, *<span class="i">b</span>)</span></span>)</span><span class="s Empty">;</span>
            }</span>
            <span class="k">else</span>
            <span class="s Compound">{
                <span class="s Expression"><span class="e Call"><span class="e ModuleScope">.<span class="e TemplateInstance"><span class="i">sortImpl</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="t Identifier"><span class="i">ss</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span>, <span class="t Identifier"><span class="i">Range</span></span></span>)</span></span>(<span class="i">range</span>(<span class="i">b</span>, <span class="i">mid</span>))</span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">b</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">mid</span></span> + <span class="e Int"><span class="n">1</span></span></span></span>;</span>
            }</span></span>
        }</span>
        <span class="k">else</span> <span class="lc">// handle semistable and stable the same</span>
        <span class="s Compound">{
            <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">ss</span></span> != <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">semistable</span></span></span></span>);</span>
            <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">pred</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Elem</span></span> <span class="i">a</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">less</span></span>(<span class="i">a</span>, <span class="i">pivot</span>)</span>;</span> }</span></span></span></span>
            <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">mid</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">partition</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span>, <span class="t Identifier"><span class="i">ss</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">range</span>(<span class="i">b</span>, <span class="i">e</span>))</span>;</span></span>
            <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">b</span></span> == <span class="e Identifier"><span class="i">mid</span></span></span>)
            <span class="s Compound">{
                <span class="lc">// bad, bad pivot. pivot &lt;= everything</span>
                <span class="lc">// find the first occurrence of the pivot                </span>
                <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">pred1</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Elem</span></span> <span class="i">a</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">less</span></span></span>(<span class="i">pivot</span>, <span class="i">a</span>)</span>;</span> }</span></span></span></span>
                <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">firstPivotPos</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">find</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred1</span></span></span>)</span>(<span class="i">range</span>(<span class="i">b</span>, <span class="i">e</span>))</span>;</span></span>
                <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">firstPivotPos</span></span> != <span class="e Identifier"><span class="i">e</span></span></span>)</span>;</span>
                <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">less</span></span></span>(*<span class="i">firstPivotPos</span>, <span class="i">pivot</span>)</span>
                       &amp;&amp; <span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">less</span></span></span>(<span class="i">pivot</span>, *<span class="i">firstPivotPos</span>)</span></span>)</span>;</span>
                <span class="lc">// find the last occurrence of the pivot</span>
                <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">pred2</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Elem</span></span> <span class="i">a</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">less</span></span>(<span class="i">pivot</span>, <span class="i">a</span>)</span>;</span> }</span></span></span></span>
                <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">lastPivotPos</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">find</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred2</span></span></span>)</span>(<span class="i">range</span>(<span class="i">firstPivotPos</span> + <span class="n">1</span>, <span class="i">e</span>))</span>;</span></span>
                <span class="lc">// now rotate firstPivotPos..lastPivotPos to the front</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">b</span></span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">rotate</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">range</span>(<span class="i">b</span>, <span class="i">lastPivotPos</span>), <span class="i">firstPivotPos</span>)</span></span>;</span>
            }</span>
            <span class="k">else</span>
            <span class="s Compound">{
                <span class="s Expression"><span class="e Call"><span class="e ModuleScope">.<span class="e TemplateInstance"><span class="i">sortImpl</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="t Identifier"><span class="i">ss</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span>, <span class="t Identifier"><span class="i">Range</span></span></span>)</span></span>(<span class="i">range</span>(<span class="i">b</span>, <span class="i">mid</span>))</span>;</span>
                <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">b</span></span> = <span class="e Identifier"><span class="i">mid</span></span></span>;</span>
            }</span></span>
        }</span></span>
    }</span></span>
    <span class="lc">// residual sort</span>
    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">optimisticInsertionSortGetsBetter</span></span> &gt; <span class="e Int"><span class="n">1</span></span></span>)
    <span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">optimisticInsertionSort</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span>, <span class="t Identifier"><span class="i">Range</span></span></span>)</span>(<span class="i">r</span>)</span>;</span>
    }</span></span>
}</span></span></span></span></span>
    
<span class="lc">// schwartzSort</span>
<span class="bc">/**
Sorts a range using an algorithm akin to the $(WEB
wikipedia.org/wiki/Schwartzian_transform, Schwartzian transform), also
known as the decorate-sort-undecorate pattern in Python and Lisp. (Not
to be confused with $(WEB youtube.com/watch?v=S25Zf8svHZQ, the other
Schwartz).) This function is helpful when the sort comparison includes
an expensive computation. The complexity is the same as that of the
corresponding $(D sort), but $(D schwartzSort) evaluates $(D
transform) only $(D r.length) times (less than half when compared to
regular sorting). The usage can be best illustrated with an example.

Example:

----
uint hashFun(string) { ... expensive computation ... }
string[] array = ...;
// Sort strings by hash, slow
sort!("hashFun(a) &lt; hashFun(b)")(array);
// Sort strings by hash, fast (only computes arr.length hashes):
schwartzSort!(hashFun, "a &lt; b")(array);
----

The $(D schwartzSort) function might require less temporary data and
be faster than the Perl idiom or the decorate-sort-undecorate idiom
present in Python and Lisp. This is because sorting is done in-place
and only minimal extra data (one array of transformed elements) is
created.
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">schwartzSort</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">transform</span></span>, <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span> = <span class="sl">"a &lt; b"</span></span>,
                  <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">SwapStrategy</span></span> <span class="i">ss</span> = <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">unstable</span></span></span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t Typeof"><span class="k">typeof</span>(<span class="e Call"><span class="e Identifier"><span class="i">transform</span></span>(*<span class="i">begin</span>(<span class="i">r</span>))</span>)</span> <span class="i">XformType</span>;</span></span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">xform</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">XformType</span></span><span class="t Array">[<span class="t Qualified"><span class="t Identifier"><span class="i">r</span></span>.<span class="t Identifier"><span class="i">length</span></span></span>]</span></span>;</span></span>
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">XformType</span></span><span class="t Array">[]</span></span>)</span> <span class="i">InnerIter</span>;</span></span></span>
    <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span>, <span class="o Parameter"><span class="i">e</span></span></span>; <span class="e Identifier"><span class="i">r</span></span>)
    <span class="s Compound">{
        <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">xform</span></span>[<span class="e Identifier"><span class="i">i</span></span>]</span> = <span class="e Call"><span class="e Identifier"><span class="i">transform</span></span>(<span class="i">e</span>)</span></span>;</span>
    }</span></span>
    <span class="lc">// primitive to swap the two collections in lockstep</span>
    <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">mySwap</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">InnerIter</span></span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">InnerIter</span></span> <span class="i">b</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">a</span>, <span class="i">b</span>)</span>;</span>
        <span class="d StorageClass"><span class="k">invariant</span> <span class="d Variables"><span class="i">i</span> = <span class="e Minus"><span class="e Identifier"><span class="i">a</span></span> - <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">xform</span>)</span></span>, <span class="i">j</span> = <span class="e Minus"><span class="e Identifier"><span class="i">b</span></span> - <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">xform</span>)</span></span>;</span></span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &gt;= <span class="e Int"><span class="n">0</span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">i</span></span> &lt; <span class="e Dot"><span class="e Identifier"><span class="i">xform</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">j</span></span> &gt;= <span class="e Int"><span class="n">0</span></span></span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">j</span></span> &lt; <span class="e Dot"><span class="e Identifier"><span class="i">xform</span></span>.<span class="e Identifier"><span class="i">length</span></span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">swap</span></span>(<span class="i">r</span>[<span class="i">i</span>], <span class="i">r</span>[<span class="i">j</span>])</span>;</span>
    }</span></span></span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">sort</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="t Identifier"><span class="i">ss</span></span>, <span class="t Identifier"><span class="i">mySwap</span></span></span>)</span>(<span class="i">xform</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">static</span> <span class="d Function"><span class="t Integral"><span class="k">double</span></span> <span class="i">entropy</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">double</span></span><span class="t Array">[]</span> <span class="i">probs</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">double</span></span> <span class="i">result</span> = <span class="e Int"><span class="n">0</span></span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">p</span></span></span>; <span class="e Identifier"><span class="i">probs</span></span>) <span class="s Compound">{
            <span class="s If"><span class="k">if</span> (<span class="e Not">!<span class="e Identifier"><span class="i">p</span></span></span>) <span class="s Continue"><span class="k">continue</span>;</span></span>
            <span class="lc">//enforce(p &gt; 0 &amp;&amp; p &lt;= 1, "Wrong probability passed to entropy");</span>
            <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">result</span></span> -= <span class="e Mul"><span class="e Identifier"><span class="i">p</span></span> * <span class="e Call"><span class="e Identifier"><span class="i">log</span></span>(<span class="i">p</span>)</span></span></span>;</span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
    }</span></span></span></span>

    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">lowEnt</span> = <span class="e Dot"><span class="e Paren">(<span class="e ArrayLiteral">[ <span class="e Real"><span class="n">1.0</span></span>, <span class="e Int"><span class="n">0</span></span>, <span class="e Int"><span class="n">0</span></span> ]</span>)</span>.<span class="e Identifier"><span class="i">dup</span></span></span>,
        <span class="i">midEnt</span> = <span class="e Dot"><span class="e Paren">(<span class="e ArrayLiteral">[ <span class="e Real"><span class="n">0.1</span></span>, <span class="e Real"><span class="n">0.1</span></span>, <span class="e Real"><span class="n">0.8</span></span> ]</span>)</span>.<span class="e Identifier"><span class="i">dup</span></span></span>,
        <span class="i">highEnt</span> = <span class="e Dot"><span class="e Paren">(<span class="e ArrayLiteral">[ <span class="e Real"><span class="n">0.31</span></span>, <span class="e Real"><span class="n">0.29</span></span>, <span class="e Real"><span class="n">0.4</span></span> ]</span>)</span>.<span class="e Identifier"><span class="i">dup</span></span></span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">double</span></span> <span class="i">arr</span><span class="t Array">[]<span class="t Array">[]</span></span> = <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">double</span></span><span class="t Array">[]</span><span class="t Array">[<span class="e Int"><span class="n">3</span></span>]</span></span>;</span></span>
    <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">arr</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> = <span class="e Identifier"><span class="i">midEnt</span></span></span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">arr</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> = <span class="e Identifier"><span class="i">lowEnt</span></span></span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Index"><span class="e Identifier"><span class="i">arr</span></span>[<span class="e Int"><span class="n">2</span></span>]</span> = <span class="e Identifier"><span class="i">highEnt</span></span></span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">schwartzSort</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">entropy</span></span>, <span class="e String"><span class="sl">q{a &lt; b}</span></span></span>)</span>(<span class="i">arr</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">arr</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e Identifier"><span class="i">lowEnt</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">arr</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e Identifier"><span class="i">midEnt</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">arr</span></span>[<span class="e Int"><span class="n">2</span></span>]</span> == <span class="e Identifier"><span class="i">highEnt</span></span></span>)</span>;</span>

    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">schwartzSort</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">entropy</span></span>, <span class="e String"><span class="sl">q{a &gt; b}</span></span></span>)</span>(<span class="i">arr</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">arr</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e Identifier"><span class="i">highEnt</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">arr</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e Identifier"><span class="i">midEnt</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">arr</span></span>[<span class="e Int"><span class="n">2</span></span>]</span> == <span class="e Identifier"><span class="i">lowEnt</span></span></span>)</span>;</span>

    <span class="lc">// random data</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">b</span> = <span class="e TemplateInstance"><span class="i">rndstuff</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">string</span></span></span>)</span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">schwartzSort</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">tolower</span></span></span>)</span>(<span class="i">b</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isSorted</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"toupper(a) &lt; toupper(b)"</span></span></span>)</span>(<span class="i">b</span>)</span>)</span>;</span>
}</span></span></span>

<span class="lc">// partialSort</span>
<span class="bc">/**
Reorders $(D r) such that the range $(D begin(r) .. mid) is the same
as if $(D r) were sorted, and leaves the range $(D mid .. end(r)) in
no particular order. Performs $(BIGOH r.length * log(mid - begin(r)))
evaluations of $(D pred).

Example:
----
int[] a = [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ];
partialSort(a, begin(a) + 5);
assert(a[0 .. 5] == [ 0, 1, 2, 3, 4 ]);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">partialSort</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span> = <span class="sl">"a &lt; b"</span></span>, <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">SwapStrategy</span></span> <span class="i">ss</span> = <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">unstable</span></span></span></span>,
    <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>, <span class="o TemplateTypeParameter"><span class="i">It</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">It</span></span> <span class="i">mid</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">topN</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="t Identifier"><span class="i">ss</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">r</span>, <span class="i">mid</span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">sort</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="t Identifier"><span class="i">ss</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span>, <span class="t Identifier"><span class="i">Range</span></span></span>)</span>(<span class="i">range</span>(<span class="i">begin</span>(<span class="i">r</span>), <span class="i">mid</span>))</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">9</span></span>, <span class="e Int"><span class="n">8</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">0</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">partialSort</span></span>(<span class="i">a</span>, <span class="i">begin</span>(<span class="i">a</span>) + <span class="n">5</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Slice"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Int"><span class="n">0</span></span> .. <span class="e Int"><span class="n">5</span></span>]</span> == <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">0</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span> ]</span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// isSorted</span>
<span class="bc">/**
Checks whether a random-access range is sorted according to the
comparison operation $(D less). Performs $(BIGOH r.length) evaluations
of $(D less).

   Example:

----
int[] arr = [4, 3, 2, 1];
assert(!isSorted(arr));
sort(arr);
assert(isSorted(arr));
sort!("a &gt; b")(arr);
assert(isSorted!("a &gt; b")(arr));
----
*/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">isSorted</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">pred</span><span class="o Parameters">(<span class="o Parameter"><span class="t Typeof"><span class="k">typeof</span>(<span class="e Call"><span class="e Deref">*<span class="e Identifier"><span class="i">begin</span></span></span>(<span class="i">r</span>)</span>)</span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Typeof"><span class="k">typeof</span>(<span class="e Call"><span class="e Deref">*<span class="e Identifier"><span class="i">begin</span></span></span>(<span class="i">r</span>)</span>)</span> <span class="i">b</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">less</span></span>(<span class="i">b</span>, <span class="i">a</span>)</span>;</span> }</span></span></span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Equal"><span class="e Call"><span class="e TemplateInstance"><span class="i">findAdjacent</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">pred</span></span></span>)</span>(<span class="i">r</span>)</span> == <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span></span>;</span>
}</span></span></span></span></span>

<span class="lc">/// Ditto</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">isSorted</span><span class="o TemplateParameters">(<span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">string</span></span> <span class="i">less</span> = <span class="e String"><span class="sl">"a &lt; b"</span></span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e ModuleScope">.<span class="e TemplateInstance"><span class="i">isSorted</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span>, <span class="t Identifier"><span class="i">Range</span></span></span>)</span></span>(<span class="i">r</span>)</span>;</span>
}</span></span></span></span></span>

<span class="lc">// // makeIndex</span>
<span class="lc">// /**</span>
<span class="lc">// Computes an index for $(D r) based on the comparison $(D less). The</span>
<span class="lc">// returned index is a sorted array of iterators into the original</span>
<span class="lc">// range. This technique is similar to sorting, but it is more flexible</span>
<span class="lc">// because (1) it allows "sorting" of invariant collections, (2) allows</span>
<span class="lc">// binary search even if the original collection does not offer random</span>
<span class="lc">// access, (3) allows multiple indexes, each on a different predicate,</span>
<span class="lc">// and (4) may be faster when dealing with large objects. However, using</span>
<span class="lc">// an index may also be slower under certain circumstances due to the</span>
<span class="lc">// extra indirection, and is always larger than a sorting-based solution</span>
<span class="lc">// because it needs space for the index in addition to the original</span>
<span class="lc">// collection. The complexity is the same as $(D sort)'s.</span>

<span class="lc">// Example:</span>

<span class="lc">// ----</span>
<span class="lc">// invariant arr = [ 2, 3, 1 ];</span>
<span class="lc">// auto index = makeIndex!(less)(arr);</span>
<span class="lc">// assert(*index[0] == 1 &amp;&amp; *index[1] == 2 &amp;&amp; *index[2] == 3);</span>
<span class="lc">// assert(isSorted!("*a &lt; *b")(index));</span>
<span class="lc">// ----</span>
<span class="lc">// */</span>
<span class="lc">// Iterator!(Range)[] makeIndex(</span>
<span class="lc">//     alias less,</span>
<span class="lc">//     SwapStrategy ss = SwapStrategy.unstable,</span>
<span class="lc">//     alias iterSwap = .iterSwap,</span>
<span class="lc">//     Range)(Range r)</span>
<span class="lc">// {</span>
<span class="lc">//     alias Iterator!(Range) Iter;</span>
<span class="lc">//     auto result = new Iter[r.length];</span>
<span class="lc">//     // assume collection already ordered</span>
<span class="lc">//     size_t i = 0;</span>
<span class="lc">//     foreach (it; begin(r) .. end(r))</span>
<span class="lc">//     {</span>
<span class="lc">//         result[i++] = it;</span>
<span class="lc">//     }</span>
<span class="lc">//     // sort the index</span>
<span class="lc">//     static bool indirectLess(Iter a, Iter b)</span>
<span class="lc">//     {</span>
<span class="lc">//         return less(*a, *b);</span>
<span class="lc">//     }</span>
<span class="lc">//     sort!(indirectLess, ss, iterSwap)(result);</span>
<span class="lc">//     return result;</span>
<span class="lc">// }</span>


<span class="lc">// /// Ditto</span>
<span class="lc">// Iterator!(Range)[] makeIndex(</span>
<span class="lc">//     string less = q{a &lt; b},</span>
<span class="lc">//     SwapStrategy ss = SwapStrategy.unstable,</span>
<span class="lc">//     alias iterSwap = .iterSwap,</span>
<span class="lc">//     Range)(Range r)</span>
<span class="lc">// {</span>
<span class="lc">//     return .makeIndex!(binaryFun!(less), ss, iterSwap, Range)(r);</span>
<span class="lc">// }</span>

<span class="lc">// topNIndexImpl</span>
<span class="lc">// @@@BUG1904</span>
<span class="bc">/*private*/</span> <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">topNIndexImpl</span><span class="o TemplateParameters">(
    <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span></span>,
    <span class="o TemplateValueParameter"><span class="t Integral"><span class="k">bool</span></span> <span class="i">sortAfter</span></span>,
    <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">SwapStrategy</span></span> <span class="i">ss</span></span>,
    <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span></span>,
    <span class="o TemplateTypeParameter"><span class="i">SRange</span></span>, <span class="o TemplateTypeParameter"><span class="i">TRange</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">SRange</span></span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">TRange</span></span> <span class="i">target</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span> <span class="i">lessFun</span>;</span></span></span>
    <span class="s StaticAssert"><span class="k">static</span> <span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">ss</span></span> == <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">unstable</span></span></span></span>,
                  <span class="e String"><span class="sl">"Stable indexing not yet implemented"</span></span>);</span>
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">SRange</span></span></span>)</span> <span class="i">SIter</span>;</span></span></span>
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">ElementType</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">TRange</span></span></span>)</span> <span class="i">TElem</span>;</span></span></span>
    <span class="d StorageClass"><span class="k">enum</span> <span class="d Variables"><span class="i">usingInt</span> = <span class="e TemplateInstance"><span class="i">isIntegral</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">TElem</span></span></span>)</span>;</span></span>

    <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">usingInt</span></span>)
    <span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">enforce</span></span>(<span class="i">source</span>.<span class="i">length</span> &lt;= <span class="i">TElem</span>.<span class="i">max</span>,
                <span class="sl">"Numeric overflow at risk in computing topNIndexImpl"</span>)</span>;</span>
    }</span></span>

    <span class="lc">// types and functions used within</span>
    <span class="s Declaration"><span class="d Function"><span class="t Identifier"><span class="i">SIter</span></span> <span class="i">index2iter</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">TElem</span></span> <span class="i">a</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Not">!<span class="e Identifier"><span class="i">usingInt</span></span></span>)
            <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">a</span></span>;</span>
        <span class="k">else</span>
            <span class="s Return"><span class="k">return</span> <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">source</span>)</span> + <span class="e Identifier"><span class="i">a</span></span></span>;</span></span>
    }</span></span></span></span>
    <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">indirectLess</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">TElem</span></span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">TElem</span></span> <span class="i">b</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">lessFun</span></span>(*<span class="i">index2iter</span>(<span class="i">a</span>), *<span class="i">index2iter</span>(<span class="i">b</span>))</span>;</span>
    }</span></span></span></span>
    <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">indirectCopy</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">SIter</span></span> <span class="i">from</span></span>, <span class="o Parameter"><span class="k">ref</span> <span class="t Identifier"><span class="i">TElem</span></span> <span class="i">to</span></span>)</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Not">!<span class="e Identifier"><span class="i">usingInt</span></span></span>)
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">to</span></span> = <span class="e Identifier"><span class="i">from</span></span></span>;</span>
        <span class="k">else</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">to</span></span> = <span class="e Cast"><span class="k">cast</span>(<span class="t Identifier"><span class="i">TElem</span></span>)<span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">from</span></span> - <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">source</span>)</span></span>)</span></span></span>;</span></span>
    }</span></span></span></span>

    <span class="lc">// copy beginning of collection into the target</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">sb</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">source</span>)</span>, <span class="i">se</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">source</span>)</span>,
        <span class="i">tb</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">target</span>)</span>, <span class="i">te</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">target</span>)</span>;</span></span>
    <span class="s For"><span class="k">for</span> (; <span class="e Equal"><span class="e Identifier"><span class="i">sb</span></span> != <span class="e Identifier"><span class="i">se</span></span></span>; <span class="e Comma"><span class="e PreIncr">++<span class="e Identifier"><span class="i">sb</span></span></span>, <span class="e PreIncr">++<span class="e Identifier"><span class="i">tb</span></span></span></span>)
    <span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">tb</span></span> == <span class="e Identifier"><span class="i">te</span></span></span>) <span class="s Break"><span class="k">break</span>;</span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">indirectCopy</span></span>(<span class="i">sb</span>, *<span class="i">tb</span>)</span>;</span>
    }</span></span>

    <span class="lc">// if the index's size is same as the source size, just quicksort it</span>
    <span class="lc">// otherwise, heap-insert stuff in it.</span>
    <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">sb</span></span> == <span class="e Identifier"><span class="i">se</span></span></span>)
    <span class="s Compound">{
        <span class="lc">// everything in source is now in target... just sort the thing</span>
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">sortAfter</span></span>) <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">sort</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">indirectLess</span></span>, <span class="t Identifier"><span class="i">ss</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">target</span>)</span>;</span></span>
    }</span>
    <span class="k">else</span>
    <span class="s Compound">{
        <span class="lc">// heap-insert</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">te</span></span> = <span class="e Identifier"><span class="i">tb</span></span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">tb</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">target</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">target</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">range</span></span>(<span class="i">tb</span>, <span class="i">te</span>)</span></span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">makeHeap</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">indirectLess</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">target</span>)</span>;</span>
        <span class="lc">// add stuff to heap</span>
        <span class="s For"><span class="k">for</span> (; <span class="e Equal"><span class="e Identifier"><span class="i">sb</span></span> != <span class="e Identifier"><span class="i">se</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">sb</span></span></span>)
        <span class="s Compound">{
            <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">lessFun</span></span></span>(*<span class="i">sb</span>, *<span class="i">index2iter</span>(*<span class="i">tb</span>))</span>) <span class="s Continue"><span class="k">continue</span>;</span></span>
            <span class="lc">// copy the source over the smallest</span>
            <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">indirectCopy</span></span>(<span class="i">sb</span>, *<span class="i">tb</span>)</span>;</span>
            <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">heapify</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">indirectLess</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">target</span>, <span class="i">tb</span>)</span>;</span>
        }</span></span>
        <span class="s StaticIf"><span class="k">static</span> <span class="k">if</span> (<span class="e Identifier"><span class="i">sortAfter</span></span>) <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">sortHeap</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">indirectLess</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">target</span>)</span>;</span></span>
    }</span></span>
}</span></span></span></span></span>

<span class="bc">/**
topNIndex
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">topNIndex</span><span class="o TemplateParameters">(
    <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span></span>,
    <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">SwapStrategy</span></span> <span class="i">ss</span> = <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">unstable</span></span></span></span>,
    <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>,
    <span class="o TemplateTypeParameter"><span class="i">SRange</span></span>, <span class="o TemplateTypeParameter"><span class="i">TRange</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">SRange</span></span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">TRange</span></span> <span class="i">target</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e ModuleScope">.<span class="e TemplateInstance"><span class="i">topNIndexImpl</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="e Bool"><span class="k">false</span></span>, <span class="t Identifier"><span class="i">ss</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span></span>(<span class="i">source</span>, <span class="i">target</span>)</span>;</span>
}</span></span></span></span></span>

<span class="lc">/// Ditto</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">topNIndex</span><span class="o TemplateParameters">(
    <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">string</span></span> <span class="i">less</span></span>,
    <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">SwapStrategy</span></span> <span class="i">ss</span> = <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">unstable</span></span></span></span>,
    <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>,
    <span class="o TemplateTypeParameter"><span class="i">SRange</span></span>, <span class="o TemplateTypeParameter"><span class="i">TRange</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">SRange</span></span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">TRange</span></span> <span class="i">target</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e ModuleScope">.<span class="e TemplateInstance"><span class="i">topNIndexImpl</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span>, <span class="e Bool"><span class="k">false</span></span>, <span class="t Identifier"><span class="i">ss</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span></span>(<span class="i">source</span>, <span class="i">target</span>)</span>;</span>
}</span></span></span></span></span>

<span class="lc">// partialIndex</span>
<span class="bc">/**
Computes an index for $(D source) based on the comparison $(D less)
and deposits the result in $(D target). It is acceptable that $(D
target.length &lt; source.length), in which case only the smallest $(D
target.length) elements in $(D source) get indexed. The target
provides a sorted "view" into $(D source). This technique is similar
to sorting and partial sorting, but it is more flexible because (1) it
allows "sorting" of invariant collections, (2) allows binary search
even if the original collection does not offer random access, (3)
allows multiple indexes, each on a different comparison criterion, (4)
may be faster when dealing with large objects. However, using an index
may also be slower under certain circumstances due to the extra
indirection, and is always larger than a sorting-based solution
because it needs space for the index in addition to the original
collection. The complexity is $(BIGOH source.length *
log(target.length)).

Two types of indexes are accepted. They are selected by simply passing
the appropriate $(D target) argument: $(OL $(LI Indexes of type $(D
Iterator!(Source)), in which case the index will be sorted with the
predicate $(D less(*a, *b));) $(LI Indexes of an integral type
(e.g. $(D size_t)), in which case the index will be sorted with the
predicate $(D less(source[a], source[b])).))

Example:

----
invariant arr = [ 2, 3, 1 ];
int* index[3];
partialIndex(arr, index);
assert(*index[0] == 1 &amp;&amp; *index[1] == 2 &amp;&amp; *index[2] == 3);
assert(isSorted!("*a &lt; *b")(index));
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">partialIndex</span><span class="o TemplateParameters">(
    <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span></span>,
    <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">SwapStrategy</span></span> <span class="i">ss</span> = <span class="e Dot"><span class="e Identifier"><span class="i">SwapStrategy</span></span>.<span class="e Identifier"><span class="i">unstable</span></span></span></span>,
    <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>,
    <span class="o TemplateTypeParameter"><span class="i">SRange</span></span>, <span class="o TemplateTypeParameter"><span class="i">TRange</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">SRange</span></span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">TRange</span></span> <span class="i">target</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e ModuleScope">.<span class="e TemplateInstance"><span class="i">topNIndexImpl</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="e Bool"><span class="k">true</span></span>, <span class="t Identifier"><span class="i">ss</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span></span>(<span class="i">source</span>, <span class="i">target</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">invariant</span> <span class="d Variables"><span class="i">arr</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">1</span></span> ]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">index</span> = <span class="e New"><span class="k">new</span> <span class="t Invariant"><span class="k">invariant</span>(<span class="t Integral"><span class="k">int</span></span>)</span><span class="t Pointer">*</span><span class="t Array">[<span class="e Int"><span class="n">3</span></span>]</span></span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">partialIndex</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &lt; b"</span></span></span>)</span></span>)</span>(<span class="i">arr</span>, <span class="i">index</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e AndAnd"><span class="e Equal"><span class="e Index"><span class="e Deref">*<span class="e Identifier"><span class="i">index</span></span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e Int"><span class="n">1</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Deref">*<span class="e Identifier"><span class="i">index</span></span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e Int"><span class="n">2</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Deref">*<span class="e Identifier"><span class="i">index</span></span></span>[<span class="e Int"><span class="n">2</span></span>]</span> == <span class="e Int"><span class="n">3</span></span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isSorted</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"*a &lt; *b"</span></span></span>)</span>(<span class="i">index</span>)</span>)</span>;</span>
}</span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">static</span> <span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">less</span><span class="o Parameters">(<span class="o Parameter"><span class="t Integral"><span class="k">int</span></span> <span class="i">a</span></span>, <span class="o Parameter"><span class="t Integral"><span class="k">int</span></span> <span class="i">b</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Rel"><span class="e Identifier"><span class="i">a</span></span> &lt; <span class="e Identifier"><span class="i">b</span></span></span>;</span> }</span></span></span></span>
    <span class="s Scope"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">string</span></span><span class="t Array">[]</span> <span class="i">x</span> = <span class="e Dot"><span class="e Paren">(<span class="e ArrayLiteral">[ <span class="e String"><span class="sl">"c"</span></span>, <span class="e String"><span class="sl">"a"</span></span>, <span class="e String"><span class="sl">"b"</span></span>, <span class="e String"><span class="sl">"d"</span></span> ]</span>)</span>.<span class="e Identifier"><span class="i">dup</span></span></span>;</span></span>
        <span class="lc">// test with integrals</span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">index1</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">size_t</span></span><span class="t Array">[<span class="t Qualified"><span class="t Identifier"><span class="i">x</span></span>.<span class="t Identifier"><span class="i">length</span></span></span>]</span></span>;</span></span>
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">partialIndex</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">q{a &lt; b}</span></span></span>)</span>(<span class="i">x</span>, <span class="i">index1</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">index1</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e Int"><span class="n">1</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">index1</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e Int"><span class="n">2</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">index1</span></span>[<span class="e Int"><span class="n">2</span></span>]</span> == <span class="e Int"><span class="n">0</span></span></span></span>
               &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">index1</span></span>[<span class="e Int"><span class="n">3</span></span>]</span> == <span class="e Int"><span class="n">3</span></span></span></span>)</span>;</span>
        <span class="lc">// half-sized</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">index1</span></span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">size_t</span></span><span class="t Array">[<span class="e Div"><span class="e Dot"><span class="e Identifier"><span class="i">x</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> / <span class="e Int"><span class="n">2</span></span></span>]</span></span></span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">partialIndex</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">q{a &lt; b}</span></span></span>)</span>(<span class="i">x</span>, <span class="i">index1</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">index1</span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e Int"><span class="n">1</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Identifier"><span class="i">index1</span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e Int"><span class="n">2</span></span></span></span>)</span>;</span>

        <span class="lc">// and with iterators</span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">index</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">string</span></span><span class="t Pointer">*</span><span class="t Array">[<span class="t Qualified"><span class="t Identifier"><span class="i">x</span></span>.<span class="t Identifier"><span class="i">length</span></span></span>]</span></span>;</span></span>
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">partialIndex</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">q{a &lt; b}</span></span></span>)</span>(<span class="i">x</span>, <span class="i">index</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isSorted</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">q{*a &lt; *b}</span></span></span>)</span>(<span class="i">index</span>)</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e AndAnd"><span class="e AndAnd"><span class="e Equal"><span class="e Index"><span class="e Deref">*<span class="e Identifier"><span class="i">index</span></span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e String"><span class="sl">"a"</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Deref">*<span class="e Identifier"><span class="i">index</span></span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e String"><span class="sl">"b"</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Deref">*<span class="e Identifier"><span class="i">index</span></span></span>[<span class="e Int"><span class="n">2</span></span>]</span> == <span class="e String"><span class="sl">"c"</span></span></span></span>
               &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Deref">*<span class="e Identifier"><span class="i">index</span></span></span>[<span class="e Int"><span class="n">3</span></span>]</span> == <span class="e String"><span class="sl">"d"</span></span></span></span>)</span>;</span>
    }</span></span>

    <span class="s Scope"><span class="s Compound">{
        <span class="d StorageClass"><span class="k">invariant</span> <span class="d Variables"><span class="i">arr</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">1</span></span> ]</span>;</span></span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">index</span> = <span class="e New"><span class="k">new</span> <span class="t Invariant"><span class="k">invariant</span>(<span class="t Integral"><span class="k">int</span></span>)</span><span class="t Pointer">*</span><span class="t Array">[<span class="t Qualified"><span class="t Identifier"><span class="i">arr</span></span>.<span class="t Identifier"><span class="i">length</span></span></span>]</span></span>;</span></span>
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">partialIndex</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span>(<span class="i">arr</span>, <span class="i">index</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e AndAnd"><span class="e Equal"><span class="e Index"><span class="e Deref">*<span class="e Identifier"><span class="i">index</span></span></span>[<span class="e Int"><span class="n">0</span></span>]</span> == <span class="e Int"><span class="n">1</span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Deref">*<span class="e Identifier"><span class="i">index</span></span></span>[<span class="e Int"><span class="n">1</span></span>]</span> == <span class="e Int"><span class="n">2</span></span></span></span> &amp;&amp; <span class="e Equal"><span class="e Index"><span class="e Deref">*<span class="e Identifier"><span class="i">index</span></span></span>[<span class="e Int"><span class="n">2</span></span>]</span> == <span class="e Int"><span class="n">3</span></span></span></span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isSorted</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">q{*a &lt; *b}</span></span></span>)</span>(<span class="i">index</span>)</span>)</span>;</span>
    }</span></span>

    <span class="lc">// random data</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">b</span> = <span class="e TemplateInstance"><span class="i">rndstuff</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">string</span></span></span>)</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">index</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">string</span></span><span class="t Pointer">*</span><span class="t Array">[<span class="t Qualified"><span class="t Identifier"><span class="i">b</span></span>.<span class="t Identifier"><span class="i">length</span></span></span>]</span></span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">partialIndex</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"toupper(a) &lt; toupper(b)"</span></span></span>)</span>(<span class="i">b</span>, <span class="i">index</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isSorted</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"toupper(*a) &lt; toupper(*b)"</span></span></span>)</span>(<span class="i">index</span>)</span>)</span>;</span>

    <span class="lc">// random data with indexes</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">index1</span> = <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">size_t</span></span><span class="t Array">[<span class="t Qualified"><span class="t Identifier"><span class="i">b</span></span>.<span class="t Identifier"><span class="i">length</span></span></span>]</span></span>;</span></span>
    <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">cmp</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">string</span></span> <span class="i">x</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">string</span></span> <span class="i">y</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Rel"><span class="e Call"><span class="e Identifier"><span class="i">toupper</span></span>(<span class="i">x</span>)</span> &lt; <span class="e Call"><span class="e Identifier"><span class="i">toupper</span></span>(<span class="i">y</span>)</span></span>;</span> }</span></span></span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">partialIndex</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">cmp</span></span></span>)</span>(<span class="i">b</span>, <span class="i">index1</span>)</span>;</span>
    <span class="s Declaration"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">check</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">x</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">y</span></span>)</span> <span class="s FuncBody"><span class="s Compound">{ <span class="s Return"><span class="k">return</span> <span class="e Rel"><span class="e Call"><span class="e Identifier"><span class="i">toupper</span></span>(<span class="i">b</span>[<span class="i">x</span>])</span> &lt; <span class="e Call"><span class="e Identifier"><span class="i">toupper</span></span>(<span class="i">b</span>[<span class="i">y</span>])</span></span>;</span> }</span></span></span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isSorted</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">check</span></span></span>)</span>(<span class="i">index1</span>)</span>)</span>;</span>
}</span></span></span>

<span class="lc">// Commented out for now, needs reimplementation</span>
 
<span class="lc">// // schwartzMakeIndex</span>
<span class="lc">// /**</span>
<span class="lc">// Similar to $(D makeIndex) but using $(D schwartzSort) to sort the</span>
<span class="lc">// index.</span>

<span class="lc">// Example:</span>

<span class="lc">// ----</span>
<span class="lc">// string[] arr = [ "ab", "c", "Ab", "C" ];</span>
<span class="lc">// auto index = schwartzMakeIndex!(toupper, less, SwapStrategy.stable)(arr);</span>
<span class="lc">// assert(*index[0] == "ab" &amp;&amp; *index[1] == "Ab"</span>
<span class="lc">//     &amp;&amp; *index[2] == "c" &amp;&amp; *index[2] == "C");</span>
<span class="lc">// assert(isSorted!("toupper(*a) &lt; toupper(*b)")(index));</span>
<span class="lc">// ----</span>
<span class="lc">// */</span>
<span class="lc">// Iterator!(Range)[] schwartzMakeIndex(</span>
<span class="lc">//     alias transform,</span>
<span class="lc">//     alias less,</span>
<span class="lc">//     SwapStrategy ss = SwapStrategy.unstable,</span>
<span class="lc">//     alias iterSwap = .iterSwap,</span>
<span class="lc">//     Range)(Range r)</span>
<span class="lc">// {</span>
<span class="lc">//     alias Iterator!(Range) Iter;</span>
<span class="lc">//     auto result = new Iter[r.length];</span>
<span class="lc">//     // assume collection already ordered</span>
<span class="lc">//     size_t i = 0;</span>
<span class="lc">//     foreach (it; begin(r) .. end(r))</span>
<span class="lc">//     {</span>
<span class="lc">//         result[i++] = it;</span>
<span class="lc">//     }</span>
<span class="lc">//     // sort the index</span>
<span class="lc">//     alias typeof(transform(*result[0])) Transformed;</span>
<span class="lc">//     static bool indirectLess(Transformed a, Transformed b)</span>
<span class="lc">//     {</span>
<span class="lc">//         return less(a, b);</span>
<span class="lc">//     }</span>
<span class="lc">//     static Transformed indirectTransform(Iter a)</span>
<span class="lc">//     {</span>
<span class="lc">//         return transform(*a);</span>
<span class="lc">//     }</span>
<span class="lc">//     schwartzSort!(indirectTransform, less, ss)(result);</span>
<span class="lc">//     return result;</span>
<span class="lc">// }</span>

<span class="lc">// /// Ditto</span>
<span class="lc">// Iterator!(Range)[] schwartzMakeIndex(</span>
<span class="lc">//     alias transform,</span>
<span class="lc">//     string less = q{a &lt; b},</span>
<span class="lc">//     SwapStrategy ss = SwapStrategy.unstable,</span>
<span class="lc">//     alias iterSwap = .iterSwap,</span>
<span class="lc">//     Range)(Range r)</span>
<span class="lc">// {</span>
<span class="lc">//     return .schwartzMakeIndex!(</span>
<span class="lc">//         transform, binaryFun!(less), ss, iterSwap, Range)(r);</span>
<span class="lc">// }</span>

<span class="lc">// version (wyda) unittest</span>
<span class="lc">// {</span>
<span class="lc">//     string[] arr = [ "D", "ab", "c", "Ab", "C" ];</span>
<span class="lc">//     auto index = schwartzMakeIndex!(toupper, "a &lt; b",</span>
<span class="lc">//                                     SwapStrategy.stable)(arr);</span>
<span class="lc">//     assert(isSorted!(q{toupper(*a) &lt; toupper(*b)})(index));</span>
<span class="lc">//     assert(*index[0] == "ab" &amp;&amp; *index[1] == "Ab"</span>
<span class="lc">//            &amp;&amp; *index[2] == "c" &amp;&amp; *index[3] == "C");</span>

<span class="lc">//     // random data</span>
<span class="lc">//     auto b = rndstuff!(string);</span>
<span class="lc">//     auto index1 = schwartzMakeIndex!(toupper)(b);</span>
<span class="lc">//     assert(isSorted!("toupper(*a) &lt; toupper(*b)")(index1));</span>
<span class="lc">// }</span>

<span class="lc">// schwartzIsSorted</span>
<span class="bc">/**
Checks whether a random-access range is sorted according to the
comparison operation $(D less(transform(a), transform(b))). Performs
$(BIGOH r.length) evaluations of $(D less) and $(D transform). The
advantage over $(D isSorted) is that it evaluates $(D transform) only
half as many times.

   Example:

----
int[] arr = [ "ab", "Ab", "aB", "bc", "Bc" ];
assert(!schwartzIsSorted!(toupper, "a &lt; b")(arr));
----
*/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">schwartzIsSorted</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">transform</span></span>, <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">isEmpty</span></span>(<span class="i">r</span>)</span>) <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">i</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span>, <span class="i">e</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">last</span> = <span class="e Call"><span class="e Identifier"><span class="i">transform</span></span>(*<span class="i">i</span>)</span>;</span></span>
    <span class="s For"><span class="k">for</span> (<span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>;</span> <span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> != <span class="e Identifier"><span class="i">e</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">i</span></span></span>)
    <span class="s Compound">{
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">next</span> = <span class="e Call"><span class="e Identifier"><span class="i">transform</span></span>(*<span class="i">i</span>)</span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">less</span></span>(<span class="i">next</span>, <span class="i">last</span>)</span>) <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">false</span></span>;</span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">move</span></span>(<span class="i">next</span>, <span class="i">last</span>)</span>;</span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Bool"><span class="k">true</span></span>;</span>
}</span></span></span></span></span>

<span class="lc">/// Ditto</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">schwartzIsSorted</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">transform</span></span>, <span class="o TemplateValueParameter"><span class="t Identifier"><span class="i">string</span></span> <span class="i">less</span> = <span class="e String"><span class="sl">"a &lt; b"</span></span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e ModuleScope">.<span class="e TemplateInstance"><span class="i">schwartzIsSorted</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">transform</span></span>, <span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span>, <span class="t Identifier"><span class="i">Range</span></span></span>)</span></span>(<span class="i">r</span>)</span>;</span>
}</span></span></span></span></span>
      
<span class="lc">// lowerBound</span>
<span class="bc">/**
Returns the leftmost position in $(D range) such that all other values
$(D x) to the left of that position satisfy $(D less(x,
value)). Performs $(BIGOH log(r.length)) evaluations of $(D less). See
also STL's $(WEB sgi.com/tech/stl/lower_bound.html, lower_bound).

Precondition:
$(D isSorted!(less)(r))

Returns:
$(D i) such that $(D less(*p, i)) for all p in $(D [begin(r), i$(RPAREN)).

Example:
----
int[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];
auto p = lowerBound!(less)(a, 4);
assert(*p == 4);
p = lowerBound(a, 4); // uses less by default
assert(*p == 4);
p = lowerBound!("a &lt; b")(a, 4); // predicate as string
assert(*p == 4);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range</span></span></span>)</span> <span class="i">lowerBound</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span> = <span class="sl">"a &lt; b"</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>, <span class="o TemplateTypeParameter"><span class="i">V</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">V</span></span> <span class="i">value</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">first</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">count</span> = <span class="e Minus"><span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span> - <span class="e Identifier"><span class="i">first</span></span></span>;</span></span>
    <span class="s While"><span class="k">while</span> (<span class="e Rel"><span class="e Identifier"><span class="i">count</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span>)
    <span class="s Compound">{
        <span class="d StorageClass"><span class="k">invariant</span> <span class="d Variables"><span class="i">step</span> = <span class="e Div"><span class="e Identifier"><span class="i">count</span></span> / <span class="e Int"><span class="n">2</span></span></span>;</span></span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">it</span> = <span class="e Plus"><span class="e Identifier"><span class="i">first</span></span> + <span class="e Identifier"><span class="i">step</span></span></span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span>(*<span class="i">it</span>, <span class="i">value</span>)</span>)
        <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">it</span></span> + <span class="e Int"><span class="n">1</span></span></span></span>;</span>
            <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">count</span></span> -= <span class="e Plus"><span class="e Identifier"><span class="i">step</span></span> + <span class="e Int"><span class="n">1</span></span></span></span>;</span>
        }</span>
        <span class="k">else</span>
        <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">count</span></span> = <span class="e Identifier"><span class="i">step</span></span></span>;</span>
        }</span></span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">first</span></span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">0</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">8</span></span>, <span class="e Int"><span class="n">9</span></span> ]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">p</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">lowerBound</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &lt; b"</span></span></span>)</span>(<span class="i">a</span>, <span class="n">4</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Deref">*<span class="e Identifier"><span class="i">p</span></span></span> == <span class="e Int"><span class="n">4</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">p</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">lowerBound</span></span>(<span class="i">a</span>, <span class="n">5</span>)</span></span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Deref">*<span class="e Identifier"><span class="i">p</span></span></span> == <span class="e Int"><span class="n">5</span></span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">p</span></span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">lowerBound</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">q{a &lt; b}</span></span></span>)</span>(<span class="i">a</span>, <span class="n">6</span>)</span></span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Deref">*<span class="e Identifier"><span class="i">p</span></span></span> == <span class="e Int"><span class="n">6</span></span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// upperBound</span>
<span class="bc">/**
Returns the rightmost position in $(D r) such that all other elements
$(D x) to the left of that position satisfy $(D !less(value, x)).
Performs $(BIGOH log(r.length)) evaluations of $(D less). See also
STL's $(WEB sgi.com/tech/stl/upper_bound.html, upper_bound).

Precondition:
$(D isSorted!(less)(r))

Returns: $(D i) such that $(D less(*p, value)) for all p in $(D
[begin(r), i$(RPAREN)).

Example:
----
auto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];
auto p = upperBound(a, 3);
assert(p == begin(a) + 5);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t TemplateInstance"><span class="i">Iterator</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">Range</span></span></span>)</span> <span class="i">upperBound</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span> = <span class="sl">"a &lt; b"</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>, <span class="o TemplateTypeParameter"><span class="i">V</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">V</span></span> <span class="i">value</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">first</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">count</span> = <span class="e Minus"><span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span> - <span class="e Identifier"><span class="i">first</span></span></span>;</span></span>
    <span class="s While"><span class="k">while</span> (<span class="e Rel"><span class="e Identifier"><span class="i">count</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span>)
    <span class="s Compound">{
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">step</span> = <span class="e Div"><span class="e Identifier"><span class="i">count</span></span> / <span class="e Int"><span class="n">2</span></span></span>;</span></span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">it</span> = <span class="e Plus"><span class="e Identifier"><span class="i">first</span></span> + <span class="e Identifier"><span class="i">step</span></span></span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Not">!<span class="e TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span></span>(<span class="i">value</span>,*<span class="i">it</span>)</span>)
        <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">it</span></span> + <span class="e Int"><span class="n">1</span></span></span></span>;</span>
            <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">count</span></span> -= <span class="e Plus"><span class="e Identifier"><span class="i">step</span></span> + <span class="e Int"><span class="n">1</span></span></span></span>;</span>
        }</span>
        <span class="k">else</span> <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">count</span></span> = <span class="e Identifier"><span class="i">step</span></span></span>;</span></span>
  }</span></span>
  <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">first</span></span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span> ]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">p</span> = <span class="e Call"><span class="e Identifier"><span class="i">upperBound</span></span>(<span class="i">a</span>, <span class="n">3</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">p</span></span> == <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">a</span>)</span> + <span class="e Int"><span class="n">5</span></span></span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// equalRange</span>
<span class="bc">/**
The call $(D equalRange!(less)(r, v)) returns $(D range($(D
lowerBound!(less)(r, v), $(D upperBound!(less)(r, v))))) but a bit
more efficiently than calling both functions.  Performs $(BIGOH
log(r.length)) evaluations of $(D less). See also STL's $(WEB
sgi.com/tech/stl/equal_range.html, equal_range).

Precondition:
$(D isSorted!(less)(range))

Returns:

The largest subrange of $(D r) such that for all $(D p) in that range,
$(D !less(*p, value) &amp;&amp; !less(value, *p)).

Example:
----
auto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];
auto r = equalRange(a, 3);
assert(r == [ 3, 3, 3 ]);
----
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">equalRange</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span> = <span class="sl">"a &lt; b"</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>, <span class="o TemplateTypeParameter"><span class="i">V</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">V</span></span> <span class="i">value</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Alias"><span class="k">alias</span> <span class="d Variables"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span> <span class="i">lessFun</span>;</span></span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">first</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span>, <span class="i">last</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span>;</span></span>
    <span class="s For"><span class="k">for</span> (<span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">count</span> = <span class="e Minus"><span class="e Identifier"><span class="i">last</span></span> - <span class="e Identifier"><span class="i">first</span></span></span>;</span></span> <span class="e Rel"><span class="e Identifier"><span class="i">count</span></span> &gt; <span class="e Int"><span class="n">0</span></span></span>; )
    <span class="s Compound">{
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">step</span> = <span class="e Div"><span class="e Identifier"><span class="i">count</span></span> / <span class="e Int"><span class="n">2</span></span></span>;</span></span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">middle</span> = <span class="e Plus"><span class="e Identifier"><span class="i">first</span></span> + <span class="e Identifier"><span class="i">step</span></span></span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">lessFun</span></span>(*<span class="i">middle</span>, <span class="i">value</span>)</span>)
        <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span> = <span class="e Plus"><span class="e Identifier"><span class="i">middle</span></span> + <span class="e Int"><span class="n">1</span></span></span></span>;</span>
            <span class="s Expression"><span class="e MinusAssign"><span class="e Identifier"><span class="i">count</span></span> -= <span class="e Plus"><span class="e Identifier"><span class="i">step</span></span> + <span class="e Int"><span class="n">1</span></span></span></span>;</span>
        }</span>
        <span class="k">else</span> <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">lessFun</span></span>(<span class="i">value</span>, *<span class="i">middle</span>)</span>)
        <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">count</span></span> = <span class="e Identifier"><span class="i">step</span></span></span>;</span>
        }</span>
        <span class="k">else</span>
        <span class="s Compound">{
            <span class="lc">// we're straight in the range!</span>
            <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">left</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">lowerBound</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span>(<span class="i">range</span>(<span class="i">first</span>, <span class="i">middle</span>), <span class="i">value</span>)</span>;</span></span>
            <span class="s Expression"><span class="e PlusAssign"><span class="e Identifier"><span class="i">first</span></span> += <span class="e Identifier"><span class="i">count</span></span></span>;</span>
            <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">right</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">upperBound</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span>(<span class="i">range</span>(++<span class="i">middle</span>, <span class="i">first</span>), <span class="i">value</span>)</span>;</span></span>
            <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">range</span></span>(<span class="i">left</span>, <span class="i">right</span>)</span>;</span>
        }</span></span></span>
    }</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e Call"><span class="e Identifier"><span class="i">range</span></span>(<span class="i">first</span>, <span class="i">first</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">5</span></span>, <span class="e Int"><span class="n">6</span></span> ]</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">p</span> = <span class="e Call"><span class="e Identifier"><span class="i">equalRange</span></span>(<span class="i">a</span>, <span class="n">3</span>)</span>;</span></span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">p</span></span> == <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">3</span></span> ]</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">p</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">equalRange</span></span>(<span class="i">a</span>, <span class="n">4</span>)</span></span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">p</span></span> == <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">4</span></span> ]</span></span>)</span>;</span>
    <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">p</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">equalRange</span></span>(<span class="i">a</span>, <span class="n">2</span>)</span></span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">p</span></span> == <span class="e ArrayLiteral">[ <span class="n">2</span> ]</span></span>)</span>;</span>
}</span></span></span>

<span class="lc">// canFindSorted</span>
<span class="bc">/**
Returns $(D true) if and only if $(D value) can be found in $(D
range), which is assumed to be sorted. Performs $(BIGOH log(r.length))
evaluations of $(D less). See also STL's $(WEB
sgi.com/tech/stl/binary_search.html, binary_search).
*/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">bool</span></span> <span class="i">canFindSorted</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span> = <span class="sl">"a &lt; b"</span></span>, <span class="o TemplateTypeParameter"><span class="i">T</span></span>, <span class="o TemplateTypeParameter"><span class="i">V</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">T</span></span> <span class="i">range</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">V</span></span> <span class="i">value</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">p</span> = <span class="e Call"><span class="e TemplateInstance"><span class="i">lowerBound</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span>(<span class="i">range</span>, <span class="i">value</span>)</span>;</span></span>
    <span class="s Return"><span class="k">return</span> <span class="e AndAnd"><span class="e Equal"><span class="e Identifier"><span class="i">p</span></span> != <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">range</span>)</span></span> &amp;&amp; <span class="e Call"><span class="e Not">!<span class="e TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span></span>)</span></span>(<span class="i">value</span>, *<span class="i">p</span>)</span></span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">a</span> = <span class="e TemplateInstance"><span class="i">rndstuff</span>!(<span class="o TemplateArguments"><span class="t Integral"><span class="k">int</span></span></span>)</span>;</span></span>
    <span class="s If"><span class="k">if</span> (<span class="e Dot"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span>)
    <span class="s Compound">{
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">b</span> = <span class="e Index"><span class="e Identifier"><span class="i">a</span></span>[<span class="e Div"><span class="e Dot"><span class="e Identifier"><span class="i">a</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> / <span class="e Int"><span class="n">2</span></span></span>]</span>;</span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">sort</span></span>(<span class="i">a</span>)</span>;</span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e Identifier"><span class="i">canFindSorted</span></span>(<span class="i">a</span>, <span class="i">b</span>)</span>)</span>;</span>
    }</span></span>
}</span></span></span>

<span class="bc">/**
Converts the range $(D r) into a heap. Performs $(BIGOH r.length)
evaluations of $(D less).
*/</span>

<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">makeHeap</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span> = <span class="sl">"a &lt; b"</span></span>, <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Dot"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> &lt; <span class="e Int"><span class="n">2</span></span></span>) <span class="s Return"><span class="k">return</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">i</span> = <span class="e Plus"><span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span> + <span class="e Div"><span class="e Paren">(<span class="e Minus"><span class="e Dot"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> - <span class="e Int"><span class="n">2</span></span></span>)</span> / <span class="e Int"><span class="n">2</span></span></span></span>;</span></span>
    <span class="s For"><span class="k">for</span> (;; <span class="e PreDecr">--<span class="e Identifier"><span class="i">i</span></span></span>)
    <span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">heapify</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">r</span>, <span class="i">i</span>)</span>;</span>
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">i</span></span> == <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span></span>) <span class="s Return"><span class="k">return</span>;</span></span>
    }</span></span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="lc">// example from "Introduction to Algorithms" Cormen et al., p 146</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">1</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">16</span></span>, <span class="e Int"><span class="n">9</span></span>, <span class="e Int"><span class="n">10</span></span>, <span class="e Int"><span class="n">14</span></span>, <span class="e Int"><span class="n">8</span></span>, <span class="e Int"><span class="n">7</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">makeHeap</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &lt; b"</span></span></span>)</span></span>)</span>(<span class="i">a</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">a</span></span> == <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">16</span></span>, <span class="e Int"><span class="n">14</span></span>, <span class="e Int"><span class="n">10</span></span>, <span class="e Int"><span class="n">8</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">9</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">1</span></span> ]</span></span>)</span>;</span>
}</span></span></span>

<span class="bc">/*private*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">heapify</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span></span>, <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>, <span class="o TemplateTypeParameter"><span class="i">It</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">It</span></span> <span class="i">i</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">b</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span>;</span></span>
    <span class="s For"><span class="k">for</span> (;;)
    <span class="s Compound">{
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">left</span> = <span class="e Plus"><span class="e Plus"><span class="e Identifier"><span class="i">b</span></span> + <span class="e Mul"><span class="e Paren">(<span class="e Minus"><span class="e Identifier"><span class="i">i</span></span> - <span class="e Identifier"><span class="i">b</span></span></span>)</span> * <span class="e Int"><span class="n">2</span></span></span></span> + <span class="e Int"><span class="n">1</span></span></span>, <span class="i">right</span> = <span class="e Plus"><span class="e Identifier"><span class="i">left</span></span> + <span class="e Int"><span class="n">1</span></span></span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">right</span></span> == <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span></span>)
        <span class="s Compound">{
            <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Identifier"><span class="i">less</span></span>(*<span class="i">i</span>, *<span class="i">left</span>)</span>) <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">i</span>, <span class="i">left</span>)</span>;</span></span>
            <span class="s Return"><span class="k">return</span>;</span>
        }</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">right</span></span> &gt; <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span></span>) <span class="s Return"><span class="k">return</span>;</span></span>
        <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e AndAnd"><span class="e Rel"><span class="e Identifier"><span class="i">left</span></span> &lt; <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span></span> &amp;&amp; <span class="e Rel"><span class="e Identifier"><span class="i">right</span></span> &lt; <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span></span></span>)</span>;</span>
        <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">largest</span> = <span class="e Cond"><span class="e Call"><span class="e Identifier"><span class="i">less</span></span>(*<span class="i">i</span>, *<span class="i">left</span>)</span>
            ? <span class="e Paren">(<span class="e Cond"><span class="e Call"><span class="e Identifier"><span class="i">less</span></span>(*<span class="i">left</span>, *<span class="i">right</span>)</span> ? <span class="e Identifier"><span class="i">right</span></span> : <span class="e Identifier"><span class="i">left</span></span></span>)</span>
            : <span class="e Paren">(<span class="e Cond"><span class="e Call"><span class="e Identifier"><span class="i">less</span></span>(*<span class="i">i</span>, *<span class="i">right</span>)</span> ? <span class="e Identifier"><span class="i">right</span></span> : <span class="e Identifier"><span class="i">i</span></span></span>)</span></span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">largest</span></span> == <span class="e Identifier"><span class="i">i</span></span></span>) <span class="s Return"><span class="k">return</span>;</span></span>
        <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">i</span>, <span class="i">largest</span>)</span>;</span>
        <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">i</span></span> = <span class="e Identifier"><span class="i">largest</span></span></span>;</span>
    }</span></span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="lc">// example from "Introduction to Algorithms" Cormen et al., p 143</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e ArrayInit">[ <span class="e Int"><span class="n">16</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">10</span></span>, <span class="e Int"><span class="n">14</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">9</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">8</span></span>, <span class="e Int"><span class="n">1</span></span> ]</span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">heapify</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &lt; b"</span></span></span>)</span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">a</span>, <span class="i">begin</span>(<span class="i">a</span>) + <span class="n">1</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Equal"><span class="e Identifier"><span class="i">a</span></span> == <span class="e ArrayLiteral">[ <span class="e Int"><span class="n">16</span></span>, <span class="e Int"><span class="n">14</span></span>, <span class="e Int"><span class="n">10</span></span>, <span class="e Int"><span class="n">8</span></span>, <span class="e Int"><span class="n">7</span></span>, <span class="e Int"><span class="n">9</span></span>, <span class="e Int"><span class="n">3</span></span>, <span class="e Int"><span class="n">2</span></span>, <span class="e Int"><span class="n">4</span></span>, <span class="e Int"><span class="n">1</span></span> ]</span></span>)</span>;</span>
}</span></span></span>

<span class="bc">/**
popHeap 
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">popHeap</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span></span>, <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Dot"><span class="e Identifier"><span class="i">r</span></span>.<span class="e Identifier"><span class="i">length</span></span></span> &lt;= <span class="e Int"><span class="n">1</span></span></span>) <span class="s Return"><span class="k">return</span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">newEnd</span> = <span class="e Minus"><span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span> - <span class="e Int"><span class="n">1</span></span></span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">iterSwap</span></span>(<span class="i">begin</span>(<span class="i">r</span>), <span class="i">newEnd</span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">heapify</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">range</span>(<span class="i">begin</span>(<span class="i">r</span>), <span class="i">newEnd</span>), <span class="i">begin</span>(<span class="i">r</span>))</span>;</span>
}</span></span></span></span></span>

<span class="bc">/**
sortHeap
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">sortHeap</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span></span>, <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>, <span class="o TemplateTypeParameter"><span class="i">Range</span></span>)</span><span class="o Parameters">(<span class="o Parameter"><span class="t Identifier"><span class="i">Range</span></span> <span class="i">r</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">b</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">r</span>)</span>, <span class="i">e</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">r</span>)</span>;</span></span>
    <span class="s For"><span class="k">for</span> (; <span class="e Rel"><span class="e Minus"><span class="e Identifier"><span class="i">e</span></span> - <span class="e Identifier"><span class="i">b</span></span></span> &gt; <span class="e Int"><span class="n">1</span></span></span>; <span class="e PreDecr">--<span class="e Identifier"><span class="i">e</span></span></span>)
    <span class="s Compound">{
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">popHeap</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">range</span>(<span class="i">b</span>, <span class="i">e</span>))</span>;</span>
    }</span></span>
}</span></span></span></span></span>

<span class="bc">/**
topNCopy 
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">topNCopy</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span></span>, <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>, <span class="o TemplateTypeParameter"><span class="i">SRange</span></span>, <span class="o TemplateTypeParameter"><span class="i">TRange</span></span>)</span><span class="o Parameters">(
    <span class="o Parameter"><span class="t Identifier"><span class="i">SRange</span></span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">TRange</span></span> <span class="i">target</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="lc">// make an initial heap in the target</span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">tb</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">target</span>)</span>, <span class="i">te</span> = <span class="e Identifier"><span class="i">tb</span></span>;</span></span>
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">sb</span> = <span class="e Call"><span class="e Identifier"><span class="i">begin</span></span>(<span class="i">source</span>)</span>, <span class="i">se</span> = <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">source</span>)</span>;</span></span>
    <span class="s For"><span class="k">for</span> (; <span class="e Equal"><span class="e Identifier"><span class="i">sb</span></span> != <span class="e Identifier"><span class="i">se</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">sb</span></span></span>)
    <span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Equal"><span class="e Identifier"><span class="i">te</span></span> == <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">target</span>)</span></span>) <span class="s Break"><span class="k">break</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">te</span></span></span> = <span class="e Deref">*<span class="e Identifier"><span class="i">sb</span></span></span></span>;</span>
        <span class="s Expression"><span class="e PreIncr">++<span class="e Identifier"><span class="i">te</span></span></span>;</span>
    }</span></span>
    <span class="s If"><span class="k">if</span> (<span class="e Rel"><span class="e Identifier"><span class="i">te</span></span> &lt; <span class="e Call"><span class="e Identifier"><span class="i">end</span></span>(<span class="i">target</span>)</span></span>) <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">target</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">range</span></span>(<span class="i">tb</span>, <span class="i">te</span>)</span></span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">makeHeap</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">target</span>)</span>;</span>

    <span class="lc">// now copy stuff into the target if it's smaller</span>
    <span class="s For"><span class="k">for</span> (; <span class="e Equal"><span class="e Identifier"><span class="i">sb</span></span> != <span class="e Identifier"><span class="i">se</span></span></span>; <span class="e PreIncr">++<span class="e Identifier"><span class="i">sb</span></span></span>)
    <span class="s Compound">{
        <span class="s If"><span class="k">if</span> (<span class="e Call"><span class="e Not">!<span class="e Identifier"><span class="i">less</span></span></span>(*<span class="i">sb</span>, *<span class="i">tb</span>)</span>) <span class="s Continue"><span class="k">continue</span>;</span></span>
        <span class="s Expression"><span class="e Assign"><span class="e Deref">*<span class="e Identifier"><span class="i">tb</span></span></span> = <span class="e Deref">*<span class="e Identifier"><span class="i">sb</span></span></span></span>;</span>
        <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">heapify</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">target</span>, <span class="i">tb</span>)</span>;</span>
    }</span></span>
}</span></span></span></span></span>

<span class="bc">/**
partialSortCopy
*/</span>
<span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">void</span></span> <span class="i">partialSortCopy</span><span class="o TemplateParameters">(<span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">less</span></span>, <span class="o TemplateAliasParameter"><span class="k">alias</span> <span class="i">iterSwap</span> = <span class="t Qualified"><span class="t ModuleScope">.</span><span class="t Identifier"><span class="i">iterSwap</span></span></span></span>, <span class="o TemplateTypeParameter"><span class="i">SRange</span></span>, <span class="o TemplateTypeParameter"><span class="i">TRange</span></span>)</span><span class="o Parameters">(
    <span class="o Parameter"><span class="t Identifier"><span class="i">SRange</span></span> <span class="i">source</span></span>, <span class="o Parameter"><span class="t Identifier"><span class="i">TRange</span></span> <span class="i">target</span></span>)</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">topNCopy</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">source</span>, <span class="i">target</span>)</span>;</span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">sortHeap</span>!(<span class="o TemplateArguments"><span class="t Identifier"><span class="i">less</span></span>, <span class="t Identifier"><span class="i">iterSwap</span></span></span>)</span>(<span class="i">target</span>)</span>;</span>
}</span></span></span></span></span>

<span class="d Unittest"><span class="k">unittest</span>
<span class="s FuncBody"><span class="s Compound">{
    <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">r</span> = <span class="e Call"><span class="e Identifier"><span class="i">Random</span></span>(<span class="i">unpredictableSeed</span>)</span>;</span></span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">a</span> = <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">int</span></span><span class="t Array">[<span class="e Call"><span class="e Identifier"><span class="i">uniform</span></span>(<span class="i">r</span>, <span class="n">0</span>, <span class="n">1000</span>)</span>]</span></span>;</span></span>
    <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span>, <span class="o Parameter"><span class="k">ref</span> <span class="i">e</span></span></span>; <span class="e Identifier"><span class="i">a</span></span>) <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">e</span></span> = <span class="e Identifier"><span class="i">i</span></span></span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e Identifier"><span class="i">randomShuffle</span></span>(<span class="i">a</span>, <span class="i">r</span>)</span>;</span>
    <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">b</span> = <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">int</span></span><span class="t Array">[<span class="e Call"><span class="e Identifier"><span class="i">uniform</span></span>(<span class="i">r</span>, <span class="n">0</span>, <span class="i">a</span>.<span class="i">length</span>)</span>]</span></span>;</span></span>
    <span class="s Expression"><span class="e Call"><span class="e TemplateInstance"><span class="i">partialSortCopy</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &lt; b"</span></span></span>)</span></span>)</span>(<span class="i">a</span>, <span class="i">b</span>)</span>;</span>
    <span class="s Expression"><span class="e Assert"><span class="k">assert</span>(<span class="e Call"><span class="e TemplateInstance"><span class="i">isSorted</span>!(<span class="o TemplateArguments"><span class="t TemplateInstance"><span class="i">binaryFun</span>!(<span class="o TemplateArguments"><span class="e String"><span class="sl">"a &lt; b"</span></span></span>)</span></span>)</span>(<span class="i">b</span>)</span>)</span>;</span>
}</span></span></span>

<span class="lc">// Internal random array generators</span>

<span class="d Version"><span class="k">version</span>(<span class="k">unittest</span>)
<span class="d Compound">{
    <span class="d Protection"><span class="k">private</span> <span class="d StorageClass"><span class="k">enum</span> <span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">maxArraySize</span> = <span class="e Int"><span class="n">50</span></span>;</span></span></span>
    <span class="d Protection"><span class="k">private</span> <span class="d StorageClass"><span class="k">enum</span> <span class="d Variables"><span class="t Identifier"><span class="i">size_t</span></span> <span class="i">minArraySize</span> = <span class="e Minus"><span class="e Identifier"><span class="i">maxArraySize</span></span> - <span class="e Int"><span class="n">1</span></span></span>;</span></span></span>

    <span class="d Protection"><span class="k">private</span> <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Identifier"><span class="i">string</span></span><span class="t Array">[]</span> <span class="i">rndstuff</span><span class="o TemplateParameters">(<span class="o TemplateTypeParameter"><span class="i">T</span> : <span class="t Identifier"><span class="i">string</span></span></span>)</span><span class="o Parameters">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="d StorageClass"><span class="k">static</span> <span class="d Variables"><span class="t Identifier"><span class="i">Random</span></span> <span class="i">rnd</span>;</span></span>
        <span class="d StorageClass"><span class="k">static</span> <span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">first</span> = <span class="e Bool"><span class="k">true</span></span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">first</span></span>)
        <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">rnd</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">Random</span></span>(<span class="i">unpredictableSeed</span>)</span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span>
        }</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">string</span></span><span class="t Array">[]</span> <span class="i">result</span> =
            <span class="e New"><span class="k">new</span> <span class="t Identifier"><span class="i">string</span></span><span class="t Array">[<span class="e Call"><span class="e Identifier"><span class="i">uniform</span></span>(<span class="i">rnd</span>, <span class="i">minArraySize</span>, <span class="i">maxArraySize</span>)</span>]</span></span>;</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Identifier"><span class="i">string</span></span> <span class="i">alpha</span> = <span class="e String"><span class="sl">"abcdefghijABCDEFGHIJ"</span></span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="k">ref</span> <span class="i">s</span></span></span>; <span class="e Identifier"><span class="i">result</span></span>)
        <span class="s Compound">{
            <span class="s ForeachRange"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span></span>; <span class="e Int"><span class="n">0</span></span> .. <span class="e Call"><span class="e TemplateInstance"><span class="i">uniform</span>!(<span class="o TemplateArguments"><span class="t Integral"><span class="k">uint</span></span></span>)</span>(<span class="i">rnd</span>, <span class="n">0u</span>, <span class="n">20u</span>)</span>)
            <span class="s Compound">{
                <span class="d StorageClass"><span class="k">auto</span> <span class="d Variables"><span class="i">j</span> = <span class="e Call"><span class="e Identifier"><span class="i">uniform</span></span>(<span class="i">rnd</span>, <span class="n">0</span>, <span class="i">alpha</span>.<span class="i">length</span> - <span class="n">1</span>)</span>;</span></span>
                <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">s</span></span> ~= <span class="e Index"><span class="e Identifier"><span class="i">alpha</span></span>[<span class="e Identifier"><span class="i">j</span></span>]</span></span>;</span>
            }</span></span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
    }</span></span></span></span></span></span>

    <span class="d Protection"><span class="k">private</span> <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">rndstuff</span><span class="o TemplateParameters">(<span class="o TemplateTypeParameter"><span class="i">T</span> : <span class="t Integral"><span class="k">int</span></span></span>)</span><span class="o Parameters">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="d StorageClass"><span class="k">static</span> <span class="d Variables"><span class="t Identifier"><span class="i">Random</span></span> <span class="i">rnd</span>;</span></span>
        <span class="d StorageClass"><span class="k">static</span> <span class="d Variables"><span class="t Integral"><span class="k">bool</span></span> <span class="i">first</span> = <span class="e Bool"><span class="k">true</span></span>;</span></span>
        <span class="s If"><span class="k">if</span> (<span class="e Identifier"><span class="i">first</span></span>)
        <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">rnd</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">Random</span></span>(<span class="i">unpredictableSeed</span>)</span></span>;</span>
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">first</span></span> = <span class="e Bool"><span class="k">false</span></span></span>;</span>
        }</span></span>
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">int</span></span><span class="t Array">[]</span> <span class="i">result</span> = <span class="e New"><span class="k">new</span> <span class="t Integral"><span class="k">int</span></span><span class="t Array">[<span class="e Call"><span class="e Identifier"><span class="i">uniform</span></span>(<span class="i">rnd</span>, <span class="i">minArraySize</span>, <span class="i">maxArraySize</span>)</span>]</span></span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="k">ref</span> <span class="i">i</span></span></span>; <span class="e Identifier"><span class="i">result</span></span>)
        <span class="s Compound">{
            <span class="s Expression"><span class="e Assign"><span class="e Identifier"><span class="i">i</span></span> = <span class="e Call"><span class="e Identifier"><span class="i">uniform</span></span>(<span class="i">rnd</span>, -<span class="n">100</span>, <span class="n">100</span>)</span></span>;</span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
    }</span></span></span></span></span></span>

    <span class="d Protection"><span class="k">private</span> <span class="d Template"><span class="d Compound"><span class="d Function"><span class="t Integral"><span class="k">double</span></span><span class="t Array">[]</span> <span class="i">rndstuff</span><span class="o TemplateParameters">(<span class="o TemplateTypeParameter"><span class="i">T</span> : <span class="t Integral"><span class="k">double</span></span></span>)</span><span class="o Parameters">()</span>
    <span class="s FuncBody"><span class="s Compound">{
        <span class="s Declaration"><span class="d Variables"><span class="t Integral"><span class="k">double</span></span><span class="t Array">[]</span> <span class="i">result</span>;</span></span>
        <span class="s Foreach"><span class="k">foreach</span> (<span class="o Parameters"><span class="o Parameter"><span class="i">i</span></span></span>; <span class="e Call"><span class="e TemplateInstance"><span class="i">rndstuff</span>!(<span class="o TemplateArguments"><span class="t Integral"><span class="k">int</span></span></span>)</span>()</span>)
        <span class="s Compound">{
            <span class="s Expression"><span class="e CatAssign"><span class="e Identifier"><span class="i">result</span></span> ~= <span class="e Div"><span class="e Identifier"><span class="i">i</span></span> / <span class="e Real"><span class="n">50.</span></span></span></span>;</span>
        }</span></span>
        <span class="s Return"><span class="k">return</span> <span class="e Identifier"><span class="i">result</span></span>;</span>
    }</span></span></span></span></span></span>
}</span></span></span>

</pre></td>
</tr></table>
</body>
</html>